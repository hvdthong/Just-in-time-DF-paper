%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/


%% Created for Shane McIntosh at 2014-08-17 16:49:53 -0400 


%% Saved with string encoding Unicode (UTF-8) 


@comment{		JOURNAL PAPERS		}
@comment{		CONFERENCE PAPERS		}
@comment{		Theses			}
@comment{		Textbooks		}
@comment{		WWW		}
@comment{  Tool used for counting lines of code. }
@comment{  Bugzilla homepage. }
@comment{  A blog describing various flaws with Make described as "Myths".   - Portability   - Scalability   - Simplicity   - Speed   - Reliability   - Implied dependencies (e.g., included header files)   - Arcane syntax   - Debugging facilities }
@comment{  A blog describing various flaws with GNU make. Highly opinionated.  Not recommended for reuse... }

@inproceedings{Zhou2010FSE,
 author = {Zhou, Minghui and Mockus, Audris},
 title = {Developer fluency: achieving true mastery in software projects},
 _booktitle = {Proceedings of the eighteenth ACM SIGSOFT international symposium on Foundations of software engineering},
 booktitle = {Proc. the Int'l Symposium on Foundations of Software Engineering (FSE'10)},
 year = {2010},
 pages = {137--146},
}

@article{thongtanunam2016emse,
  Author = {Patanamon Thongtanunam and Shane McIntosh and Ahmed E. Hassan and Hajimu Iida},
  Title = {{Review Participation in Modern Code Review: An Empirical Study of the Android, Qt, and OpenStack Projects}},
  Year = {2016},
  Journal = {Empirical Software Engineering},
  
  
  Pages = {To appear}
}

@inproceedings{nam2013icse,
 author = {Nam, Jaechang and Pan, Sinno Jialin and Kim, Sunghun},
 title = {Transfer Defect Learning},
 booktitle = {{Proc. of the Int'l Conf. on Software Engineering (ICSE)}},
 year = {2013},
 pages = {382--391}
} 


@inproceedings{shimagaki2016icseseip,
 author = {Shimagaki, Junji and Kamei, Yasutaka and McIntosh, Shane and Hassan, Ahmed E. and Ubayashi, Naoyasu},
 title = {A Study of the Quality-impacting Practices of Modern Code Review at Sony Mobile},
 booktitle = {{Proc. of the Int'l Conf. on Software Engineering (ICSE), SEIP Track}},
 year = {2016},
 pages = {212--221}
} 

@inproceedings{morales2015saner,
 author = {Rodrigo Morales and Shane McIntosh and Foutse Khomh },
 title = {{Do Code Review Practices Impact Design Quality? A Case Study of the Qt, VTK, and ITK Projects}},
 booktitle = {{Proc. of the Int'l Conf. on Software Engineering (ICSE)}},
 year = {2015},
 pages = {171--180}
}

@article{menzies2013tse,
	Author = {Tim Menzies and Andrew Butcher and David Cok and Andrian Marcus and Lucas Layman and Forrest Shull and Burak Turhan and Thomas Zimmermann} ,
	Journal = {{Transactions on Software Engineering (TSE)}},
	Number = {6},
	Pages = {334--345},
	Title = {{Local versus Global Lessons for Defect Prediction and Effort Estimation}},
	Volume = {39},
	Year = {2013},
}

@inproceedings{kim2007icse,
 author = {Kim, Sunghun and Zimmermann, Thomas and Whitehead Jr., E. James and Zeller, Andreas},
 title = {{Predicting Faults from Cached History}},
 booktitle = {{Proc. of the 29th Int'l Conf. on Software Engineering (ICSE)}},
 year = {2007},
 pages = {489--498}
}

@incollection{zimmermann2008evolution,
    title = "Predicting Bugs from History",
    author = {Zimmermann, Thomas and Nagappan, Nachiappan and Zeller, Andreas },
    year = "2008",
    booktitle = "Software Evolution",
    chapter = "4",
    editors = "Tom Mens and Serge Demeyer",
    pages = "69--88",
    publisher = "Springer"
}


@book{splbook,
	Author = {Paul Clements and Linda Northrop},
	Date-Added = {2014-08-17 20:39:52 +0000},
	Date-Modified = {2014-08-17 20:40:46 +0000},
	Publisher = {Addison-Wesley},
	Title = {{Software Product Lines: Practices and Patterns}},
	Year = {2002}}

@book{lientz1980,
	Author = {Bennet P. Lientz and E. Burton Swanson},
	Date-Added = {2014-08-16 21:33:23 +0000},
	Date-Modified = {2014-08-16 21:36:05 +0000},
	Publisher = {Addison-Wesley},
	Title = {{Software Maintenance Management: A Study of the Maintenance of Computer Application Software in 487 Data Processing Organizations}},
	Year = {1980}}

@inproceedings{alkofahi2014icsme,
	Author = {Jafar Al-Kofahi and Hung Viet Nguyen and Tien N. Nguyen},
	Booktitle = {{Proc. of the 30th Int'l Conf. on Software Maintenance and Evolution (ICSME)}},
	Date-Added = {2014-08-16 21:16:42 +0000},
	Date-Modified = {2014-08-16 21:18:30 +0000},
	Pages = {To appear},
	Title = {{Fault Localization for Make-Based Build Crashes}},
	Year = {2014}}

@article{deissenboeck2008ieeesw,
	Abstract = {Over time, software systems suffer gradual quality decay and therefore costs can rise if organizations fail to take proactive countermeasures. Quality control is the first step to avoiding this cost trap. Continuous quality assessments help users identify quality problems early, when their removal is still inexpensive; they also aid decision making by providing an integrated view of a software system's current status. As a side effect, continuous and timely feedback helps developers and maintenance personnel improve their skills and thereby decreases the likelihood of future quality defects. To make regular quality control feasible, it must be highly automated, and assessment results must be presented in an aggregated manner to avoid overwhelming users with data. This article offers an overview of tools that aim to address these issues. The authors also discuss their own flexible, open-source toolkit, which supports the creation of dashboards for quality control.},
	Author = {Florian Deissenboeck and Elmar Juergens and Benjamin Hummel and Stefan Wagner and Benedikt Mas y Parareda and Markus Pizka},
	Date-Added = {2014-08-16 02:52:16 +0000},
	Date-Modified = {2014-08-16 02:53:47 +0000},
	Journal = {IEEE Software},
	Number = {5},
	Pages = {60--67},
	Title = {{Tool Support for Continuous Quality Control}},
	Volume = {25},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJS4uL1BhcGVycy9pZWVlc3cyMDA4X2RlaXNzZW5ib2Vjay5wZGbSFwsYGVdOUy5kYXRhTxEBtgAAAAABtgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OG2llZWVzdzIwMDhfZGVpc3NlbmJvZWNrLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG1XH/PK3MeAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADPK7luAAAAAQAMAAoODgAJZz8ACWc8AAIARk1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpZWVlc3cyMDA4X2RlaXNzZW5ib2Vjay5wZGYADgA4ABsAaQBlAGUAZQBzAHcAMgAwADAAOABfAGQAZQBpAHMAcwBlAG4AYgBvAGUAYwBrAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA2VXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWVlZXN3MjAwOF9kZWlzc2VuYm9lY2sucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AtgC7AMMCfQJ/AoQCjwKYAqYCqgKxAroCvwLMAs8C4QLkAukAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6w==}}

@inproceedings{telea2008csmr,
	Abstract = {We present Build Analyzer, a tool that helps developers optimize the build performance of huge systems written in C. Due to complex C header dependencies, even small code changes can cause extremely long rebuilds, which are problematic when code is shared and modified by teams of hundreds of individuals. Build Analyzer supports several use cases. For developers, it provides an estimate of the build impact and distribution caused by a given change. For architects, it shows why a build is costly, how its cost is spread over the entire code base, which headers cause build bottlenecks, and suggests ways to refactor these to reduce the cost. We demonstrate Build Analyzer with a use-case on a real industry code base.},
	Author = {Alexandru Telea and Lucian Voinea},
	Booktitle = {{Proc. of the 12th European Conf. on Software Maintenance and Reengineering (CSMR)}},
	Date-Added = {2014-08-14 00:53:37 +0000},
	Date-Modified = {2014-08-14 00:56:08 +0000},
	Pages = {323--325},
	Title = {{A Tool for Optimizing the Build Performance of Large Software Code Bases}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9jc21yMjAwOF90ZWxlYS5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmNzbXIyMDA4X3RlbGVhLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKOWdrQEYEsAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADQEblsAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBjc21yMjAwOF90ZWxlYS5wZGYAAA4AJgASAGMAcwBtAHIAMgAwADAAOABfAHQAZQBsAGUAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2NzbXIyMDA4X3RlbGVhLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{unphon2009shark,
	Abstract = {This paper presents an empirical study of how the application of genuine architecture can be employed beyond the design phase of product line development. The study is based on a co-operative research project with a company developing product line architecture for hydraulic modelling software. By concretising the architecture as a build hierarchy the architecture mediates the evolution of the design throughout the whole software life cycle. The empirical evidence has confirmed the improvements of (1) the software quality and flexibility, (2) the communication and cooperation with new developers, (3) the distribution of work and parallel implementation, and (4) the foreseen usage by hydraulic and environmental consultants who tailor the software. Our research further indicates requirements for the architectural analysis tools that are deliberately embedded in the daily development practices.},
	Author = {Hataichanok Unphon},
	Booktitle = {{Proc. of the 4th Int'l Workshop on SHAring and Reusing architectural Knowledge (SHARK)}},
	Date-Added = {2014-08-14 00:42:01 +0000},
	Date-Modified = {2014-08-14 00:45:37 +0000},
	Pages = {41--48},
	Title = {{Making Use of Architecture throughout the Software Life Cycle - How the Build Hierarchy can Facilitate Product Line Development}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9zaGFyazIwMDlfdW5waG9uLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4Uc2hhcmsyMDA5X3VucGhvbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo5R5tARfpkAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANARttkAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHNoYXJrMjAwOV91bnBob24ucGRmAAAOACoAFABzAGgAYQByAGsAMgAwADAAOQBfAHUAbgBwAGgAbwBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvc2hhcmsyMDA5X3VucGhvbi5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{buffenbarger2013releng,
	Abstract = {This paper explains how to improve the quality of an existing Makefile-based build system, using a new variant of Make. Ordinary file-oriented dependencies are detected, recorded, and monitored automatically. Checksums are compared, rather than timestamps. Other important dependencies are also processed automatically. This provides an accurate, compact, and low-maintenance build system. Experiences with the Linux kernel/driver build system are described.},
	Author = {Jim Buffenbarger},
	Booktitle = {{Proc. of the 1st Int'l Workshop on RELease ENGineering (RELENG)}},
	Date-Added = {2014-08-14 00:26:29 +0000},
	Date-Modified = {2014-08-17 20:49:53 +0000},
	Pages = {1--4},
	Title = {{Adding Automatic Dependency Processing to Makefile-Based Build Systems with Amake}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJS4uL1BhcGVycy9yZWxlbmcyMDEzX2J1ZmZlbmJhcmdlci5wZGbSFwsYGVdOUy5kYXRhTxEBtgAAAAABtgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OG3JlbGVuZzIwMTNfYnVmZmVuYmFyZ2VyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKOPQDQEXr1AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADQEbM1AAAAAQAMAAoODgAJZz8ACWc8AAIARk1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgByZWxlbmcyMDEzX2J1ZmZlbmJhcmdlci5wZGYADgA4ABsAcgBlAGwAZQBuAGcAMgAwADEAMwBfAGIAdQBmAGYAZQBuAGIAYQByAGcAZQByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA2VXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvcmVsZW5nMjAxM19idWZmZW5iYXJnZXIucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AtgC7AMMCfQJ/AoQCjwKYAqYCqgKxAroCvwLMAs8C4QLkAukAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6w==}}

@inproceedings{simpson2007agile,
	Abstract = {Should we use build and deployment teams on large projects? Build and deployment work often emerges as a specialization on project teams. This specialization becomes important on medium to large projects as the complexity of deploying code and configuring enterprise environments increases. However, how do we coordinate the work of this team with the work of the development teams and how do we ensure this team helps the development team that it serves rather than hinders it? In this report we share the experience of an eight person distributed agile build team on a large bespoke software project at an investment bank. The report spans the formation of the team from the USA, the UK and India to the adjournment of the team after finishing the deployment to production on time without fuss. Topics include: how we worked in a distributed agile 8-10 person team in San Francisco and London, how we used agile methods to track build and deployment tasks; how we worked in iterations, estimated the work for each iteration, and tracked velocity over time.},
	Author = {Julian Simpson and Shane Duan},
	Booktitle = {{Proc. of the Agile 2007 Conf.}},
	Date-Added = {2014-08-14 00:22:15 +0000},
	Date-Modified = {2014-08-14 00:24:34 +0000},
	Pages = {359--364},
	Title = {{Large Build Teams: Help or Hindrance?}},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9hZ2lsZTIwMDdfc2ltcHNvbi5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWFnaWxlMjAwN19zaW1wc29uLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKONX3QEXm1AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADQEbH1AAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBhZ2lsZTIwMDdfc2ltcHNvbi5wZGYADgAsABUAYQBnAGkAbABlADIAMAAwADcAXwBzAGkAbQBwAHMAbwBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvYWdpbGUyMDA3X3NpbXBzb24ucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{brooks2008agile,
	Abstract = {The use of automated build and continuous integration systems by software teams is a well-established practice, and has been shown to provide significant benefits. However, to qualify the value of continuous integration practices it is necessary to to compare their cost with the associated benefit. When considering automated builds or continuous integration in an agile team, this cost is the time taken by developers to run the build script and automated tests before code can be committed and/or deployed. This paper discusses the effect of this time on team behaviour by comparing two projects with significantly different build times.},
	Author = {Graham Brooks},
	Booktitle = {{Proc. of the Agile 2008 Conf.}},
	Date-Added = {2014-08-14 00:14:48 +0000},
	Date-Modified = {2014-08-14 00:20:38 +0000},
	Pages = {294--297},
	Title = {{Team Pace - Keeping Build Times Down}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9hZ2lsZTIwMDhfYnJvb2tzLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UYWdpbGUyMDA4X2Jyb29rcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo4uZdAReR0AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANARsV0AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGFnaWxlMjAwOF9icm9va3MucGRmAAAOACoAFABhAGcAaQBsAGUAMgAwADAAOABfAGIAcgBvAG8AawBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvYWdpbGUyMDA4X2Jyb29rcy5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{slawinska2007ipdps,
	Abstract = {Fast hardware turnover in supercomputing centers, stimulated by rapid technological progress, results in high heterogeneity among HPC platforms, and necessitates that applications are ported and adapted frequently. The cutting-edge nature of the hardware mandates customized performance tuning, which, coupled with continuously growing application complexity, makes the process inherently and increasingly challenging. In this paper, we analyze build procedures of a representative set of HPC applications, and attempt to identify commonalities that can be exploited to enhance cross-platform portability. We then propose a novel method for reducing non-portabilities while preserving high performance. The approach, based on profiles that capture and isolate non-portable features at various levels, requires only a moderate amount of changes to existing makefiles. It leverages the expertise of system designers and administrators, and reduces burdens placed on application scientists. As a proof of concept, we discuss the application of our methodology to enhancing portability of the Mile application across heterogeneous HPC platforms.},
	Author = {Magdalena S\l{}awi\'{n}ska and Jaros\l{}aw S\l{}awi\'{n}ski and Dawid Kurzyniec and Vaidy Sunderam},
	Booktitle = {{Proc. of the 21st Int'l Parallel and Distributed Processing Symposium (IPDPS)}},
	Date-Added = {2014-08-14 00:08:03 +0000},
	Date-Modified = {2014-08-14 01:09:29 +0000},
	Pages = {1--8},
	Title = {{Enhancing Portability of HPC Applications across High-end Computing Platforms}},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIS4uL1BhcGVycy9pcGRwczIwMDdfc2xhd2luc2thLnBkZtIXCxgZV05TLmRhdGFPEQGmAAAAAAGmAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4XaXBkcHMyMDA3X3NsYXdpbnNrYS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo4g0tARduwAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANARrywAAAABAAwACg4OAAlnPwAJZzwAAgBCTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGlwZHBzMjAwN19zbGF3aW5za2EucGRmAA4AMAAXAGkAcABkAHAAcwAyADAAMAA3AF8AcwBsAGEAdwBpAG4AcwBrAGEALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADJVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pcGRwczIwMDdfc2xhd2luc2thLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALIAtwC/AmkCawJwAnsChAKSApYCnQKmAqsCuAK7As0C0ALVAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtc=}}

@article{dubois2003cise,
	Abstract = {The title of this article refers to Rudolph Flesch's famous 1955 book, "Why Johnny Can't Read", which called attention to a nationwide decline in reading ability. Here, the author wants to talk about another situation in which an important ability is lacking: the ability to create significant, portable scientific software. The author discusses some of the reasons this problem exists and suggests some approaches to solving it that seem promising.},
	Author = {Paul F. Dubois and Thomas Epperly and Gary Kumfert},
	Date-Added = {2014-08-13 23:59:44 +0000},
	Date-Modified = {2014-08-14 00:03:27 +0000},
	Journal = {Computing in Science and Engineering},
	Number = {5},
	Pages = {83--88},
	Title = {{Why Johnny Can't Build}},
	Volume = {5},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9jaXNlMjAwM19kdWJvaXMucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNjaXNlMjAwM19kdWJvaXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACjhLh0BF1FgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAA0BGtVgAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAY2lzZTIwMDNfZHVib2lzLnBkZgAOACgAEwBjAGkAcwBlADIAMAAwADMAXwBkAHUAYgBvAGkAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2Npc2UyMDAzX2R1Ym9pcy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{slawinska2008ipdps,
	Abstract = {The paper addresses the build problem in the HPC arena that results from heterogeneity in hardware architectures, system software, and application build systems. We propose a new approach that generalizes current build systems, and enhances their portability across heterogeneous high-end platforms. Although the original application build system needs to be modified it is a one-time activity that allows us to extract target platform specific information and store it into profiles. Our toolkit exploits profiles to retrieve appropriate target-specific information during the actual build process. Our developed mechanism termed late binding enables dynamic concretization of platform-specific variables from profiles. This approach simplifies the build process for heterogeneous environments, promotes profile reuse, and improves its portability. In order to verify our approach in practice we have applied our methodology to a production molecular dynamics code (the CPMD application).},
	Author = {Magdalena S\l{}awi\'{n}ska and Jaros\l{}aw S\l{}awi\'{n}ski and Vaidy Sunderam},
	Booktitle = {{Proc. of the 22nd Int'l Parallel and Distributed Processing Symposium (IPDPS)}},
	Date-Added = {2014-08-13 23:53:47 +0000},
	Date-Modified = {2014-08-14 01:09:20 +0000},
	Pages = {1--8},
	Title = {{Enhancing Build-Portability for Scientific Applications Across Heterogeneous Platforms}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIS4uL1BhcGVycy9pcGRwczIwMDhfc2xhd2luc2thLnBkZtIXCxgZV05TLmRhdGFPEQGmAAAAAAGmAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4XaXBkcHMyMDA4X3NsYXdpbnNrYS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo4EE9ARcxMAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANARq1MAAAABAAwACg4OAAlnPwAJZzwAAgBCTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGlwZHBzMjAwOF9zbGF3aW5za2EucGRmAA4AMAAXAGkAcABkAHAAcwAyADAAMAA4AF8AcwBsAGEAdwBpAG4AcwBrAGEALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADJVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pcGRwczIwMDhfc2xhd2luc2thLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALIAtwC/AmkCawJwAnsChAKSApYCnQKmAqsCuAK7As0C0ALVAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtc=}}

@inproceedings{slawinska2009ipdps,
	Abstract = {High-end machines at modern HPC centers are constantly undergoing hardware and system software upgrades - necessitating frequent rebuilds of application codes. The number of possible combinations of compilers, libraries, application build configurations, differing hardware architectures, etc, makes the process of building applications very onerous, requiring expert build knowledge from different domains. Our ongoing Harness Workbench Toolkit (HWT) project aims to foster and streamline the entire build process on heterogeneous computational platforms. This paper focuses on a key research issue of the HWT that regards facilitating and enhancement portability of build systems across multifarious machines, with particular respect to scientific software commonly used in the HPC community. The article presents a novel HWT approach based on the concept of generic build systems and profiles which encapsulate build knowledge provided independently by relevant experts. The paper describes profiles, the logistics of storing and retrieving build information, and interfacing to user-guided builds. We also report on experiences with applying the HWT approach to two scientific production codes (CPMD, GAMESS) on Cray XT4.},
	Author = {Magdalena S\l{}awi\'{n}ska and Jaros\l{}aw S\l{}awi\'{n}ski and Vaidy Sunderam},
	Booktitle = {{Proc. of the 23rd Int'l Parallel and Distributed Processing Symposium (IPDPS)}},
	Date-Added = {2014-08-13 23:40:33 +0000},
	Date-Modified = {2014-08-14 01:10:06 +0000},
	Pages = {1--8},
	Title = {{Portable Builds of HPC Applications on Diverse Target Platforms}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIS4uL1BhcGVycy9pcGRwczIwMDlfc2xhd2luc2thLnBkZtIXCxgZV05TLmRhdGFPEQGmAAAAAAGmAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4XaXBkcHMyMDA5X3NsYXdpbnNrYS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo38qNARcY0AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANARqc0AAAABAAwACg4OAAlnPwAJZzwAAgBCTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGlwZHBzMjAwOV9zbGF3aW5za2EucGRmAA4AMAAXAGkAcABkAHAAcwAyADAAMAA5AF8AcwBsAGEAdwBpAG4AcwBrAGEALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADJVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pcGRwczIwMDlfc2xhd2luc2thLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALIAtwC/AmkCawJwAnsChAKSApYCnQKmAqsCuAK7As0C0ALVAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtc=}}

@inproceedings{elsner2011splc,
	Abstract = {Deriving a product from a software product line may require various build tasks, such as model transformations, source code generation, preprocessing, compiling, as well as linking and packaging the compiled sources. Usually implemented using simple scripting languages, such as Apache ant or GNU make, build systems tend to become monolithic entities, which are intricate to adapt and maintain.

This makes developing the build system for a multi-- product-line, which is composed of several sub--product-lines and maybe other configurable components, particularly challenging. Several, previously independent build systems--- possibly implemented using different build tools (ant, make, etc.)---need to be integrated. In this paper, we approach this by using models to describe the involved build tasks (including their input and output parameters) as well as their composition. An interpreter evaluates the models and executes the tasks in the composed order with the configured parameters to produce the final product.

Our approach enables the interaction of build systems implemented with different tools with only little development effort, whereas the build order and parameter flow is made explicit in the models. We have started to apply our tooling to model the build system of two multi--product-lines, where it reveals sufficient expressiveness and clarifies the build system interaction.},
	Author = {Christoph Elsner and Daniel Lohmann and Wolfgang Schr\"{o}der-Preikschat},
	Booktitle = {{Proc. of the 15th Int'l Software Product Line Conference (SPLC)}},
	Date-Added = {2014-08-13 21:23:10 +0000},
	Date-Modified = {2014-08-13 21:26:24 +0000},
	Pages = {18:1--18:8},
	Title = {{An Infrastructure for Composing Build Systems of Software Product Lines}},
	Volume = {2},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9zcGxjMjAxMV9lbHNuZXIucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNzcGxjMjAxMV9lbHNuZXIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACjedL0BFPtgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAA0BGH9gAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAc3BsYzIwMTFfZWxzbmVyLnBkZgAOACgAEwBzAHAAbABjADIAMAAxADEAXwBlAGwAcwBuAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3NwbGMyMDExX2Vsc25lci5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{downs2012icse,
	Abstract = {We describe the evaluation of a build awareness system that assists agile software development teams to understand current build status and who is responsible for any build breakages. The system uses ambient awareness technologies, providing a separate, easily perceived communication channel distinct from standard team workflow. Multiple system configurations and behaviours were evaluated. An evaluation of the system showed that, while there was no significant change in the proportion of build breakages, the overall number of builds increased substantially, and the duration of broken builds decreased. Team members also reported an increased sense of awareness of, and responsibility for, broken builds and some noted the system dramatically changed their perception of the build process making them more cognisant of broken builds.},
	Author = {John Downs and Beryl Plimmer and John G. Hosking},
	Booktitle = {{Proc. of the 34th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2014-08-13 20:54:33 +0000},
	Date-Modified = {2014-08-13 21:21:10 +0000},
	Pages = {507--517},
	Title = {{Ambient Awareness of Build Status in Collocated Software Teams}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9pY3NlMjAxMl9kb3ducy5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmljc2UyMDEyX2Rvd25zLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKN4z/QEU7yAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADQEYcyAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAxMl9kb3ducy5wZGYAAA4AJgASAGkAYwBzAGUAMgAwADEAMgBfAGQAbwB3AG4AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2UyMDEyX2Rvd25zLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{passos2013splc,
	Author = {Leonardo Passos and Jianmei Guo and Leopoldo Teixeira and Krzysztof Czarnecki and Andrzej Wasowski and Paulo Borba},
	Booktitle = {{Proc. of the 17th Software Product Line Conference (SPLC)}},
	Date-Added = {2014-08-11 12:01:34 +0000},
	Date-Modified = {2014-08-14 01:15:54 +0000},
	Pages = {91--100},
	Title = {{Coevolution of Variability Models and Related Artifacts: A Case Study from the Linux Kernel}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9zcGxjMjAxM19wYXNzb3MucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNzcGxjMjAxM19wYXNzb3MucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACjmNH0BGF7wAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAA0BG+LwAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAc3BsYzIwMTNfcGFzc29zLnBkZgAOACgAEwBzAHAAbABjADIAMAAxADMAXwBwAGEAcwBzAG8AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3NwbGMyMDEzX3Bhc3Nvcy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{kastner2011oopsla,
	Abstract = {In many projects, lexical preprocessors are used to manage different variants of the project (using conditional compilation) and to define compile-time code transformations (using macros). Unfortunately, while being a simple way to implement variability, conditional compilation and lexical macros hinder automatic analysis, even though such analysis is urgently needed to combat variability-induced complexity. To analyze code with its variability, we need to parse it without preprocessing it. However, current parsing solutions use unsound heuristics, support only a subset of the language, or suffer from exponential explosion. As part of the TypeChef project, we contribute a novel variability-aware parser that can parse almost all unpreprocessed code without heuristics in practicable time. Beyond the obvious task of detecting syntax errors, our parser paves the road for further analysis, such as variability-aware type checking. We implement variability-aware parsers for Java and GNU C and demonstrate practicability by parsing the product line MobileMedia and the entire X86 architecture of the Linux kernel with 6065 variable features.},
	Author = {Christian K\"{a}stner and Paolo G. Giarrusso and Tillmann Rendel and Sebastian Erdweg and Klaus Ostermann and Thorsten Berger},
	Booktitle = {{Proc. of the 26th Int'l Conf. on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)}},
	Date-Added = {2014-08-11 11:44:04 +0000},
	Date-Modified = {2014-08-11 11:49:30 +0000},
	Pages = {805--824},
	Title = {{Variability-Aware Parsing in the Presence of Lexical Macros and Conditional Compliation}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9vb3BzbGEyMDExX2thc3RuZXIucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZvb3BzbGEyMDExX2thc3RuZXIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACjE6A0A4lJgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAA0A5dZgAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAb29wc2xhMjAxMV9rYXN0bmVyLnBkZgAADgAuABYAbwBvAHAAcwBsAGEAMgAwADEAMQBfAGsAYQBzAHQAbgBlAHIALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9vb3BzbGEyMDExX2thc3RuZXIucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@article{nadi2014jsep,
	Abstract = {Although build systems control what code gets compiled into the final built product, they are often overlooked when studying software variability. The Linux kernel is one of the biggest open source software systems supporting variability and contains over 10,000 configurable features described in its kconfig files. To understand the role of the build system in variability implementation, we use Linux as a case study. We study its build system, kbuild, and extract the variability constraints in its Makefiles. We first provide a quantitative analysis of the variability in kbuild. We then study how the variability constraints in the build system affect variability anomalies detected in Linux. We concentrate on dead and undead artifacts, and by extending previous work, we show that considering build system variability constraints allows more anomalies to be detected. We provide examples of such anomalies on both the code block and source file level. Our work shows that kbuild contains a large percentage of the variability information in Linux, so it should not be ignored during variability analysis. Nonetheless, the anomalies we find suggest that variability on the file level in kbuild is consistent with kconfig, whereas the constraints on the code level are harder to keep consistent with both kbuild and kconfig.},
	Author = {Sarah Nadi and Ric Holt},
	Date-Added = {2014-08-11 02:31:28 +0000},
	Date-Modified = {2014-08-11 02:43:21 +0000},
	Journal = {Journal of Software: Evolution and Practice (JSEP)},
	Pages = {To appear},
	Title = {{The Linux kernel: a case study of build system variability}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9qc2VwMjAxNF9uYWRpLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RanNlcDIwMTRfbmFkaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAowjQdANpDEAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANAN3HEAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGpzZXAyMDE0X25hZGkucGRmAA4AJAARAGoAcwBlAHAAMgAwADEANABfAG4AYQBkAGkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9qc2VwMjAxNF9uYWRpLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@inproceedings{mcintosh2014icsme,
	Abstract = {As a software project ages, its source code is modified to add new features, restructure existing ones, and fix defects. These source code changes often induce changes in the build system, i.e., the system that specifies how source code is translated into deliverables. However, since developers are often not familiar with the complex and occasionally archaic technologies used to specify build systems, they may not be able to identify when their source code changes require accompanying build system changes. This can cause build breakages that slow development progress and impact other developers, testers, or even users. In this paper, we mine the source and test code changes that required accompanying build changes in order to better understand this co-change relationship. We build random forest classifiers using language-agnostic and language-specific code change characteristics to explain when code-accompanying build changes are necessary based on historical trends. Case studies of the Mozilla C++ system, the Lucene and Eclipse open source Java systems, and the IBM Jazz proprietary Java system indicate that our classifiers can accurately explain when build co- changes are necessary with an AUC of 0.60-0.88. Unsurprisingly, our highly accurate C++ classifiers (AUC of 0.88) derive much of their explanatory power from indicators of structural change (e.g., was a new source file added?). On the other hand, our Java classifiers are less accurate (AUC of 0.60-0.78) because roughly 75% of Java build co-changes do not coincide with changes to the structure of a system, but rather are instigated by concerns related to release engineering, quality assurance, and general build maintenance.},
	Author = {Shane McIntosh and Bram Adams and Meiyappan Nagappan and Ahmed E. Hassan},
	Booktitle = {{Proc. of the 30th Int'l Conf. on Software Maintenance and Evolution (ICSME)}},
	Date-Added = {2014-08-11 01:31:41 +0000},
	Date-Modified = {2014-08-11 01:33:08 +0000},
	Pages = {To appear},
	Title = {{Mining Co-Change Information to Understand when Build Changes are Necessary}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9pY3NtZTIwMTRfbWNpbnRvc2gucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZpY3NtZTIwMTRfbWNpbnRvc2gucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACjANR0A2VuQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAA0A3N+QAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzbWUyMDE0X21jaW50b3NoLnBkZgAADgAuABYAaQBjAHMAbQBlADIAMAAxADQAXwBtAGMAaQBuAHQAbwBzAGgALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pY3NtZTIwMTRfbWNpbnRvc2gucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@article{xia2014ieice,
	Abstract = {A build system converts source code, libraries and other data into executable programs by orchestrating the execution of compilers and other tools. The whole building process is managed by a software build system, such as Make, Ant, CMake, Maven, Scons, and QMake. Many studies have investigated bugs and fixes in several systems, but to our best knowledge, none focused on bugs in build systems. One significant feature of software build systems is that they should work on various platforms, i.e., various operating systems (e.g., Windows, Linux), various development environments (e.g., Eclipse, Visual Studio), and various programming languages (e.g., C, C++, Java, C#), so the study of software build systems deserves special consideration. In this paper, we perform an empirical study on bugs in software build systems. We analyze four software build systems, Ant, Maven, CMake and QMake, which are four typical and widely-used software build systems, and can be used to build Java, C, C++ systems. We investigate their bug database and code repositories, randomly sample a set of bug reports and their fixes (800 bugs reports totally, and 199, 250, 200, and 151 bug reports for Ant, Maven, CMake and QMake, respectively), and manually assign them into various categories. We find that 21.35% of the bugs belong to the external interface category, 18.23% of the bugs belong to the logic category, and 12.86% of the bugs belong to the configuration category. We also investigate the relationship between bug categories and bug severities, bug fixing time, and number of bug comments.},
	Author = {Xin Xia and Xiaozhen Zhou and David Lo and Xiaoqiong Zhao and Ye Wang},
	Date-Added = {2014-08-11 01:10:50 +0000},
	Date-Modified = {2014-08-11 01:14:32 +0000},
	Journal = {IEICE Transactions on Information and Systems},
	Number = {7},
	Pages = {1769--1780},
	Title = {{An Empirical Study of Bugs in Software Build System}},
	Volume = {E97-D},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9pZWljZTIwMTRfeGlhLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RaWVpY2UyMDE0X3hpYS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAov5XdANkVkAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANANyZkAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGllaWNlMjAxNF94aWEucGRmAA4AJAARAGkAZQBpAGMAZQAyADAAMQA0AF8AeABpAGEALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pZWljZTIwMTRfeGlhLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@inproceedings{xia2013qsic,
	Abstract = {Build system converts source code, libraries and other data into executable programs by orchestrating the execution of compilers and other tools. The whole building process is managed by a software build system, such as Make, Ant, CMake, Maven, Scons, and QMake. The reliability of software build systems would affect the reliability of the build process. In this paper, we perform an empirical study on bugs in software build systems. We analyze four software build systems, Ant, Maven, CMake and QMake, which are four typical and widely-used software build systems, and can be used to build Java, C, C++ systems. We investigate their bug database and code repositories, randomly sample a set of bug reports and their fixes (800 bugs reports totally, and 199, 250, 200, and 151 bug reports for Ant, Maven, CMake and QMake, respectively), and manually assign them into various categories. We find that 21.35% of the bugs belong to the external interface category, 18.23% of the bugs belong to the logic category, and 12.86% of the bugs belong to the configuration category. We also investigate the relationship between bug categories and bug severities.},
	Author = {Xin Xia and Xiaozhen Zhou and David Lo and Xiaoqiong Zhao},
	Booktitle = {{Proc. of the 13th Int'l Conf. on Quality Software (QSIC)}},
	Date-Added = {2014-08-11 01:01:30 +0000},
	Date-Modified = {2014-08-11 01:03:39 +0000},
	Pages = {200--203},
	Title = {{An Empirical Study of Bugs in Software Build Systems}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy9xc2ljMjAxM194aWEucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhBxc2ljMjAxM194aWEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGotozmxblQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzmyT1QAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAcXNpYzIwMTNfeGlhLnBkZgAADgAiABAAcQBzAGkAYwAyADAAMQAzAF8AeABpAGEALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9xc2ljMjAxM194aWEucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@inproceedings{nadi2014icse,
	Abstract = {Highly-configurable systems allow users to tailor the software to their specific needs. Not all combinations of configuration options are valid though, and constraints arise for technical or non-technical reasons. Explicitly describing these constraints in a variability model allows reasoning about the supported configurations. To automate creating variability models, we need to identify the origin of such configuration constraints. We propose an approach which uses build-time errors and a novel feature-effect heuristic to automatically extract configuration constraints from C code. We conduct an empirical study on four highly-configurable open-source systems with existing variability models having three objectives in mind: evaluate the accuracy of our approach, determine the recoverability of existing variability-model constraints using our analysis, and classify the sources of variability-model constraints. We find that both our extraction heuristics are highly accurate (93% and 77% respectively), and that we can recover 19% of the existing variability-models using our approach. However, we find that many of the remaining constraints require expert knowledge or more expensive analyses. We argue that our approach, tooling, and experimental results support researchers and practitioners working on variability model re-engineering, evolution, and consistency-checking techniques. },
	Author = {Sarah Nadi and Thorsten Berger and Christian K\"{a}stner and Krzysztof Czarnecki},
	Booktitle = {{Proc. of the 36th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2014-08-11 00:49:19 +0000},
	Date-Modified = {2014-08-11 00:53:35 +0000},
	Pages = {140--151},
	Title = {{Mining Configuration Constraints: Static Analyses and Empirical Results}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9pY3NlMjAxNF9uYWRpLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RaWNzZTIwMTRfbmFkaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAovw9tANjDcAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANANxHcAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc2UyMDE0X25hZGkucGRmAA4AJAARAGkAYwBzAGUAMgAwADEANABfAG4AYQBkAGkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pY3NlMjAxNF9uYWRpLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@inproceedings{shridhar2014esem,
	Abstract = {Context: Recent empirical studies have shown quantitatively how software build systems, which are responsible for con- verting software artifacts into an installable deliverable for the end user, induce considerable overhead on software de- velopers, taking away their focus from actual development. Goal: Little, however, is known of what are the typical types of changes that these developers need to make to build sys- tems, the characteristics of these changes and whether de- velopers work on these changes by themselves, or are co- ordinated by build experts.
Method: This paper qualitatively investigates the build com- mit history of 18 open-source projects from the Apache and Eclipse eco-systems, over a period of fourteen months, using manual tagging and classification of change types and build system ownership styles.
Results: ``Corrective'', ``Adaptive'' and ``New Functionality'' build changes introduce considerably higher churn and are more invasive, while many changes are identified by accident during regular development. Having dedicated build experts allows software projects to make more invasive ``Adaptive'' changes.
Conclusions: Build system studies need to take into account the type of build change, since not all build changes are equal.},
	Author = {Mini Shridhar and Bram Adams and Foutse Khomh},
	Booktitle = {{Proc. of the 8th Int'l Symposium on Empirical Software Engineering and Measurement (ESEM)}},
	Date-Added = {2014-08-11 00:41:18 +0000},
	Date-Modified = {2014-08-11 00:46:20 +0000},
	Pages = {To appear},
	Title = {{A Qualitative Analysis of Software Build System Changes and Build Ownership Styles}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9lc2VtMjAxNF9zaHJpZGhhci5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWVzZW0yMDE0X3NocmlkaGFyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ9UKTQASPfAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADQAVwfAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBlc2VtMjAxNF9zaHJpZGhhci5wZGYADgAsABUAZQBzAGUAbQAyADAAMQA0AF8AcwBoAHIAaQBkAGgAYQByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvZXNlbTIwMTRfc2hyaWRoYXIucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{kerzazi2014icsme,
	Abstract = {To detect integration errors as quickly as possible, organizations use automated build systems. Such systems ensure that (1) the developers are able to integrate their parts into an executable whole; (2) the testers are able to test the built system; (3) and the release engineers are able to leverage the generated build to produce the upcoming release. The flipside of automated builds is that any incorrect change can break the build, and hence testing and releasing, and (even worse) block other developers from continuing their work, delaying the project even further. To measure the impact of such build breakage, this empirical study analyzes 3,214 builds produced in a large software company over a period of 6 months. We found a high ratio of build breakage (17.9%), and also quantified the cost of such build breakage as more than 336.18 man-hours. Interviews with 28 software engineers from the company helped to understand the circumstances under which builds are broken and the effects of build breakages on the collaboration and coordination of teams. We quantitatively investigated the main factors impacting build breakage and found that build failures correlate with the number of simultaneous contributors on branches, the type of work items performed on a branch, and the roles played by the stakeholders of the builds (for example developers vs. integrators).},
	Author = {Noureddine Kerzazi and Foutse Khomh and Bram Adams},
	Booktitle = {{Proc. of the 30th Int'l Conf. on Software Maintenance and Evolution (ICSME)}},
	Date-Added = {2014-08-11 00:38:15 +0000},
	Date-Modified = {2014-08-11 00:40:04 +0000},
	Pages = {To appear},
	Title = {{Why do Automated Builds Break? An Empirical Study}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NtZTIwMTRfa2VyemF6aS5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc21lMjAxNF9rZXJ6YXppLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ9ULjQASQSAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADQAVxSAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtZTIwMTRfa2VyemF6aS5wZGYADgAsABUAaQBjAHMAbQBlADIAMAAxADQAXwBrAGUAcgB6AGEAegBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbWUyMDE0X2tlcnphemkucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{alkofahi2014icse,
	Abstract = {Building is an important process in software development. In large software projects, build code has a high level of complexity, churn rate, and defect proneness. While several automated approaches exist to help developers in localizing faults in traditional source code and in detecting code smells in build code, fault localization techniques have not yet been developed for build code. In this work, we introduce MkFault, a tool to localize errors resulting in build crashes. MkFault monitors the execution traces from GNU Make statements that produce concrete build rules and the original code locations for each component of a rule (i.e., target, prerequisites, and recipe). It then uses a novel ranking algorithm to give suspiciousness scores to the original statements in the Makefile. In our empirical evaluation with real faults, we show that MkFault can help localize faults in Make code with high accuracy.},
	Author = {Jafar Al-Kofahi and Hung Viet Nguyen and Tien N. Nguyen},
	Booktitle = {{Proc. of the 36th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2014-08-10 22:32:59 +0000},
	Date-Modified = {2014-08-10 22:34:51 +0000},
	Pages = {600--601},
	Title = {{Fault Localization for Build Code Errors in Makefiles}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NlMjAxNF9hbGtvZmFoaS5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc2UyMDE0X2Fsa29mYWhpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKL3TbQDWupAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADQDaPpAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAxNF9hbGtvZmFoaS5wZGYADgAsABUAaQBjAHMAZQAyADAAMQA0AF8AYQBsAGsAbwBmAGEAaABpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMTRfYWxrb2ZhaGkucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{hardt2013releng,
	Abstract = {``Build maintenance'' refers to the changes made to the build system as a software project evolves over time and has been shown to impose a significant overhead on overall development costs, in part because changes to source code often require parallel changes in the build system. However, little tool support exists to assist developers with build maintenance, particularly for those changes that must accompany changes to the source code. Formiga is a build maintenance and dependency discovery tool for the Ant build system. Formiga's primary uses are to automate build changes as the source code is updated, to assist in build refactoring, to identify the build dependencies within a software project, and to clarify the dependency differences between different versions of build files. Formiga is implemented as an IDE plugin, which allows it to recognize when project resources are updated and automatically update the build system accordingly. This implementation also allows it to leverage existing metaphors used by developers to maintain source code, thus making it easier to use.},
	Author = {Ryan Hardt and Ethan V. Munson},
	Booktitle = {{Proc. of the 1st Int'l Workshop on RELease ENGineering (RELENG)}},
	Date-Added = {2014-08-10 22:23:15 +0000},
	Date-Modified = {2014-08-10 22:25:12 +0000},
	Pages = {13--16},
	Title = {{Ant Build Maintence with Formiga}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9yZWxlbmcyMDEzX2hhcmR0LnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UcmVsZW5nMjAxM19oYXJkdC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAovYJ9ANaTQAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANANoXQAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHJlbGVuZzIwMTNfaGFyZHQucGRmAAAOACoAFAByAGUAbABlAG4AZwAyADAAMQAzAF8AaABhAHIAZAB0AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvcmVsZW5nMjAxM19oYXJkdC5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{tamrawi2012ase,
	Abstract = {Software building is an important task during software development. However, program analysis support for build code is still limited, especially for build code written in a dynamic language such as Make. We introduce SYMake, a novel program analysis and refactoring tool for build code in Makefiles. SYMake is capable of detecting several types of code smells and errors such as cyclic dependencies, rule inclusion, duplicate prerequisites, recursive variable loops, etc. It also supports automatic build code refactoring, e.g. rule extraction/removal, target creation, target/variable renaming, prerequisite extraction, etc. In addition, SYMake provides the analysis on defined rules, targets, prerequisites, and associated information to help developers better understand build code in a Makefile and its included files.},
	Author = {Ahmed Tamrawi and Hoan Anh Nguyen and Hung Viet Nguyen and Tien N. Nguyen},
	Booktitle = {{Proc. of the 27th Int'l Conf. on Automated Software Engineering (ASE)}},
	Date-Added = {2014-08-10 22:15:46 +0000},
	Date-Modified = {2014-08-10 22:21:34 +0000},
	Pages = {366--369},
	Title = {{SYMake: A Build Code Analysis and Refactoring Tool for Makefiles}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9hc2UyMDEyX3RhbXJhd2kucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNhc2UyMDEyX3RhbXJhd2kucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACi9QP0A1n7wAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAA0A2gLwAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAYXNlMjAxMl90YW1yYXdpLnBkZgAOACgAEwBhAHMAZQAyADAAMQAyAF8AdABhAG0AcgBhAHcAaQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2FzZTIwMTJfdGFtcmF3aS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{budget2,
	Abstract = {Multiple regression models have wide applicability in predicting the outcome of patients with a variety of diseases. However, many researchers are using such models without validating the necessary assumptions. All too frequently, researchers also "overfit" the data by developing models using too many predictor variables and insufficient sample sizes. Models developed in this way are unlikely to stand the test of validation on a separate patient sample. Without attempting such a validation, the researcher remains unaware that overfitting has occurred. When the ratio of the number of patients suffering endpoints to the number of potential predictors is small (say less than 10), data reduction methods are available that can greatly improve the performance of regression models. Regression models can make more accurate predictions than other methods such as stratification and recursive partitioning, when model assumptions are thoroughly examined; steps are taken (ie, choosing another model or transforming the data) when assumptions are violated; and the method of model formulation does not result in overfitting the data.},
	Author = {Frank E. {Harrell Jr.} and Kerry L. Lee and David B. Matchar and T. A. Reichert},
	Date-Added = {2014-08-08 11:54:12 +0000},
	Date-Modified = {2014-08-08 12:03:45 +0000},
	Journal = {Cancer Treatment Reports},
	Number = {10},
	Pages = {1071--1077},
	Title = {{Regression models for prognostic prediction: advantages, problems, and suggested solutions}},
	Volume = {69},
	Year = {1985}}

@article{budget1,
	Abstract = {Regression models such as the Cox proportional hazards model have had increasing use in modelling and estimating the prognosis of patients with a variety of diseases. Many applications involve a large number of variables to be modelled using a relatively small patient sample. Problems of overfitting and of identifying important covariates are exacerbated in analysing prognosis because the accuracy of a model is more a function of the number of events than of the sample size.

We used a general index of predictive discrimination to measure the ability of a model developed on training samples of varying sizes to predict survival in an independent test sample of patients suspected of having coronary artery disease. We compared three methods of model fitting: (1) standard `step-up' variable selection, (2) incomplete principal components regression, and (3) Cox model regression after developing clinical indices from variable clusters. We found regression using principal components to offer superior predictions in the test sample, whereas regression using indices offers easily interpretable models nearly as good as the principal components models. Standard variable selection has a number of deficiencies.},
	Author = {Frank E. {Harrell Jr.} and Kerry L. Lee and Robert M. Califf and David B. Pryor and Robert A. Rosati},
	Date-Added = {2014-08-08 11:50:35 +0000},
	Date-Modified = {2014-08-08 11:53:32 +0000},
	Journal = {Statistics in Medicine},
	Number = {2},
	Pages = {143--152},
	Title = {{Regression modelling strategies for improved prognostic prediction}},
	Volume = {3},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QFS4uL1BhcGVycy9idWRnZXQxLnBkZtIXCxgZV05TLmRhdGFPEQF2AAAAAAF2AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4LYnVkZ2V0MS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoquhNAKMokAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAANAKaskAAAABAAwACg4OAAlnPwAJZzwAAgA2TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGJ1ZGdldDEucGRmAA4AGAALAGIAdQBkAGcAZQB0ADEALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACZVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9idWRnZXQxLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKYAqwCzAi0CLwI0Aj8CSAJWAloCYQJqAm8CfAJ/ApEClAKZAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAps=}}

@inproceedings{hassan2008sac,
	Abstract = {Source control systems permit developers to attach a free form message to every committed change. The content of these change messages can support software maintenance activities. We present an automated approach to classify a change message as either a bug fix, a feature introduction, or a general maintenance change. Researchers can study the evolution of project using our classification. For example, researchers can monitor the rate of bug fixes in a project without having access to bug reporting databases like Bugzilla.

A case study using change messages from several open source projects, shows that our approach produces results similar to a manual classifications performed by professional developers. These findings are similar to ones reported by Mockus and Votta for commercial projects.
},
	Author = {Ahmed E. Hassan},
	Booktitle = {{Proc. of the 23rd Int'l Symposium on Applied Computing (SAC)}},
	Date-Added = {2014-08-08 03:22:03 +0000},
	Date-Modified = {2014-08-08 03:24:24 +0000},
	Pages = {837--841},
	Title = {{Automated Classification of Change Messages in Open Source Projects}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9zYWMyMDA4X2hhc3Nhbi5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEnNhYzIwMDhfaGFzc2FuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKKnvXQCbs0AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADQCfN0AAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBzYWMyMDA4X2hhc3Nhbi5wZGYAAA4AJgASAHMAYQBjADIAMAAwADgAXwBoAGEAcwBzAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3NhYzIwMDhfaGFzc2FuLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{mockus2000icsm,
	Abstract = {Large scale software products must constantly change in order to adapt to a changing environment. Studies of historic data from legacy software systems have identified three specific causes of this change: adding new features; correcting faults; and restructuring code to accommodate future changes. Our hypothesis is that a textual description field of a change is essential to understanding why that change was performed. Also, we expect that difficulty, size, and interval would vary strongly across different types of changes. To test these hypotheses we have designed a program which automatically classifies maintenance activity based on a textual description of changes. Developer surveys showed that the automatic classification was in agreement with developer opinions. Tests of the classifier on a different product found that size and interval for different types of changes did not vary across two products. We have found strong relationships between the type and size of a change and the time required to carry it out. We also discovered a relatively large amount of perfective changes in the system we examined. From this study we have arrived at several suggestions on how to make version control data useful in diagnosing the state of a software project, without significantly increasing the overhead for the developer using the change management system},
	Author = {Audris Mockus and Lawrence G. Votta},
	Booktitle = {{Proc. of the 16th Int'l Conf. on Software Maintenance (ICSM)}},
	Date-Added = {2014-08-08 03:16:45 +0000},
	Date-Modified = {2014-08-08 03:19:04 +0000},
	Pages = {120--130},
	Title = {{Identifying Reasons for Software Changes Using Historic Databases}},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pY3NtMjAwMF9tb2NrdXMucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpY3NtMjAwMF9tb2NrdXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACipzm0Am6ZgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAA0AnypgAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzbTIwMDBfbW9ja3VzLnBkZgAOACgAEwBpAGMAcwBtADIAMAAwADAAXwBtAG8AYwBrAHUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc20yMDAwX21vY2t1cy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{phillips2014icse,
	Abstract = {Build, creating software from source code, is a fundamental activity in software development. Build teams manage this process and ensure builds are produced reliably and efficiently. This paper presents an exploration into the nature of build teams--how they form, work, and relate to other teams--through three multi-method studies conducted at Microsoft. We also consider build team effectiveness and find that many challenges are social, not technical: role ambiguity, knowledge sharing, communication, trust, and conflict. Our findings validate theories from group dynamics and organization science, and using a cross-discipline approach, we apply learnings from these fields to inform the design of engineering tools and practices to improve build team effectiveness},
	Author = {Shaun Phillips and Thomas Zimmermann and Christian Bird},
	Booktitle = {{Proc. of the 36th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2014-08-03 14:16:21 +0000},
	Date-Modified = {2014-08-03 14:18:52 +0000},
	Pages = {735--744},
	Title = {{Understanding and Improving Software Build Teams}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NlMjAxNF9waGlsbGlwcy5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc2UyMDE0X3BoaWxsaXBzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH8dSfPfVPkAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADPfYwkAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAxNF9waGlsbGlwcy5wZGYADgAsABUAaQBjAHMAZQAyADAAMQA0AF8AcABoAGkAbABsAGkAcABzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMTRfcGhpbGxpcHMucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@article{mantyla2009tse,
	Abstract = {Research on code reviews has often focused on defect counts instead of defect types, which offers an imperfect view of code review benefits. In this paper, we classified the defects of nine industrial (C/C++) and 23 student (Java) code reviews, detecting 388 and 371 defects, respectively. First, we discovered that 75 percent of defects found during the review do not affect the visible functionality of the software. Instead, these defects improved software evolvability by making it easier to understand and modify. Second, we created a defect classification consisting of functional and evolvability defects. The evolvability defect classification is based on the defect types found in this study, but, for the functional defects, we studied and compared existing functional defect classifications. The classification can be useful for assigning code review roles, creating checklists, assessing software evolvability, and building software engineering tools. We conclude that, in addition to functional defects, code reviews find many evolvability defects and, thus, offer additional benefits over execution-based quality assurance methods that cannot detect evolvability defects. We suggest that code reviews may be most valuable for software products with long life cycles as the value of discovering evolvability defects in them is greater than for short life cycle systems.},
	Author = {Mika V. M\"{a}ntyl\"{a} and Casper Lassenius},
	Date-Added = {2014-08-02 14:44:50 +0000},
	Date-Modified = {2014-08-02 14:46:58 +0000},
	Journal = {{Transactions on Software Engineering (TSE)}},
	Number = {3},
	Pages = {430--448},
	Title = {{What Types of Defects Are Really Discovered in Code Reviews?}},
	Volume = {35},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy90c2UyMDA5X21hbnR5bGEucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN0c2UyMDA5X21hbnR5bGEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChlSH0AJxYAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAA0AKpoAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdHNlMjAwOV9tYW50eWxhLnBkZgAOACgAEwB0AHMAZQAyADAAMAA5AF8AbQBhAG4AdAB5AGwAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3RzZTIwMDlfbWFudHlsYS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{beller2014msr,
	Abstract = {Code review is the manual assessment of source code by humans, mainly intended to identify defects and quality problems. Modern Code Review (MCR), a lightweight variant of the code inspections investigated since the 1970s, prevails today both in industry and open-source software (OSS) systems. The objective of this paper is to increase our understanding of the practical benefits that the MCR process produces on reviewed source code. To that end, we empirically explore the problems fixed through MCR in OSS systems. We manually classified over 1,400 changes taking place in reviewed code from two OSS projects into a validated categorization scheme. Surprisingly, results show that the types of changes due to the MCR process in OSS are strikingly similar to those in the industry and academic systems from literature, featuring the similar 75:25 ratio of maintainability-related to functional problems. We also reveal that 7--35% of review comments are discarded and that 10--22% of the changes are not triggered by an explicit review comment. Patterns emerged in the review data; we investigated them revealing the technical factors that influence the number of changes due to the MCR process. We found that bug-fixing tasks lead to fewer changes and tasks with more altered files and a higher code churn have more changes. Contrary to intuition, the person of the reviewer had no impact on the number of changes.},
	Author = {Moritz Beller and Alberto Bacchelli and Andy Zaidman and Elmar Juergens},
	Booktitle = {{Proc. of the 11th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2014-07-30 22:16:59 +0000},
	Date-Modified = {2014-07-30 22:18:26 +0000},
	Pages = {202--211},
	Title = {{Modern Code Reviews in Open-Source Projects: Which Problems Do They Fix?}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9tc3IyMDE0X2JlbGxlci5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEm1zcjIwMTRfYmVsbGVyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ8Wd7P/ueLAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADP/x/LAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBtc3IyMDE0X2JlbGxlci5wZGYAAA4AJgASAG0AcwByADIAMAAxADQAXwBiAGUAbABsAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL21zcjIwMTRfYmVsbGVyLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{optimism,
	Abstract = {A regression model is fitted to an observed set of data. How accurate is the model for predicting future observations? The apparent error rate tends to underestimate the true error rate because the data have been used twice, both to fit the model and to check its accuracy. We provide simple estimates for the downward bias of the apparent error rate. The theory applies to general exponential family linear models and general measures of prediction error. Special attention is given to the case of logistic regression on binary data, with error rates measured by the proportion of misclassified cases. Several connected ideas are compared: Mallows's Cp, cross-validation, generalized cross-validation, the bootstrap, and Akaike's information criterion.},
	Author = {Bradley Efron},
	Date-Added = {2014-07-28 14:13:45 +0000},
	Date-Modified = {2014-07-28 14:16:29 +0000},
	Journal = {Journal of the American Statistical Association},
	Number = {394},
	Pages = {461--470},
	Title = {{How Biased is the Apparent Error Rate of a Prediction Rule?}},
	Volume = {81},
	Year = {1986},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9ib290c3RyYXBfbW9yZS5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmJvb3RzdHJhcF9tb3JlLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ7KuDP+9F2AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADP/Am2AAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBib290c3RyYXBfbW9yZS5wZGYAAA4AJgASAGIAbwBvAHQAcwB0AHIAYQBwAF8AbQBvAHIAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2Jvb3RzdHJhcF9tb3JlLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@book{frank,
	Abstract = {Many texts are excellent sources of knowledge about individual statistical tools, but the art of data analysis is about choosing and using multiple tools. Instead of presenting isolated techniques, this text emphasizes problem solving strategies that address the many issues arising when developing multivariable models using real data and not standard textbook examples. It includes imputation methods for dealing with missing data effectively, methods for dealing with nonlinear relationships and for making the estimation of transformations a formal part of the modeling process, methods for dealing with "too many variables to analyze and not enough observations," and powerful model validation techniques based on the bootstrap. This text realistically deals with model uncertainty and its effects on inference to achieve "safe data mining".},
	Author = {Frank E. {Harrell Jr.}},
	Date-Added = {2014-07-25 19:28:25 +0000},
	Date-Modified = {2014-07-25 19:30:29 +0000},
	Edition = {2nd},
	Keywords = {rms},
	Publisher = {Springer},
	Title = {{Regression Modeling Strategies}},
	Year = {2015}}

@manual{rms_package,
	Author = {Frank E. {Harrell Jr.}},
	Note = {R package version 4.2-1},
	Title = {rms: Regression Modeling Strategies},
	Url = {http://biostat.mc.vanderbilt.edu/rms},
	Year = {2014},
	Bdsk-Url-1 = {http://biostat.mc.vanderbilt.edu/rms}}

@incollection{varclus,
	Author = {W. S. Sarle},
	Booktitle = {{SAS/STAT User's Guide}},
	Edition = {4th},
	Location = {Cary, NC, USA},
	Publisher = {SAS Institute, Inc.},
	Title = {{The VARCLUS Procedure}},
	Year = {1990}}

@article{pawlik2011vldb,
	Abstract = {We consider the classical tree edit distance between ordered labeled trees, which is defined as the minimum-cost sequence of node edit operations that transform one tree into another. The state-of-the-art solutions for the tree edit distance are not satisfactory. The main competitors in the field either have optimal worst-case complexity, but the worst case happens frequently, or they are very efficient for some tree shapes, but degenerate for others. This leads to unpredictable and often infeasible runtimes. There is no obvious way to choose between the algorithms.

In this paper we present RTED, a robust tree edit distance algorithm. The asymptotic complexity of RTED is smaller or equal to the complexity of the best competitors for any input instance, i.e., RTED is both efficient and worst-case optimal. We introduce the class of LRH (Left-Right-Heavy) algorithms, which includes RTED and the fastest tree edit distance algorithms presented in literature. We prove that RTED outperforms all previously proposed LRH algorithms in terms of runtime complexity. In our experiments on synthetic and real world data we empirically evaluate our solution and compare it to the state-of-the-art.},
	Author = {Mateusz Pawlik and Nikolaus Augsten},
	Date-Added = {2014-07-13 15:36:37 +0000},
	Date-Modified = {2014-07-13 15:39:35 +0000},
	Journal = {Proc. of the VLDB Endowment},
	Number = {4},
	Pages = {334--345},
	Title = {{RTED: A Robust Algorithm for the Tree Edit Distance}},
	Volume = {5},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy92bGRiMjAxMV9wYXdsaWsucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN2bGRiMjAxMV9wYXdsaWsucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZSGfz+gfrAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAz+hX7AAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdmxkYjIwMTFfcGF3bGlrLnBkZgAOACgAEwB2AGwAZABiADIAMAAxADEAXwBwAGEAdwBsAGkAawAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3ZsZGIyMDExX3Bhd2xpay5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{mcintosh2014emse,
	Author = {Shane McIntosh and Meiyappan Nagappan and Bram Adams and Audris Mockus and Ahmed E. Hassan},
	Date-Added = {2014-07-08 15:16:30 +0000},
	Date-Modified = {2014-07-08 15:18:23 +0000},
	Journal = {Empirical Software Engineering (EMSE)},
	Title = {{A Large-Scale Empirical Study of the Relationship between Build Technology and Build Maintenance}},
	Volume = {To appear},
	Year = {2014}}

@inproceedings{vanderburg2014ase,
	Abstract = {Open Source Software (OSS) components form the basis for many software systems. While the use of OSS components accelerates development, client systems must comply with the license terms of the OSS components that they use. Failure to do so exposes client system distributors to possible litigation from copyright holders. Yet despite the importance of license compliance, tool support for license compliance assessment is lacking. In this paper, we propose an approach to extract and analyze the Concrete Build Dependency Graph (CBDG) of a software system by tracing system calls that occur at build-time. Through a case study of seven open source systems, we show that the extracted CBDGs: (1) accurately classify sources as included in or excluded from deliverables with 88%-100% precision and 98%-100% recall, and (2) can uncover license compliance inconsistencies in real software systems - two of which prompted code fixes in the CUPS and FFmpeg systems.},
	Author = {Sander van der Burg and Julius Davies and Eelco Dolstra and Shane McIntosh and Daniel M. German and Armijn Hemel},
	Booktitle = {{Proc. of the 29th Int'l Conf. on Automated Software Engineering (ASE)}},
	Date-Added = {2014-07-02 13:06:33 +0000},
	Date-Modified = {2014-07-02 13:08:34 +0000},
	Pages = {To appear},
	Title = {{Tracing Software Build Processes to Uncover License Compliance Inconsistencies}},
	Year = {2014}}

@article{rigby2014tosem,
	Abstract = {Peer review is seen as an important quality assurance mechanism in both industrial development and the open source software (OSS) community. The techniques for performing inspections have been well studied in industry; in OSS development, software peer reviews are not as well understood.

To develop an empirical understanding of OSS peer review, we examine the review policies of 25 OSS projects and study the archival records of six large, mature, successful OSS projects. We extract a series of measures based on those used in traditional inspection experiments. We measure the frequency of review, the size of the contribution under review, the level of participation during review, the experience and expertise of the individuals involved in the review, the review interval, and the number of issues discussed during review. We create statistical models of the review efficiency, review interval, and effectiveness, the issues discussed during review, to determine which measures have the largest impact on review efficacy.

We find that OSS peer reviews are conducted asynchronously by empowered experts who focus on changes that are in their area of expertise. Reviewers provide timely, regular feedback on small changes. The descriptive statistics clearly show that OSS review is drastically different from traditional inspection.},
	Author = {Peter C. Rigby and Daniel M. German and Laura Cohen and Margaret-Anne Storey},
	Date-Added = {2014-06-21 16:02:37 +0000},
	Date-Modified = {2014-06-21 16:05:54 +0000},
	Journal = {Transactions On Software Engineering and Methodology (TOSEM)},
	Title = {{Peer Review on Open Source Software Projects: Parameters, Statistical Models, and Theory}},
	Volume = {To appear},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy90b3NlbTIwMTRfcmlnYnkucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN0b3NlbTIwMTRfcmlnYnkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACN7NFz8m0DwAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAz8nsTwAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdG9zZW0yMDE0X3JpZ2J5LnBkZgAOACgAEwB0AG8AcwBlAG0AMgAwADEANABfAHIAaQBnAGIAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3Rvc2VtMjAxNF9yaWdieS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{mcintosh2014msr,
	Abstract = {Software code review, i.e., the practice of having third-party team members critique changes to a software system, is a well-established best practice in both open source and proprietary software domains. Prior work has shown that the formal code inspections of the past tend to improve the quality of software delivered by students and small teams. However, the formal code inspection process mandates strict review criteria (e.g., in-person meetings and reviewer checklists) to ensure a base level of review quality, while the modern, lightweight code reviewing process does not. Although recent work explores the modern code review process qualitatively, little research quantitatively explores the relationship between properties of the modern code review process and software quality. Hence, in this paper, we study the relationship between software quality and: (1) code review coverage, i.e., the proportion of changes that have been code reviewed, and (2) code review participation, i.e., the degree of reviewer involvement in the code review process. Through a case study of the Qt, VTK, and ITK projects, we find that both code review coverage and participation share a significant link with software quality. Low code review coverage and participation are estimated to produce components with up to two and five additional post-release defects respectively. Our results empirically confirm the intuition that poorly reviewed code has a negative impact on software quality in large systems using modern reviewing tools.},
	Author = {Shane McIntosh and Yasutaka Kamei and Bram Adams and Ahmed E. Hassan},
	Booktitle = {{Proc. of the 11th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2014-06-20 13:39:16 +0000},
	Date-Modified = {2014-06-20 13:44:33 +0000},
	Pages = {192--201},
	Title = {{The Impact of Code Review Coverage and Code Review Participation on Software Quality: A Case Study of the QT, VTK, and ITK Projects}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9tc3IyMDE0X21jaW50b3NoLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UbXNyMjAxNF9tY2ludG9zaC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjeqp8/JslkAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM/J6pkAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AG1zcjIwMTRfbWNpbnRvc2gucGRmAAAOACoAFABtAHMAcgAyADAAMQA0AF8AbQBjAGkAbgB0AG8AcwBoAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvbXNyMjAxNF9tY2ludG9zaC5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{seo2014icse,
	Abstract = {Building is an integral part of the software development process. However, little is known about the compiler errors that occur in this process. In this paper, we present an empirical study of 26.6 million builds produced during a period of nine months by thousands of developers. We describe the workflow through which those builds are generated, and we analyze failure frequency, compiler error types, and resolution efforts to fix those compiler errors. The results provide insights on how a large organization build process works, and pinpoints errors for which further developer support would be most effective.},
	Author = {Hyunmin Seo and Caitlin Sadowski and Sebastian Elbaum and Edward Aftandilian and Robert Bowdidge},
	Booktitle = {{Proc. of the 36th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2014-05-03 20:48:34 +0000},
	Date-Modified = {2014-08-03 21:59:14 +0000},
	Pages = {724--734},
	Title = {{Programmers' Build Errors: A Case Study (at Google)}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy9pY3NlMjAxNF9zZW8ucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhBpY3NlMjAxNF9zZW8ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAb+0z4UfiAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAz4VXyAAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTIwMTRfc2VvLnBkZgAADgAiABAAaQBjAHMAZQAyADAAMQA0AF8AcwBlAG8ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pY3NlMjAxNF9zZW8ucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@article{randomforest,
	Abstract = {Random forests are a combination of tree predictors such that each tree depends on the values of a random vector sampled independently and with the same distribution for all trees in the forest. The generalization error for forests converges a.s. to a limit as the number of trees in the forest becomes large. The generalization error of a forest of tree classifiers depends on the strength of the individual trees in the forest and the correlation between them. Using a random selection of features to split each node yields error rates that compare favorably to Adaboost, but are more robust with respect to noise. Internal estimates monitor error, strength, and correlation and these are used to show the response to increasing the number of features used in the splitting. Internal estimates are also used to measure variable importance. These ideas are also applicable to regression.},
	Author = {Leo Breiman},
	Date-Added = {2014-04-30 19:53:50 +0000},
	Date-Modified = {2014-04-30 19:55:47 +0000},
	Journal = {Machine Learning},
	Number = {1},
	Pages = {5--32},
	Title = {{Random Forests}},
	Volume = {45},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9tbDIwMDFfYnJlaW1hbi5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEm1sMjAwMV9icmVpbWFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIDz2zPhs3IAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADPhwYIAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBtbDIwMDFfYnJlaW1hbi5wZGYAAA4AJgASAG0AbAAyADAAMAAxAF8AYgByAGUAaQBtAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL21sMjAwMV9icmVpbWFuLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@book{stepwise,
	Author = {Draper, N. and Smith, H.},
	Date-Added = {2014-04-16 13:17:59 +0000},
	Date-Modified = {2014-04-16 13:20:48 +0000},
	Edition = {2$^{\textit{nd}}$},
	Publisher = {John Wiley \& Sons},
	Title = {{Applied Regression Analysis}},
	Year = {1981}}

@inproceedings{mcintosh2014icse,
	Abstract = {Build systems specify how sources are transformed into deliverables, and hence must be carefully maintained to ensure that deliverables are assembled correctly. Similar to source code, build systems tend to grow in complexity unless specifications are refactored. This paper describes how clone detection can aid in quality assessments that determine if and where build refactoring effort should be applied. We gauge cloning rates in build systems by collecting and analyzing a benchmark comprising 3,872 build systems. Analysis of the benchmark reveals that: (1) build systems tend to have higher cloning rates than other software artifacts, (2) recent build technologies tend to be more prone to cloning, especially of configuration details like API dependencies, than older technologies, and (3) build systems that have fewer clones achieve higher levels of reuse via mechanisms not offered by build technologies. Our findings aided in refactoring a large industrial build system containing 1.1 million lines.},
	Author = {Shane McIntosh and Martin Poehlmann and Elmar Juergens and Audris Mockus and Bram Adams and Ahmed E. Hassan and Brigitte Haupt and Christian Wagner},
	Booktitle = {{Proc. of the 36th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2014-03-03 00:18:13 +0000},
	Date-Modified = {2014-03-16 00:03:33 +0000},
	Pages = {115--124},
	Title = {{Collecting and Leveraging a Benchmark of Build System Clones to Aid in Quality Assessments}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIy4uL1BhcGVycy9pY3Nlc2VpcDIwMTRfbWNpbnRvc2gucGRm0hcLGBlXTlMuZGF0YU8RAa4AAAAAAa4AAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhlpY3Nlc2VpcDIwMTRfbWNpbnRvc2gucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABy+0gz0piZgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAz0qapgAAAAEADAAKDg4ACWc/AAlnPAACAERNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZXNlaXAyMDE0X21jaW50b3NoLnBkZgAOADQAGQBpAGMAcwBlAHMAZQBpAHAAMgAwADEANABfAG0AYwBpAG4AdABvAHMAaAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIANFVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2VzZWlwMjAxNF9tY2ludG9zaC5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC0ALkAwQJzAnUCegKFAo4CnAKgAqcCsAK1AsICxQLXAtoC3wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALh}}

@book{lakosbook,
	Author = {John Lakos},
	Date-Added = {2014-02-22 16:04:20 +0000},
	Date-Modified = {2014-02-22 16:08:08 +0000},
	Publisher = {Addison-Wesley},
	Title = {{Large-Scale C++ Software Design}},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QLS4uL1BhcGVycy9MYXJnZS1TY2FsZV9DKytfU29mdHdhcmVfRGVzaWduLnBkZtIXCxgZV05TLmRhdGFPEQHSAAAAAAHSAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4fTGFyZ2UtU2NhbGVfQysrX1NvZiMxQjgyQzAzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbgsA88uNJ4AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM8ueu4AAAABAAwACg4OAAlnPwAJZzwAAgBKTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AExhcmdlLVNjYWxlX0MrK19Tb2YjMUI4MkMwMy5wZGYADgBIACMATABhAHIAZwBlAC0AUwBjAGEAbABlAF8AQwArACsAXwBTAG8AZgB0AHcAYQByAGUAXwBEAGUAcwBpAGcAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL0xhcmdlLVNjYWxlX0MrK19Tb2Z0d2FyZV9EZXNpZ24ucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AvgDDAMsCoQKjAqgCswK8AsoCzgLVAt4C4wLwAvMDBQMIAw0AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADDw==}}

@inproceedings{herraiz2008msr,
	Abstract = {We believe that the bug report form of Eclipse contains too many fields, and that for some fields, there are too many options. In this MSR challenge report, we focus in the case of the severity field. That field contains seven different levels of severity. Some of them seem very similar, and it is hard to distinguish among them. Users assign severity, and developers give priority to the reports depending on their severity. However, if users can not distinguish well among the various severity options, they will probably assign different priorities to bugs that require the same priority. We study the mean time to close bugs reported in Eclipse, and how the severity assigned by users affects this time. The results shows that classifying by time to close, there are less clusters of bugs than levels of severity. We therefore conclude that there is a need to make a simpler bug report form.},
	Author = {Israel Herraiz and Daniel M. German and Jesus M. Gonzalez-Barahona and Gregorio Robles},
	Booktitle = {{Proc. of the 5th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2014-01-30 04:49:14 +0000},
	Date-Modified = {2014-01-30 04:51:09 +0000},
	Pages = {145--148},
	Title = {{Towards a Simplification of the Bug Report form in Eclipse}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9tc3IyMDA4X2hlcnJhaXoucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNtc3IyMDA4X2hlcnJhaXoucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABqk5hzw9EhAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzw+K1AAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAbXNyMjAwOF9oZXJyYWl6LnBkZgAOACgAEwBtAHMAcgAyADAAMAA4AF8AaABlAHIAcgBhAGkAegAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL21zcjIwMDhfaGVycmFpei5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{sauer2000tse,
	Abstract = {Software engineers use a number of different types of software development technical review (SDTR) for the purpose of detecting defects in software products. This paper applies the behavioral theory of group performance to explain the outcomes of software reviews. A program of empirical research is developed, including propositions to both explain review performance and identify ways of improving review performance based on the specific strengths of individuals and groups. Its contributions are to clarify our understanding of what drives defect detection performance in SDTRs and to set an agenda for future research. In identifying individuals' task expertise as the primary driver of review performance, the research program suggests specific points of leverage for substantially improving review performance. It points to the importance of understanding software reading expertise and implies the need for a reconsideration of existing approaches to managing reviews.},
	Author = {Chris Sauer and D. Ross Jeffery and Lesley Land and Philip Yetton},
	Date-Added = {2014-01-29 17:22:43 +0000},
	Date-Modified = {2014-01-29 17:25:13 +0000},
	Journal = {{Transactions on Software Engineering (TSE)}},
	Number = {1},
	Pages = {1--14},
	Title = {{The Effectiveness of Software Development Technical Reviews: A Behaviorally Motivated Program of Research}},
	Volume = {26},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy90c2UyMDAwX3NhdWVyLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RdHNlMjAwMF9zYXVlci5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAan1g88Oo4gAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM8O6dgAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHRzZTIwMDBfc2F1ZXIucGRmAA4AJAARAHQAcwBlADIAMAAwADAAXwBzAGEAdQBlAHIALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy90c2UyMDAwX3NhdWVyLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@book{adjustedr2,
	Author = {Trevor Hastie and Robert Tibshirani and Jerome Friedman},
	Date-Added = {2014-01-28 12:26:40 +0000},
	Date-Modified = {2014-01-28 12:28:30 +0000},
	Edition = {2$^\textit{nd}$},
	Publisher = {Springer},
	Title = {{Elements of Statistical Learning}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9FU0xfMm5kX2VkaXRpb24ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNFU0xfMm5kX2VkaXRpb24ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABqLqIzw0MtgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzw1TBgAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoARVNMXzJuZF9lZGl0aW9uLnBkZgAOACgAEwBFAFMATABfADIAbgBkAF8AZQBkAGkAdABpAG8AbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL0VTTF8ybmRfZWRpdGlvbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{menzies2002nasa,
	Abstract = {Within NASA, there is an increasing awareness that software is of growing importance to the success of missions. Much data has been collected, and many theories have been advanced on how to reduce or eliminate errors in code. However, learning requires experience. We document a new NASA initiative to build a centralized repository of software defect data; in particular, we document one specific case study on software metrics. Software metrics are used as a basis for prediction of errors in code modules, but there are many different metrics available. McCabe is one of the more popular tools used to produce metrics, but, other metrics can be more significant.},
	Author = {Tim Menzies and Justin S. Di Stefano and Mike Chapman and Ken McGill},
	Booktitle = {{Proc of the 27th Annual NASA Goddard/IEEE Software Engineering Workshop}},
	Date-Added = {2014-01-24 19:54:35 +0000},
	Date-Modified = {2014-01-24 19:56:44 +0000},
	Pages = {51--57},
	Title = {{Metrics That Matter}},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9uYXNhMjAwMl9tZW56aWVzLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UbmFzYTIwMDJfbWVuemllcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaTMZM8IL7QAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM8IdgQAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AG5hc2EyMDAyX21lbnppZXMucGRmAAAOACoAFABuAGEAcwBhADIAMAAwADIAXwBtAGUAbgB6AGkAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvbmFzYTIwMDJfbWVuemllcy5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@article{biffl2000ieeesw,
	Abstract = {To control projects, managers need accurate and timely feedback on the quality of the software product being developed. I propose subjective team estimation models calculated from individual estimates and investigate the accuracy of defect estimation models based on inspection data.},
	Author = {Stefan Biffl},
	Date-Added = {2014-01-24 18:19:05 +0000},
	Date-Modified = {2014-01-24 18:20:41 +0000},
	Journal = {IEEE Software},
	Number = {6},
	Pages = {36--43},
	Title = {{Using Inspection Data for Defect Estimation}},
	Volume = {17},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pZWVlc3cyMDAwX2JpZmZpLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWVlZXN3MjAwMF9iaWZmaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaSsaM8IFu8AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM8IXT8AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGllZWVzdzIwMDBfYmlmZmkucGRmAAAOACoAFABpAGUAZQBlAHMAdwAyADAAMAAwAF8AYgBpAGYAZgBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWVlZXN3MjAwMF9iaWZmaS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{baysal2013wcre,
	Abstract = {When submitting a patch, the primary concerns of individual developers are ``How can I maximize the chances of my patch being approved, and minimize the time it takes for this to happen?'' In principle, code review is a transparent process that aims to assess qualities of the patch by their technical merits and in a timely manner; however, in practice the execution of this process can be affected by a variety of factors, some of which are external to the technical content of the patch itself. In this paper, we describe an empirical study of the code review process for WebKit, a large, open source project; we replicate the impact of previously studied factors - such as patch size, priority, and component and extend these studies by investigating organizational (the company) and personal dimensions (reviewer load and activity, patch writer experience) on code review response time and outcome. Our approach uses a reverse engineered model of the patch submission process and extracts key information from the issue tracking and code review systems. Our findings suggest that these nontechnical factors can significantly impact code review outcomes.},
	Author = {Olga Baysal and Oleksii Kononenko and Reid Holmes and Michael W. Godfrey},
	Booktitle = {{Proc. of the 20th Working Conf. on Reverse Engineering (WCRE)}},
	Date-Added = {2014-01-24 16:47:22 +0000},
	Date-Modified = {2014-01-24 16:50:04 +0000},
	Pages = {122--131},
	Title = {{The Influence of Non-technical Factors on Code Review}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy93Y3JlMjAxM19iYXlzYWwucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN3Y3JlMjAxM19iYXlzYWwucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABolidzwa3ZAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzwb9tAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAd2NyZTIwMTNfYmF5c2FsLnBkZgAOACgAEwB3AGMAcgBlADIAMAAxADMAXwBiAGEAeQBzAGEAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3djcmUyMDEzX2JheXNhbC5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{bettenburg2013emse,
	Abstract = {In recent years, many companies have realized that collaboration with a thriving user or developer community is a major factor in creating innovative technology driven by market demand. As a result, businesses have sought ways to stimulate contributions from developers outside their corporate walls, and integrate external developers into their development process. To support software companies in this process, this paper presents an empirical study on the contribution management processes of two major, successful, open source software ecosystems. We contrast a for-profit (ANDROID) system having a hybrid contribution style, with a not-for-profit (LINUX kernel) system having an open contribution style. To guide our comparisons, we base our analysis on a conceptual model of contribution management that we derived from a total of seven major open-source software systems. A quantitative comparison based on data mined from the ANDROID code review system and the LINUX kernel code review mailing lists shows that both projects have significantly different contribution management styles, suited to their respective market goals, but with individual advantages and disadvantages that are important for practitioners. Contribution management is a real-world problem that has received very little attention from the research community so far. Both studied systems (LINUX and ANDROID) employ different strategies and techniques for managing contributions, and both approaches are valuable examples for practitioners. Each approach has specific advantages and disadvantages that need to be carefully evaluated by practitioners when adopting a contribution management process in practice.},
	Author = {Nicolas Bettenburg and Ahmed E. Hassan and Bram Adams and Daniel M. German},
	Date-Added = {2014-01-23 18:16:50 +0000},
	Date-Modified = {2014-03-21 15:06:29 +0000},
	Journal = {Empirical Software Engineering (EMSE)},
	Title = {{Management of community contributions: A case study on the Android and Linux software ecosystems}},
	Volume = {To appear},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIS4uL1BhcGVycy9lbXNlMjAxM19iZXR0ZW5idXJnLnBkZtIXCxgZV05TLmRhdGFPEQGmAAAAAAGmAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4XZW1zZTIwMTNfYmV0dGVuYnVyZy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUt0s86lrzsAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM6l9YsAAAABAAwACg4OAAlnPwAJZzwAAgBCTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGVtc2UyMDEzX2JldHRlbmJ1cmcucGRmAA4AMAAXAGUAbQBzAGUAMgAwADEAMwBfAGIAZQB0AHQAZQBuAGIAdQByAGcALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADJVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9lbXNlMjAxM19iZXR0ZW5idXJnLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALIAtwC/AmkCawJwAnsChAKSApYCnQKmAqsCuAK7As0C0ALVAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtc=}}

@article{mockus2002tosem,
	Abstract = {According to its proponents, open source style software development has the capacity to compete successfully, and perhaps in many cases displace, traditional commercial development methods. In order to begin investigating such claims, we examine data from two major open source projects, the Apache web server and the Mozilla browser. By using email archives of source code change history and problem reports we quantify aspects of developer participation, core team size, code ownership, productivity, defect density, and problem resolution intervals for these OSS projects. We develop several hypotheses by comparing the Apache project with several commercial projects. We then test and refine several of these hypotheses, based on an analysis of Mozilla data. We conclude with thoughts about the prospects for high-performance commercial/open source process hybrids.},
	Author = {Audris Mockus and Roy T. Fielding and James D. Herbsleb},
	Date-Added = {2014-01-21 19:13:38 +0000},
	Date-Modified = {2014-01-21 19:15:04 +0000},
	Journal = {Transactions On Software Engineering and Methodology (TOSEM)},
	Number = {3},
	Pages = {309--346},
	Title = {{Two Case Studies of Open Source Software Development: Apache and Mozilla}},
	Volume = {11},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy90b3NlbTIwMDJfbW9ja3VzLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UdG9zZW0yMDAyX21vY2t1cy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaDDDM8EMX4AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM8Ed84AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHRvc2VtMjAwMl9tb2NrdXMucGRmAAAOACoAFAB0AG8AcwBlAG0AMgAwADAAMgBfAG0AbwBjAGsAdQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvdG9zZW0yMDAyX21vY2t1cy5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@article{fagan1976,
	Author = {Michael E. Fagan},
	Date-Added = {2014-01-21 17:49:57 +0000},
	Date-Modified = {2014-01-21 17:51:47 +0000},
	Journal = {IBM Systems Journal},
	Number = {3},
	Pages = {182--211},
	Title = {{Design and Code Inspections to Reduce Errors in Program Development}},
	Volume = {15},
	Year = {1976},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIi4uL1BhcGVycy9jb2RlcmV2aWV3czE5NzZmYWdhbi5wZGbSFwsYGVdOUy5kYXRhTxEBrAAAAAABrAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OGGNvZGVyZXZpZXdzMTk3NmZhZ2FuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGguorPBB3vAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADPBGQ/AAAAAQAMAAoODgAJZz8ACWc8AAIAQ01hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBjb2RlcmV2aWV3czE5NzZmYWdhbi5wZGYAAA4AMgAYAGMAbwBkAGUAcgBlAHYAaQBlAHcAcwAxADkANwA2AGYAYQBnAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAM1VzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2NvZGVyZXZpZXdzMTk3NmZhZ2FuLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCzALgAwAJwAnICdwKCAosCmQKdAqQCrQKyAr8CwgLUAtcC3AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALe}}

@inproceedings{kamei2010icsm,
	Abstract = {Bug prediction models are often used to help allocate software quality assurance efforts (e.g. testing and code reviews). Mende and Koschke have recently proposed bug prediction models that are effort-aware. These models factor in the effort needed to review or test code when evaluating the effectiveness of prediction models, leading to more realistic performance evaluations. In this paper, we revisit two common findings in the bug prediction literature: 1) Process metrics (e.g., change history) outperform product metrics (e.g., LOC), 2) Package-level predictions outperform file-level predictions. Through a case study on three projects from the Eclipse Foundation, we find that the first finding holds when effort is considered, while the second finding does not hold. These findings validate the practical significance of prior findings in the bug prediction literature and encourage their adoption in practice.},
	Author = {Yasutaka Kamei and Shinsuke Matsumoto and Akito Monden and Ken-ichi Matsumoto and Bram Adams and Ahmed E. Hassan},
	Booktitle = {{Proc. of the 26th Int'l Conf. on Software Maintenance (ICSM)}},
	Date-Added = {2014-01-21 02:53:07 +0000},
	Date-Modified = {2014-01-21 02:57:25 +0000},
	Pages = {1--10},
	Title = {{Revisiting Common Bug Prediction Findings Using Effort-Aware Models}},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9pY3NtMjAxMF9rYW1laS5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmljc20yMDEwX2thbWVpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgT/TPAxMjAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADPA1lzAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtMjAxMF9rYW1laS5wZGYAAA4AJgASAGkAYwBzAG0AMgAwADEAMABfAGsAYQBtAGUAaQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc20yMDEwX2thbWVpLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{aic,
	Abstract = {The history of the development of statistical hypothesis testing in time series analysis is reviewed briefly and it is pointed out that the hypothesis testing procedure is not adequately defined as the procedure for statistical model identification. The classical maximum likelihood estimation procedure is reviewed and a new estimate minimum information theoretical criterion (AIC) estimate (MAICE) which is designed for the purpose of statistical identification is introduced. When there are several competing models the MAICE is defined by the model and the maximum likelihood estimates of the parameters which give the minimum of AIC defined by AIC = (-2)log-(maximum likelihood) + 2(number of independently adjusted parameters within the model). MAICE provides a versatile procedure for statistical model identification which is free from the ambiguities inherent in the application of conventional hypothesis testing procedure. The practical utility of MAICE in time series analysis is demonstrated with some numerical examples.},
	Author = {Hirotugu Akaike},
	Date-Added = {2014-01-20 17:09:20 +0000},
	Date-Modified = {2014-01-20 17:12:28 +0000},
	Journal = {{Transactions on Automatic Control (TAC)}},
	Number = {6},
	Pages = {716--723},
	Title = {{A New Look at the Statistical Model Identification}},
	Volume = {19},
	Year = {1974},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QES4uL1BhcGVycy9haWMucGRm0hcLGBlXTlMuZGF0YU8RAWYAAAAAAWYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODgdhaWMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoCPizwLDMQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzwMJgQAAAAEADAAKDg4ACWc/AAlnPAACADJNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAYWljLnBkZgAOABAABwBhAGkAYwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAIlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2FpYy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCiAKcArwIZAhsCIAIrAjQCQgJGAk0CVgJbAmgCawJ9AoAChQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAKH}}

@inbook{dropone,
	Chapter = {4},
	Date-Added = {2014-01-20 16:42:50 +0000},
	Date-Modified = {2014-01-20 16:52:52 +0000},
	Editor = {John M. Chambers and Trevor J. Hastie},
	Publisher = {Wadsworth and Brooks/Cole},
	Title = {{Statistical Models in S}},
	Year = {1992}}

@article{entropy,
	Author = {Claude E. Shannon},
	Date-Added = {2014-01-18 21:11:43 +0000},
	Date-Modified = {2014-01-18 21:13:29 +0000},
	Journal = {The Bell System Technical Journal},
	Pages = {379--423, 623--656},
	Title = {{A Mathematical Theory of Communication}},
	Volume = {27},
	Year = {1948}}

@inproceedings{jiang2013msr,
	Abstract = {The Linux kernel follows an extremely distributed reviewing and integration process supported by 130 developer mailing lists and a hierarchy of dozens of Git repositories for version control. Since not every patch can make it and of those that do, some patches require a lot more reviewing and integra- tion effort than others, developers, reviewers and integrators need support for estimating which patches are worthwhile to spend effort on and which ones do not stand a chance. This paper cross- links and analyzes eight years of patch reviews from the kernel mailing lists and committed patches from the Git repository to understand which patches are accepted and how long it takes those patches to get to the end user. We found that 33% of the patches makes it into a Linux release, and that most of them need 3 to 6 months for this. Furthermore, that patches developed by more experienced developers are more easily accepted and faster reviewed and integrated. Additionally, reviewing time is impacted by submission time, the number of affected subsystems by the patch and the number of requested reviewers. },
	Author = {Yujuan Jiang and Bram Adams and Daniel M. German},
	Booktitle = {{Proc. of the 10th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2014-01-18 16:09:19 +0000},
	Date-Modified = {2014-01-18 16:12:00 +0000},
	Pages = {101--110},
	Title = {{Will My Patch Make It? And How Fast?: Case Study on the Linux Kernel}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9tc3IyMDEzX2ppYW5nLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RbXNyMjAxM19qaWFuZy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ9p8M8AEggAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM8AWFgAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AG1zcjIwMTNfamlhbmcucGRmAA4AJAARAG0AcwByADIAMAAxADMAXwBqAGkAYQBuAGcALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9tc3IyMDEzX2ppYW5nLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@article{lawrence2004ist,
	Abstract = {XML is the future language for data exchange, and support for XML has been extensive. Although XML has numerous benefits including self-describing data, improved readability, and standardization, there are always tradeoffs in the introduction of new technologies that replace existing systems. The tradeoff of XML versus other data exchange languages is improved readability and descriptiveness versus space efficiency. There has been limited work on examining the space efficiency of XML. This paper compares XML to other data exchange formats. Experiments are performed to measure the overhead in XML files and determine the amount of space used for data, schema, and overhead in a typical XML document.},
	Author = {Ramon Lawrence},
	Date-Added = {2014-01-08 21:59:02 +0000},
	Date-Modified = {2014-01-08 22:00:53 +0000},
	Journal = {Information and Software Technology (IST)},
	Number = {11},
	Pages = {753--759},
	Title = {{The space efficience of XML}},
	Volume = {46},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pc3QyMDA0X2xhd3JlbmNlLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaXN0MjAwNF9sYXdyZW5jZS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZZnjM7zNCcAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM7zencAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGlzdDIwMDRfbGF3cmVuY2UucGRmAAAOACoAFABpAHMAdAAyADAAMAA0AF8AbABhAHcAcgBlAG4AYwBlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaXN0MjAwNF9sYXdyZW5jZS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@article{mann-whitney,
	Author = {David F. Bauer},
	Date-Added = {2013-12-19 22:17:08 +0000},
	Date-Modified = {2013-12-19 22:19:41 +0000},
	Journal = {Journal of the American Statistical Association},
	Number = {339},
	Pages = {687--690},
	Title = {{Constructing Confidence Sets Using Rank Statistics}},
	Volume = {67},
	Year = {1972}}

@book{tukey,
	Author = {Rupert G. Miller},
	Date-Added = {2013-12-19 22:09:43 +0000},
	Date-Modified = {2013-12-19 22:11:23 +0000},
	Publisher = {Springer},
	Title = {{Simultaneous Statistical Inference}},
	Year = {1981}}

@article{kamei2013tse,
	Abstract = {Defect prediction models are a well-known technique for identifying defect-prone files or packages such that practitioners can allocate their quality assurance efforts (e.g., testing and code reviews). However, once the critical files or packages have been identified, developers still need to spend considerable time drilling down to the functions or even code snippets that should be reviewed or tested. This makes the approach too time consuming and impractical for large software systems. Instead, we consider defect prediction models that focus on identifying defect-prone (``risky'') software changes instead of files or packages. We refer to this type of quality assurance activity as ``Just-In-Time Quality Assurance,'' because developers can review and test these risky changes while they are still fresh in their minds (i.e., at check-in time). To build a change risk model, we use a wide range of factors based on the characteristics of a software change, such as the number of added lines, and developer experience. A large-scale study of six open source and five commercial projects from multiple domains shows that our models can predict whether or not a change will lead to a defect with an average accuracy of 68 percent and an average recall of 64 percent. Furthermore, when considering the effort needed to review changes, we find that using only 20 percent of the effort it would take to inspect all changes, we can identify 35 percent of all defect-inducing changes. Our findings indicate that ``Just-In-Time Quality Assurance'' may provide an effort-reducing way to focus on the most risky changes and thus reduce the costs of developing high-quality software.},
	Author = {Yasutaka Kamei and Emad Shihab and Bram Adams and Ahmed E. Hassan and Audris Mockus and Anand Sinha and Naoyasu Ubayashi},
	Date-Added = {2013-12-01 15:56:35 +0000},
	Date-Modified = {2013-12-01 15:59:14 +0000},
	Journal = {Transactions on Software Engineering (TSE)},
	Number = {6},
	Pages = {757--773},
	Title = {{A Large-Scale Empirical Study of Just-in-Time Quality Assurance}},
	Volume = {39},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy90c2UyMDEzX2thbWVpLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RdHNlMjAxM19rYW1laS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXaMkc7AxisAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM7BDHsAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHRzZTIwMTNfa2FtZWkucGRmAA4AJAARAHQAcwBlADIAMAAxADMAXwBrAGEAbQBlAGkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy90c2UyMDEzX2thbWVpLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@inproceedings{wettel2011icse,
	Abstract = {Software visualization is a popular program comprehension technique used in the context of software maintenance, reverse engineering, and software evolution analysis. While there is a broad range of software visualization approaches, only few have been empirically evaluated. This is detrimental to the acceptance of software visualization in both the academic and the industrial world.

We present a controlled experiment for the empirical evaluation of a 3D software visualization approach based on a city metaphor and implemented in a tool called CodeCity. The goal is to provide experimental evidence of the viability of our approach in the context of program comprehension by having subjects perform tasks related to program comprehension. We designed our experiment based on lessons extracted from the current body of research. We conducted the experiment in four locations across three countries, involving 41 participants from both academia and industry. The experiment shows that CodeCity leads to a statistically significant increase in terms of task correctness and decrease in task completion time. We detail the experiment we performed, discuss its results and reflect on the many lessons learned.},
	Author = {Richard Wettel and Michele Lanza and Romain Robbes},
	Booktitle = {{Proc. of the 33rd Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-11-25 17:27:34 +0000},
	Date-Modified = {2013-11-25 17:29:41 +0000},
	Pages = {551--560},
	Title = {{Software Systems as Cities: A Controlled Experiment}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pY3NlMjAxMV93ZXR0ZWwucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpY3NlMjAxMV93ZXR0ZWwucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABb0kLzrjzDAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzrk5XAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTIwMTFfd2V0dGVsLnBkZgAOACgAEwBpAGMAcwBlADIAMAAxADEAXwB3AGUAdAB0AGUAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2UyMDExX3dldHRlbC5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{wu2004wcre,
	Abstract = {Software systems become progressively more complex and difficult to maintain. To facilitate maintenance tasks, project managers and developers often turn to the evolution history of the system to recover various kinds of useful information, such as anomalous phenomena and lost design decisions. An informative visualization of the evolution history can help cope with this complexity by highlighting conspicuous evolution events using strong visual cues. We present a scalable visualization technique called evolution spectrographs (ESG). An evolution spectrograph portrays the evolution of a spectrum of components based on a particular property measurement. We describe several special-purpose spectrographs and discuss their use in understanding and supporting software evolution through the case studies of three large software systems (OpenSSH, KOffice and FreeBSD).},
	Author = {Jingwei Wu and Richard C. Holt and Ahmed E. Hassan},
	Booktitle = {{Proc. of the 11th Working Conf. on Reverse Engineering (WCRE)}},
	Date-Added = {2013-11-25 16:59:11 +0000},
	Date-Modified = {2013-11-25 17:00:44 +0000},
	Pages = {80--89},
	Title = {{Exploring Software Evolution Using Spectrographs}},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGS4uL1BhcGVycy93Y3JlMjAwNF93dS5wZGbSFwsYGVdOUy5kYXRhTxEBhgAAAAABhgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OD3djcmUyMDA0X3d1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFvOeTOuOx6AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOuTLKAAAAAQAMAAoODgAJZz8ACWc8AAIAOk1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgB3Y3JlMjAwNF93dS5wZGYADgAgAA8AdwBjAHIAZQAyADAAMAA0AF8AdwB1AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAqVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvd2NyZTIwMDRfd3UucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AqgCvALcCQQJDAkgCUwJcAmoCbgJ1An4CgwKQApMCpQKoAq0AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACrw==}}

@article{dambros2009tse,
	Abstract = {Software evolution analysis provides a valuable source of information that can be used both to understand a system's design and predict its future development. While for many program comprehension purposes, it is sufficient to model a single version of a system, there are types of information that can only be recovered when the history of a system is taken into account. Logical coupling, the implicit dependency between software artifacts that have been changed together, is an example of such information. Previous research has dealt with low-level couplings between files, leading to an explosion of the data to be analyzed, or has abstracted the logical couplings to the level of modules, leading to a loss of detailed information. In this paper, we present a visualization-based approach that integrates logical coupling information at different levels of abstraction. This facilitates an in-depth analysis of the logical couplings, and at the same time, leads to a characterization of a system's modules in terms of their logical coupling. The presented approach supports the retrospective analysis of a software system and maintenance activities such as restructuring and redocumentation. We illustrate retrospective analysis on two large open-source software systems.},
	Author = {Marco D'Ambros and Michele Lanza and Mircea Lungu},
	Date-Added = {2013-11-25 16:55:56 +0000},
	Date-Modified = {2013-11-25 16:59:04 +0000},
	Journal = {Transactions on Software Engineering (TSE)},
	Number = {5},
	Pages = {720--735},
	Title = {{Visualizing Co-Change Information with the Evolution Radar}},
	Volume = {35},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy90c2UyMDA5X2RhbWJyb3MucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN0c2UyMDA5X2RhbWJyb3MucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABbzTBzrjrsAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzrkyAAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdHNlMjAwOV9kYW1icm9zLnBkZgAOACgAEwB0AHMAZQAyADAAMAA5AF8AZABhAG0AYgByAG8AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3RzZTIwMDlfZGFtYnJvcy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{kemerer2009tse,
	Abstract = {This research investigates the effect of review rate on defect removal effectiveness and the quality of software products, while controlling for a number of potential confounding factors. Two data sets of 371 and 246 programs, respectively, from a Personal Software Process (PSP) approach were analyzed using both regression and mixed models. Review activities in the PSP process are those steps performed by the developer in a traditional inspection process. The results show that the PSP review rate is a significant factor affecting defect removal effectiveness, even after accounting for developer ability and other significant process variables. The recommended review rate of 200 LOC/hour or less was found to be an effective rate for individual reviews, identifying nearly two-thirds of the defects in design reviews and more than half of the defects in code reviews.},
	Author = {Chris F. Kemerer and Mark C. Paulk},
	Date-Added = {2013-11-21 00:48:00 +0000},
	Date-Modified = {2013-11-21 00:49:45 +0000},
	Journal = {{Transactions on Software Engineering (TSE)}},
	Number = {4},
	Pages = {534--550},
	Title = {{The Impact of Design and Code Reviews on Software Quality: An Empirical Study Based on PSP Data}},
	Volume = {35},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy90c2UyMDA5X2tlbWVyZXIucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN0c2UyMDA5X2tlbWVyZXIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABaAXvzrHZYgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzrIfsgAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdHNlMjAwOV9rZW1lcmVyLnBkZgAOACgAEwB0AHMAZQAyADAAMAA5AF8AawBlAG0AZQByAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3RzZTIwMDlfa2VtZXJlci5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{tanaka1995icse,
	Abstract = {This paper describes an actual experience of software process improvement at OMRON corporation. For effective technical transfer, a software engineering process group (SEPG) has set three principal goals as follows: (1) motivate developers to improve on their process, (2) describe and define current software process correctly and in detail, (3) present a feasible action plan for developers to follow. To attain these goals, the SEPG has proposed a process improvement procedure by describing the current process and estimating the benefits gained by the improvement. Firstly the SEPG, held a series of interviews with developers and depicted a flow map in the form of a Petri net which describes the current, software process. Secondly, the group constructed an action plan from the in-depth analysis of the current flow map, and estimated the benefits obtained if this plan were to be rigorously followed. As a result, both the action plan and the benefit estimation were agreed by the developers as a feasible action plan. Furthermore, by applying the action plan to a practical project, it was confirmed that, compared to a similar project, approximately 10% of the total effort/KLOC is reduced at test phases. Thus we came to a conclusion that the principal goals and the proposed procedure are proven to be effective for reducing the development effort at OMRON corporation.},
	Author = {Toshifumi Tanaka and Keishi Sakamoto and Shinji Kusumoto and Ken-ichi Matsumoto and Tohru Kikuno},
	Booktitle = {{Proc. of the 17th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-11-18 07:27:55 +0000},
	Date-Modified = {2013-11-18 07:31:18 +0000},
	Pages = {123--132},
	Title = {{Improvement of Software Process by Process Description and Benefit Estimation}},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pY3NlMTk5NV90YW5ha2EucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpY3NlMTk5NV90YW5ha2EucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYplOzq7sRgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzq8ylgAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTE5OTVfdGFuYWthLnBkZgAOACgAEwBpAGMAcwBlADEAOQA5ADUAXwB0AGEAbgBhAGsAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2UxOTk1X3RhbmFrYS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{koru2009tse,
	Abstract = {The importance of the relationship between size and defect proneness of software modules is well recognized. Understanding the nature of that relationship can facilitate various development decisions related to prioritization of quality assurance activities. Overall, the previous research only drew a general conclusion that there was a monotonically increasing relationship between module size and defect proneness. In this study, we analyzed class-level size and defect data in order to increase our understanding of this crucial relationship. In order to obtain validated and more generalizable results, we studied four large-scale object-oriented products, Mozilla, Cn3d, JBoss, and Eclipse. Our results consistently revealed a significant effect of size on defect proneness; however, contrary to common intuition, the size-defect relationship took a logarithmic form, indicating that smaller classes were proportionally more problematic than larger classes. Therefore, practitioners should consider giving higher priority to smaller modules when planning focused quality assurance activities with limited resources. For example, in Mozilla and Eclipse, an inspection strategy investing 80% of available resources on 100-LOC classes and the rest on 1,000-LOC classes would be more than twice as cost effective as the opposite strategy. These results should be immediately useful to guide focused quality assurance activities in large-scale software projects.},
	Author = {A. G\"{u}ne\c{s} Koru and Dongsong Zhang and Khaled El Emam and Hongfang Liu},
	Date-Added = {2013-11-18 05:13:41 +0000},
	Date-Modified = {2013-11-18 05:18:04 +0000},
	Journal = {Transactions on Software Engineering (TSE)},
	Number = {2},
	Pages = {293--304},
	Title = {{An Investigation into the Functional Form of the Size-Defect Relationship for Software Modules}},
	Volume = {35},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy90c2UyMDA5X2tvcnUucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhB0c2UyMDA5X2tvcnUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYuywzq8MGgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzq9SagAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdHNlMjAwOV9rb3J1LnBkZgAADgAiABAAdABzAGUAMgAwADAAOQBfAGsAbwByAHUALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy90c2UyMDA5X2tvcnUucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@inproceedings{rigby2013fse,
	Abstract = {Software peer review is practiced on a diverse set of software projects that have drastically different settings, cultures, incentive systems, and time pressures. In an effort to characterize and understand these differences we examine two Google-led projects, Android and Chromium OS, three Microsoft projects, Bing, Office, and MS SQL, and projects internal to AMD. We contrast our findings with data taken from traditional software inspection conducted on a Lucent project and from open source software peer review on six projects, including Apache, Linux, and KDE. Our measures of interest include the review interval, the number of developers involved in review, and proxy measures for the number of defects found during review. We find that despite differences among projects, many of the characteristics of the review process have independently converged to similar values which we think indicate general principles of code review practice. We also introduce a measure of the degree to which knowledge is shared during review. This is an aspect of review practice that has traditionally only had experiential support. Our knowledge sharing measure shows that conducting peer review increases the number of distinct files a developer knows about by 66% to 150% depending on the project. This paper is one of the first studies of contemporary review in software firms and the most diverse study of peer review to date.},
	Author = {Peter C. Rigby and Christian Bird},
	Booktitle = {{Proc. of the 9th joint meeting of the European Software Engineering Conf. and the Symposium on the Foundations of Software Engineering (ESEC/FSE)}},
	Date-Added = {2013-11-15 07:28:25 +0000},
	Date-Modified = {2014-03-21 14:52:05 +0000},
	Pages = {202--212},
	Title = {{Convergent Contemporary Software Peer Review Practices}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9mc2UyMDEzX3JpZ2J5LnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RZnNlMjAxM19yaWdieS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVytnM6rN5EAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM6rfeEAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGZzZTIwMTNfcmlnYnkucGRmAA4AJAARAGYAcwBlADIAMAAxADMAXwByAGkAZwBiAHkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9mc2UyMDEzX3JpZ2J5LnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@inproceedings{rigby2011icse,
	Abstract = {Software peer review has proven to be a successful technique in open source software (OSS) development. In contrast to industry, where reviews are typically assigned to specific individuals, changes are broadcast to hundreds of potentially interested stakeholders. Despite concerns that reviews may be ignored, or that discussions will deadlock because too many uninformed stakeholders are involved, we find that this approach works well in practice. In this paper, we describe an empirical study to investigate the mechanisms and behaviours that developers use to find code changes they are competent to review. We also explore how stakeholders interact with one another during the review process. We manually examine hundreds of reviews across five high profile OSS projects. Our findings provide insights into the simple, community-wide techniques that developers use to effectively manage large quantities of reviews. The themes that emerge from our study are enriched and validated by interviewing long-serving core developers.},
	Author = {Peter C. Rigby and Margaret-Anne Storey},
	Booktitle = {{Proc. of the 33rd Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-11-15 07:25:50 +0000},
	Date-Modified = {2013-11-15 07:27:40 +0000},
	Pages = {541--550},
	Title = {{Understanding Broadcast Based Peer Review on Open Source Software Projects}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9pY3NlMjAxMV9yaWdieS5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmljc2UyMDExX3JpZ2J5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFcrLPOqzb7AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOq31LAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAxMV9yaWdieS5wZGYAAA4AJgASAGkAYwBzAGUAMgAwADEAMQBfAHIAaQBnAGIAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2UyMDExX3JpZ2J5LnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{rigby2008icse,
	Abstract = {Peer review is seen as an important quality assurance mechanism in both industrial development and the open source software (OSS) community. The techniques for performing inspections have been well studied in industry; in OSS development, peer reviews are less well understood. We examine the two peer review techniques used by the successful, mature Apache server project: review-then-commit and commit-then-review. Using archival records of email discussion and version control repositories, we construct a series of metrics that produces measures similar to those used in traditional inspection experiments. Specifically, we measure the frequency of review, the level of participation in reviews, the size of the artifact under review, the calendar time to perform a review, and the number of reviews that find defects. We provide a comparison of the two Apache review techniques as well as a comparison of Apache review to inspection in an industrial project. We conclude that Apache reviews can be described as (1) early, frequent reviews (2) of small, independent, complete contributions (3) conducted asynchronously by a potentially large, but actually small, group of self-selected experts (4) leading to an efficient and effective peer review technique.},
	Author = {Peter C. Rigby and Daniel M. German and Margaret-Anne Storey},
	Booktitle = {{Proc. of the 30th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-11-15 07:20:57 +0000},
	Date-Modified = {2013-11-15 07:25:32 +0000},
	Pages = {541--550},
	Title = {{Open Source Software Peer Review Practices: A Case Study of the Apache Server}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9pY3NlMjAwOF9yaWdieS5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmljc2UyMDA4X3JpZ2J5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFcpkbOqzWUAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOq3vkAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAwOF9yaWdieS5wZGYAAA4AJgASAGkAYwBzAGUAMgAwADAAOABfAHIAaQBnAGIAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2UyMDA4X3JpZ2J5LnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{hassan2009icse,
	Abstract = {Predicting the incidence of faults in code has been commonly associated with measuring complexity. In this paper, we propose complexity metrics that are based on the code change process instead of on the code. We conjecture that a complex code change process negatively affects its product, i.e., the software system. We validate our hypothesis empirically through a case study using data derived from the change history for six large open source projects. Our case study shows that our change complexity metrics are better predictors of fault potential in comparison to other well-known historical predictors of faults, i.e., prior modifications and prior faults.},
	Author = {Ahmed E. Hassan},
	Booktitle = {{Proc. of the 31st Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-11-14 01:33:27 +0000},
	Date-Modified = {2013-11-18 01:12:51 +0000},
	Pages = {78--88},
	Title = {{Predicting Faults Using the Complexity of Code Changes}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pY3NlMjAwOV9oYXNzYW4ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpY3NlMjAwOV9oYXNzYW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzbSczh/ShQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAziAKxQAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTIwMDlfaGFzc2FuLnBkZgAOACgAEwBpAGMAcwBlADIAMAAwADkAXwBoAGEAcwBzAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2UyMDA5X2hhc3Nhbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{bacchelli2013icse,
	Abstract = {Code review is a common software engineering practice employed both in open source and industrial contexts. Review today is less formal and more ``lightweight'' than the code inspections performed and studied in the 70s and 80s. We empirically explore the motivations, challenges, and outcomes of tool-based code reviews. We observed, interviewed, and surveyed developers and managers and manually classified hundreds of review comments across diverse teams at Microsoft. Our study reveals that while finding defects remains the main motivation for review, reviews are less about defects than expected and instead provide additional benefits such as knowledge transfer, increased team awareness, and creation of alternative solutions to problems. Moreover, we find that code and change understanding is the key aspect of code reviewing and that developers employ a wide range of mechanisms to meet their understanding needs, most of which are not met by current tools. We provide recommendations for practitioners and researchers.},
	Author = {Alberto Bacchelli and Christian Bird},
	Booktitle = {{Proc. of the 35th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-11-12 06:39:57 +0000},
	Date-Modified = {2013-11-12 06:42:37 +0000},
	Pages = {712--721},
	Title = {{Expectations, Outcomes, and Challenges of Modern Code Review}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QLC4uL1BhcGVycy9JQ1NFMjAxMy9pY3NlMTMvcDcxMi1iYWNjaGVsbGkucGRm0hcLGBlXTlMuZGF0YU8RAb4AAAAAAb4AAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAGf5XxJwNzEyLWJhY2NoZWxsaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ/l2zasPUAAAAAAAAAAAAAEABAAACSAAAAAAAAAAAAAAAAAAAAAGaWNzZTEzABAACAAAzQf1+gAAABEACAAAzatHkAAAAAEAFABn+V8AbUQOAAoODgAJZz8ACWc8AAIAT01hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBJQ1NFMjAxMzoAaWNzZTEzOgBwNzEyLWJhY2NoZWxsaS5wZGYAAA4AJgASAHAANwAxADIALQBiAGEAYwBjAGgAZQBsAGwAaQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL0lDU0UyMDEzL2ljc2UxMy9wNzEyLWJhY2NoZWxsaS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AvQDCAMoCjAKOApMCngKnArUCuQLAAskCzgLbAt4C8ALzAvgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC+g==}}

@inproceedings{hamasaki2013msr,
	Abstract = {We present four datasets that are focused on the general roles of OSS peer review members. With data mined from both an integrated peer review system and code source repositories, our rich datasets comprise of peer review data that was automatically recorded. Using the Android project as a case study, we describe our extraction methodology, the datasets and their application used for three separate studies. Our datasets are available online at http://sdlab.naist.jp/reviewmining/},
	Author = {Kazuki Hamasaki and Raula Gaikovina Kula and Norihiro Yoshida and Ana Erika Camargo Cruz and Kenji Fujiwara and Hajima Iida},
	Booktitle = {{Proc. of the 10th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2013-11-11 06:49:24 +0000},
	Date-Modified = {2013-11-11 06:51:51 +0000},
	Pages = {49--52},
	Title = {{Who Does What during a Code Review? Datasets of OSS Peer Review Repositories}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QKS4uL1BhcGVycy9JQ1NFMjAxMy9tc3IxMy9wNDktaGFtYXNha2kucGRm0hcLGBlXTlMuZGF0YU8RAbIAAAAAAbIAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAGf9iBBwNDktaGFtYXNha2kucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ/2KzZEZTQAAAAAAAAAAAAEABAAACSAAAAAAAAAAAAAAAAAAAAAFbXNyMTMAABAACAAAzQf1+gAAABEACAAAzZFRjQAAAAEAFABn/YgAbUQOAAoODgAJZz8ACWc8AAIATE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBJQ1NFMjAxMzoAbXNyMTM6AHA0OS1oYW1hc2FraS5wZGYADgAiABAAcAA0ADkALQBoAGEAbQBhAHMAYQBrAGkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADpVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9JQ1NFMjAxMy9tc3IxMy9wNDktaGFtYXNha2kucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AugC/AMcCfQJ/AoQCjwKYAqYCqgKxAroCvwLMAs8C4QLkAukAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6w==}}

@inproceedings{rahman2011icse,
	Author = {Foyzur Rahman and Premkumar Devanbu},
	Booktitle = {{Proc. of the 33rd Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-11-04 13:13:59 +0000},
	Date-Modified = {2013-11-04 13:16:15 +0000},
	Pages = {491--500},
	Title = {{Ownership, Experience and Defects: A Fine-Grained Study of Authorship}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QKy4uL1BhcGVycy9Qcm9jSUNTRTExL2ljc2UxMS9wNDkxLXJhaG1hbi5wZGbSFwsYGVdOUy5kYXRhTxEBtAAAAAABtAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg+TD3A0OTEtcmFobWFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKEJfJ1xeQAAAAAAAAAAAAAQAEAAAJIAAAAAAAAAAAAAAAAAAAAAZpY3NlMTEAEAAIAADNB/X6AAAAEQAIAADJ10/QAAAAAQAUAAoPkwAKDt0ACg4OAAlnPwAJZzwAAgBOTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AFByb2NJQ1NFMTE6AGljc2UxMToAcDQ5MS1yYWhtYW4ucGRmAA4AIAAPAHAANAA5ADEALQByAGEAaABtAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL1Byb2NJQ1NFMTEvaWNzZTExL3A0OTEtcmFobWFuLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALwAwQDJAoECgwKIApMCnAKqAq4CtQK+AsMC0ALTAuUC6ALtAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=}}

@inproceedings{mukadam2013msr,
	Author = {Murtuza Mukadam and Christian Bird and Peter C. Rigby},
	Booktitle = {{Proc. of the 10th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2013-11-04 13:03:53 +0000},
	Date-Modified = {2013-11-04 13:05:36 +0000},
	Pages = {45--48},
	Title = {{Gerrit Software Code Review Data from Android}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QKC4uL1BhcGVycy9JQ1NFMjAxMy9tc3IxMy9wNDUtbXVrYWRhbS5wZGbSFwsYGVdOUy5kYXRhTxEBsAAAAAABsAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAAZ/2ID3A0NS1tdWthZGFtLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABn/a7NkRlMAAAAAAAAAAAAAQAEAAAJIAAAAAAAAAAAAAAAAAAAAAVtc3IxMwAAEAAIAADNB/X6AAAAEQAIAADNkVGMAAAAAQAUAGf9iABtRA4ACg4OAAlnPwAJZzwAAgBLTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AElDU0UyMDEzOgBtc3IxMzoAcDQ1LW11a2FkYW0ucGRmAAAOACAADwBwADQANQAtAG0AdQBrAGEAZABhAG0ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADlVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9JQ1NFMjAxMy9tc3IxMy9wNDUtbXVrYWRhbS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AuQC+AMYCegJ8AoECjAKVAqMCpwKuArcCvALJAswC3gLhAuYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6A==}}

@inproceedings{riehle2014hicss,
	Abstract = {Many open source projects have long become commercial. This paper shows just how much of open source software development is paid work and how much has remained volunteer work. Using a conservative approach, we find that about 50% of all open source software development has been paid work for many years now and that many small projects are fully paid for by companies. However, we also find that any non-trivial project balances the amount of paid developer with volunteer work, and we suggest that the ratio of volunteer to paid work can serve as an indicator for the health of open source projects and aid the management of the respective communities.},
	Author = {Dirk Riehle and Philipp Riemer and Carsten Kolassa and Michael Schmidt},
	Booktitle = {{Proc. of the 47th Hawaii Int'l Conf. on System Science (HICSS)}},
	Date-Added = {2013-10-08 15:46:29 +0000},
	Date-Modified = {2013-10-08 15:49:23 +0000},
	Note = {To appear},
	Title = {{Paid vs. Volunteer Work in Open Source}},
	Year = {2014},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9oaWNzczIwMTRfcmllaGxlLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaGljc3MyMDE0X3JpZWhsZS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASHixM55odsAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM552hsAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGhpY3NzMjAxNF9yaWVobGUucGRmAAAOACoAFABoAGkAYwBzAHMAMgAwADEANABfAHIAaQBlAGgAbABlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaGljc3MyMDE0X3JpZWhsZS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@article{kasper2008emse,
	Abstract = {Literature on the topic of code cloning often asserts that duplicating code within a software system is a bad practice, that it causes harm to the system's design and should be avoided. However, in our studies, we have found significant evidence that cloning is often used in a variety of ways as a principled engineering tool. For example, one way to evaluate possible new features for a system is to clone the affected subsystems and introduce the new features there, in a kind of sandbox testbed. As features mature and become stable within the experimental subsystems, they can be migrated incrementally into the stable code base; in this way, the risk of introducing instabilities in the stable version is minimized. This paper describes several patterns of cloning that we have observed in our case studies and discusses the advantages and disadvantages associated with using them. We also examine through a case study the frequencies of these clones in two medium-sized open source software systems, the Apache web server and the Gnumeric spreadsheet application. In this study, we found that as many as 71\% of the clones could be considered to have a positive impact on the maintainability of the software system.},
	Author = {Cory J. Kasper and Michael W. Godfrey},
	Date-Added = {2013-10-05 13:44:31 +0000},
	Date-Modified = {2013-10-05 13:46:36 +0000},
	Journal = {Empirical Software Engineering (EMSE)},
	Number = {6},
	Pages = {645--692},
	Title = {``{C}loning considered harmful'' considered harmful: patterns of cloning in software},
	Volume = {13},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9lbXNlMjAwOF9rYXNwZXIucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNlbXNlMjAwOF9rYXNwZXIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGGPyzmck2gAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzmddGgAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZW1zZTIwMDhfa2FzcGVyLnBkZgAOACgAEwBlAG0AcwBlADIAMAAwADgAXwBrAGEAcwBwAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2Vtc2UyMDA4X2thc3Blci5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{rahman2012emse,
	Abstract = {Clones are generally considered bad programming practice in software engineering folklore. They are identified as a bad smell (Fowler et al. 1999) and a major contributor to project maintenance difficulties. Clones inherently cause code bloat, thus increasing project size and maintenance costs. In this work, we try to validate the conventional wisdom empirically to see whether cloning makes code more defect prone. This paper analyses the relationship between cloning and defect proneness. For the four medium to large open source projects that we studied, we find that, first, the great majority of bugs are not significantly associated with clones. Second, we find that clones may be less defect prone than non-cloned code. Third, we find little evidence that clones with more copies are actually more error prone. Fourth, we find little evidence to support the claim that clone groups that span more than one file or directory are more defect prone than collocated clones. Finally, we find that developers do not need to put a disproportionately higher effort to fix clone dense bugs. Our findings do not support the claim that clones are really a ``bad smell'' (Fowler et al. 1999). Perhaps we can clone, and breathe easily, at the same time.},
	Author = {Foyzur Rahman and Christian Bird and Premkumar Devanbu},
	Date-Added = {2013-10-05 13:39:56 +0000},
	Date-Modified = {2013-10-05 13:43:54 +0000},
	Journal = {Empirical Software Engineering (EMSE)},
	Number = {4-5},
	Pages = {503--530},
	Title = {Clones: what is that smell?},
	Volume = {17},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9lbXNlMjAxMl9yYWhtYW4ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNlbXNlMjAxMl9yYWhtYW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxc1XzhRXMAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzhSPcAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZW1zZTIwMTJfcmFobWFuLnBkZgAOACgAEwBlAG0AcwBlADIAMAAxADIAXwByAGEAaABtAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2Vtc2UyMDEyX3JhaG1hbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{hermans2013icse,
	Author = {{Felienne Hermans and Ben Sedee and Martin Pinzger and Arie van Deursen}},
	Booktitle = {{Proc. of the 35th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-10-02 15:17:49 +0000},
	Date-Modified = {2013-10-02 15:19:58 +0000},
	Pages = {292--301},
	Title = {{Data Clone Detection and Visualization in Spreadsheets}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NlMjAxM19oZXJtYW5zLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzZTIwMTNfaGVybWFucy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR02Es5xseUAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM5x6iUAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc2UyMDEzX2hlcm1hbnMucGRmAAAOACoAFABpAGMAcwBlADIAMAAxADMAXwBoAGUAcgBtAGEAbgBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMTNfaGVybWFucy5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{juergens2010icse,
	Abstract = {Due to their pivotal role in software engineering, considerable effort is spent on the quality assurance of software requirements specifications. As they are mainly described in natural language, relatively few means of automated quality assessment exist. However, we found that clone detection, a technique widely applied to source code, is promising to assess one important quality aspect in an automated way, namely redundancy that stems from copy&paste operations. This paper describes a large-scale case study that applied clone detection to 28 requirements specifications with a total of 8,667 pages. We report on the amount of redundancy found in real-world specifications, discuss its nature as well as its consequences and evaluate in how far existing code clone detection approaches can be applied to assess the quality of requirements specifications in practice.},
	Author = {Elmar Juergens and Florian Deissenboeck and Martin Feilkas and Benjamin Hummel and Bernhard Schaetz and Stefan Wagner and Christoph Domann and Jonathan Streit},
	Booktitle = {{Proc. of the 32nd Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-10-02 15:12:51 +0000},
	Date-Modified = {2013-10-02 15:17:31 +0000},
	Pages = {79--88},
	Title = {{Can Clone Detection Support Quality Assessments of Requirements Specifications?}},
	Volume = {2},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NlMjAxMF9qdWVyZ2Vucy5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc2UyMDEwX2p1ZXJnZW5zLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADi+NHOOPG5AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOOSn5AAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAxMF9qdWVyZ2Vucy5wZGYADgAsABUAaQBjAHMAZQAyADAAMQAwAF8AagB1AGUAcgBnAGUAbgBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMTBfanVlcmdlbnMucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{ducasse1999icsm,
	Abstract = {Code duplication is one of the factors that severely complicates the maintenance and evolution of large software systems. Techniques for detecting duplicated code exist but rely mostly on parsers, technology that has proven to be brittle in the face of different languages and dialects. In this paper we show that is possible to circumvent this hindrance by applying a language independent and visual approach, i.e. a tool that requires no parsing, yet is able to detect a significant amount of code duplication. We validate our approach on a number of case studies, involving four different implementation languages and ranging from 256 K up to 13 Mb of source code size.},
	Author = {St\'{e}phane Ducasse and Matthias Rieger and Serge Demeyer},
	Booktitle = {{Proc. of the 15th Int'l Conf. on Software Maintenance (ICSM)}},
	Date-Added = {2013-10-02 14:11:51 +0000},
	Date-Modified = {2013-10-02 14:14:07 +0000},
	Title = {{A Language Independent Approach for Detecting Duplicated Code}},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NtMTk5OV9kdWNhc3NlLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzbTE5OTlfZHVjYXNzZS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR0hVM5xol4AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM5x2p4AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc20xOTk5X2R1Y2Fzc2UucGRmAAAOACoAFABpAGMAcwBtADEAOQA5ADkAXwBkAHUAYwBhAHMAcwBlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTE5OTlfZHVjYXNzZS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{lague1997icsm,
	Abstract = {The aim of the experiment presented in this paper is to present an insight into the evaluation of the potential benefits of introducing a function clone detection technology in an industrial software development process. To take advantage of function clone detection, two modifications to the software development process are presented. Our experiment consists of evaluating the impact that these proposed changes would have had on a specific software system if they had been applied over a 3 year period (involving 10000 person-months), where 6 subsequent versions of the software under study were released. The software under study is a large telecommunication system. In total 89 million lines of code have been analyzed. A first result showed that, against our expectations, a significant number of clones are being removed from the system over time. However, this effort is insufficient to prevent the growth of the overall number of clones in the system. In this context the first process change would have added value. We have also found that the second process change would have provided programmers with a significant number of opportunities for correcting problems before customers experienced them. This result shows a potential for improving the software system quality and customer satisfaction.},
	Author = {{Bruno Lagu\"{e} and Daniel Proulx and Ettore M. Merlo and Jean Mayrand and John Hudepohl}},
	Booktitle = {{Proc. of the 13th Int'l Conf. on Software Maintenance (ICSM)}},
	Date-Added = {2013-10-02 14:04:09 +0000},
	Date-Modified = {2013-10-02 14:11:45 +0000},
	Pages = {314--321},
	Title = {{Assessing the Benefits of Incorporating Function Clone Detection in a Development Process}},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9pY3NtMTk5N19sYWd1ZS5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmljc20xOTk3X2xhZ3VlLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEdH/rOcaG+AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOcdn+AAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtMTk5N19sYWd1ZS5wZGYAAA4AJgASAGkAYwBzAG0AMQA5ADkANwBfAGwAYQBnAHUAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc20xOTk3X2xhZ3VlLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{kontogiannis1996asej,
	Abstract = {A legacy system is an operational, large-scale software system that is maintained beyond its first generation of programmers. It typically represents a massive economic investment and is critical to the mission of the organization it serves. As such systems age, they become increasingly complex and brittle, and hence harder to maintain. They also become even more critical to the survival of their organization because the business rules encoded within the system are seldom documented elsewhere.
Our research is concerned with developing a suite of tools to aid the maintainers of legacy systems in recovering the knowledge embodied within the system. The activities, known collectively as ``program understanding'', are essential preludes for several key processes, including maintenance and design recovery for reengineering.
In this paper we present three pattern-matching techniques: source code metrics, a dynamic programming algorithm for finding the best alignment between two code fragments, and a statistical matching algorithm between abstract code descriptions represented in an abstract language and actual source code. The methods are applied to detect instances of code cloning in several moderately-sized production systems including tcsh, bash, and CLIPS.
The programmer's skill and experience are essential elements of our approach. Selection of particular tools and analysis methods depends on the needs of the particular task to be accomplished. Integration of the tools provides opportunities for synergy, allowing the programmer to select the most appropriate tool for a given task.},
	Author = {K. A. Kontogiannis and R. Demori and E. Merlo and M. Galler and M. Bernstein},
	Date-Added = {2013-10-02 13:59:29 +0000},
	Date-Modified = {2013-10-02 14:03:42 +0000},
	Journal = {Automated Software Engineering},
	Number = {1-2},
	Pages = {77--108},
	Title = {{Pattern Matching for Clone and Concept Detection}},
	Volume = {3},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIy4uL1BhcGVycy9hc2VqMTk5Nl9rb250b2dpYW5uaXMucGRm0hcLGBlXTlMuZGF0YU8RAa4AAAAAAa4AAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhlhc2VqMTk5Nl9rb250b2dpYW5uaXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHRNXznGfPQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAznHXfQAAAAEADAAKDg4ACWc/AAlnPAACAERNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAYXNlajE5OTZfa29udG9naWFubmlzLnBkZgAOADQAGQBhAHMAZQBqADEAOQA5ADYAXwBrAG8AbgB0AG8AZwBpAGEAbgBuAGkAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIANFVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2FzZWoxOTk2X2tvbnRvZ2lhbm5pcy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC0ALkAwQJzAnUCegKFAo4CnAKgAqcCsAK1AsICxQLXAtoC3wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALh}}

@inproceedings{baker1995wcre,
	Abstract = {This paper describes how a program called dup can be used to locate instances of duplication or near-duplication in a software system. Dup reports both textually identical sections of code and sections that are the same textually except for systematic substitution of one set of variable names and constants for another. Further processing locates longer sections of code that are the same except for other small modifications. Experimental results from running dup on millions of lines from two large software systems show dup to be both effective at locating duplication and fast. Applications could include identifying sections of code that should be replaced by procedures, elimination of duplication during reengineering of the system, redocumentation to include references to copies, and debugging.},
	Author = {Brenda S. Baker},
	Booktitle = {{Proc. of the 2nd Working Conf. on Reverse Engineering (WCRE)}},
	Date-Added = {2013-10-02 13:56:55 +0000},
	Date-Modified = {2013-10-02 13:58:28 +0000},
	Pages = {86--95},
	Title = {{On Finding Duplication and Near-Duplication in Large Software Systems}},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy93Y3JlMTk5NV9iYWtlci5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEndjcmUxOTk1X2Jha2VyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEdENzOcZ7fAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOcdcfAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgB3Y3JlMTk5NV9iYWtlci5wZGYAAA4AJgASAHcAYwByAGUAMQA5ADkANQBfAGIAYQBrAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3djcmUxOTk1X2Jha2VyLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{alves2010icsm,
	Abstract = {A wide variety of software metrics have been proposed and a broad range of tools is available to measure them. However, the effective use of software metrics is hindered by the lack of meaningful thresholds. Thresholds have been proposed for a few metrics only, mostly based on expert opinion and a small number of observations. Previously proposed methodologies for systematically deriving metric thresholds have made unjustified assumptions about the statistical properties of source code metrics. As a result, the general applicability of the derived thresholds is jeopardized. We designed a method that determines metric thresholds empirically from measurement data. The measurement data for different software systems are pooled and aggregated after which thresholds are selected that (i) bring out the metric's variability between systems and (ii) help focus on a reasonable percentage of the source code volume. Our method respects the distributions and scales of source code metrics, and it is resilient against outliers in metric values or system size. We applied our method to a benchmark of 100 object-oriented software systems, both proprietary and open-source, to derive thresholds for metrics included in the SIG maintainability model.},
	Author = {Tiago L. Alves and Christiaan Ypma and Joost Visser},
	Booktitle = {{Proc. of the 26th Int'l Conf. on Software Maintenance (ICSM)}},
	Date-Added = {2013-10-01 19:54:01 +0000},
	Date-Modified = {2013-10-01 19:56:52 +0000},
	Pages = {1--10},
	Title = {{Deriving Metric Thresholds from Benchmark Data}},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9pY3NtMjAxMF9hbHZlcy5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmljc20yMDEwX2FsdmVzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEX2yjOZbD7AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOZek7AAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtMjAxMF9hbHZlcy5wZGYAAA4AJgASAGkAYwBzAG0AMgAwADEAMABfAGEAbAB2AGUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc20yMDEwX2FsdmVzLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{hexbin,
	Abstract = {High-performance interaction with scatterplot matrices is a powerful approach to exploratory multivariate data analysis. For a small number of data points, real-time interaction is possible and overplotting is usually not a major problem. When the number of plotted points is large, however, display techniques that deal with overplotting and slow production are important. This article addresses these two problems. Topics include density representation by gray scale or by symbol area, alternatives to brushing, and animation sequences. We also discuss techniques that are generally applicable, including interactive graphical subset selection from any plot in a collection of scatterplots and comparison of scatterplot matrices.},
	Author = {Daniel B. Carr and Richard J. Littlefield and W. L. Nicholson and J. S. Littlefield},
	Date-Added = {2013-09-25 12:46:30 +0000},
	Date-Modified = {2013-09-25 12:54:50 +0000},
	Journal = {Journal of the Amarican Statistical Association},
	Number = {398},
	Pages = {424--436},
	Title = {{Scatterplot Matrix Techniques for Large N}},
	Volume = {82},
	Year = {1987},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QFC4uL1BhcGVycy9oZXhiaW4ucGRm0hcLGBlXTlMuZGF0YU8RAXQAAAAAAXQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODgpoZXhiaW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGNG0zmhUJgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzmiMZgAAAAEADAAKDg4ACWc/AAlnPAACADVNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaGV4YmluLnBkZgAADgAWAAoAaABlAHgAYgBpAG4ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACVVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9oZXhiaW4ucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKUAqgCyAioCLAIxAjwCRQJTAlcCXgJnAmwCeQJ8Ao4CkQKWAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAApg=}}

@inproceedings{yang2012msr,
	Abstract = {Code search is an integral part of software development and program comprehension. The difficulty of code search lies in the inability to guess the exact words used in the code. Therefore, it is crucial for keyword-based code search to expand queries with semantically related words, e.g., synonyms and abbreviations, to increase the search effectiveness. However, it is limited to rely on resources such as English dictionaries and WordNet to obtain semantically related words in software, because many words that are semantically related in software are not semantically related in English. This paper proposes a simple and general technique to automatically infer semantically related words in software by leveraging the context of words in comments and code. We achieve a reasonable accuracy in seven large and popular code bases written in C and Java. Our further evaluation against the state of art shows that our technique can achieve a higher precision and recall.},
	Author = {Jinqiu Yang and Lin Tan},
	Booktitle = {{Proc. of the 9th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2013-09-18 19:34:27 +0000},
	Date-Modified = {2013-09-18 19:36:00 +0000},
	Pages = {161--170},
	Title = {{Inferring Semantically Related Words from Software Context}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy9tc3IyMDEyX3lhbmcucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhBtc3IyMDEyX3lhbmcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEjHpzl947wAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzl+xLwAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAbXNyMjAxMl95YW5nLnBkZgAADgAiABAAbQBzAHIAMgAwADEAMgBfAHkAYQBuAGcALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9tc3IyMDEyX3lhbmcucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@inproceedings{mockus2010fse,
	Author = {Audris Mockus},
	Booktitle = {{Proc. of the 18th Symposium on the Foundations of Software Engineering (FSE)}},
	Date-Added = {2013-09-13 21:30:40 +0000},
	Date-Modified = {2013-09-13 21:33:04 +0000},
	Pages = {117--126},
	Title = {{Organizational Volatility and its Effects on Software Defects}},
	Year = {2010}}

@inproceedings{shihab2010esem,
	Author = {Emad Shihab and Zhen Ming Jiang and Walid M. Ibrahim and Bram Adams and Ahmed E. Hassan},
	Booktitle = {{Proc. of the 4th Int'l Symposium on Empirical Software Engineering and Measurement (ESEM)}},
	Date-Added = {2013-09-13 21:02:26 +0000},
	Date-Modified = {2013-09-13 21:29:07 +0000},
	Pages = {1--10},
	Title = {{Understanding the Impact of Code and Process Metrics on Post-Release Defects: A Case Study on the Eclipse Project}},
	Year = {2010}}

@book{appliedregression,
	Author = {John Fox},
	Date-Added = {2013-09-11 15:25:11 +0000},
	Date-Modified = {2013-09-11 15:27:26 +0000},
	Edition = {2$^\textit{nd}$},
	Publisher = {Sage Publications},
	Title = {{Applied Regression Analysis and Generalized Linear Models}},
	Year = {2008}}

@inproceedings{beaumont2012ipdpsw,
	Abstract = {In this paper, we consider the problem of scheduling a special kind of mixed data-parallel applications arising in the context of Continuous Integration. Continuous integration (CI) is a software engineering technique, which consists in re-building and testing interdependent software components as soon as developers modify them. The CI tool is able to provide quick feedback to the developers, which allows them to fix the bug soon after it has been introduced. The CI process can be described as a DAG where nodes represent package build tasks, and edges represent dependencies among these packages, build tasks themselves can in turn be run in parallel. Thus, CI can be viewed as a mixed data-parallel application. A crucial point for a successful CI process is its ability to provide quick feedback. Thus, make span minimization is the main goal. Our contribution is twofold. First we provide and analyze a large dataset corresponding to a build DAG. Second, we compare the performance of several scheduling heuristics on this dataset.},
	Author = {Olivier Beaumont and Nicholas Bonichon and Ludovic Court`{e}s and Xavier Hanin and Eelco Dolstra},
	Booktitle = {{Proc. of the 26th Int'l Parallel and Distributed Processing Symposium Workshops (IPDPSW)}},
	Date-Added = {2013-09-06 18:20:45 +0000},
	Date-Modified = {2013-09-06 18:26:38 +0000},
	Pages = {91--98},
	Title = {{Mixed Data-Parallel Scheduling for Distributed Continuous Integration}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIS4uL1BhcGVycy9pcGRwc3cyMDEyX2JlYXVtb250LnBkZtIXCxgZV05TLmRhdGFPEQGmAAAAAAGmAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4XaXBkcHN3MjAxMl9iZWF1bW9udC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQBILc5PluEAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM5PzyEAAAABAAwACg4OAAlnPwAJZzwAAgBCTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGlwZHBzdzIwMTJfYmVhdW1vbnQucGRmAA4AMAAXAGkAcABkAHAAcwB3ADIAMAAxADIAXwBiAGUAYQB1AG0AbwBuAHQALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADJVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pcGRwc3cyMDEyX2JlYXVtb250LnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALIAtwC/AmkCawJwAnsChAKSApYCnQKmAqsCuAK7As0C0ALVAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtc=}}

@inproceedings{dayanifard2005fase,
	Abstract = {The build architecture of legacy C/C++ software systems, groups program files in directories to represent logical components. The interfaces of these components are loosely defined by a set of header files that are typically grouped in one common include directory. As legacy systems evolve, these interfaces decay, which contribute to an increase in the build time and the number of conflict in parallel developments. This paper presents an empirical study of the build architecture of large commercial software systems, introduces a restructuring approach, based on Reflexion models and automatic clustering, and reports on a case study using VIM open source editor.},
	Author = {Homayoun Dayani-Fard and Yijun Yu and John Mylopoulos and Periklis Andritsos},
	Booktitle = {{Proc. of the 8th Int'l Conf. on Fundamental Approaches to Software Engineering (FASE)}},
	Date-Added = {2013-09-06 18:14:37 +0000},
	Date-Modified = {2013-09-06 18:20:27 +0000},
	Pages = {96--110},
	Title = {{Improving the Build Architecture of Legacy C/C++ Software Systems}},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIS4uL1BhcGVycy9mYXNlMjAwNV9kYXlhbmlmYXJkLnBkZtIXCxgZV05TLmRhdGFPEQGmAAAAAAGmAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4XZmFzZTIwMDVfZGF5YW5pZmFyZC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPyTe85OUDUAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM5OiHUAAAABAAwACg4OAAlnPwAJZzwAAgBCTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGZhc2UyMDA1X2RheWFuaWZhcmQucGRmAA4AMAAXAGYAYQBzAGUAMgAwADAANQBfAGQAYQB5AGEAbgBpAGYAYQByAGQALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADJVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9mYXNlMjAwNV9kYXlhbmlmYXJkLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALIAtwC/AmkCawJwAnsChAKSApYCnQKmAqsCuAK7As0C0ALVAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtc=}}

@article{cataldo2009tse,
	Abstract = {Prior research has shown that customer-reported software faults are often the result of violated dependencies that are not recognized by developers implementing software. Many types of dependencies and corresponding measures have been proposed to help address this problem. The objective of this research is to compare the relative performance of several of these dependency measures as they relate to customer-reported defects. Our analysis is based on data collected from two projects from two independent companies. Combined, our data set encompasses eight years of development activity involving 154 developers. The principal contribution of this study is the examination of the relative impact that syntactic, logical, and work dependencies have on the failure proneness of a software system. While all dependencies increase the fault proneness, the logical dependencies explained most of the variance in fault proneness, while workflow dependencies had more impact than syntactic dependencies. These results suggest that practices such as rearchitecting, guided by the network structure of logical dependencies, hold promise for reducing defects.},
	Author = {Marcelo Cataldo and Audris Mockus and Jeffrey A. Roberts and James D. Herbsleb},
	Date-Added = {2013-08-28 15:06:25 +0000},
	Date-Modified = {2013-08-28 15:08:29 +0000},
	Journal = {Transactions on Software Engineering (TSE)},
	Number = {6},
	Pages = {864--878},
	Title = {{Software Dependencies, Work Dependencies, and Their Impact on Failures}},
	Volume = {35},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy90c2UyMDA5X2NhdGFsZG8ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN0c2UyMDA5X2NhdGFsZG8ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6h/7zkOIHAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzkPAXAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdHNlMjAwOV9jYXRhbGRvLnBkZgAOACgAEwB0AHMAZQAyADAAMAA5AF8AYwBhAHQAYQBsAGQAbwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3RzZTIwMDlfY2F0YWxkby5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{fischer2005ijhci,
	Author = {Arnout R. H. Fischer and Frans J. J. Blommaert and Cees J. H. Midden},
	Date-Added = {2013-08-26 13:11:57 +0000},
	Date-Modified = {2013-08-26 13:18:04 +0000},
	Journal = {Int'l Journal of Human-Computer Interaction},
	Number = {2},
	Pages = {163--180},
	Title = {Monitoring and Evaluation of Time Delay},
	Volume = {19},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pamhjaTIwMDVfZmlzY2hlci5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWlqaGNpMjAwNV9maXNjaGVyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADnOSHOQMwAAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOQQRAAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpamhjaTIwMDVfZmlzY2hlci5wZGYADgAsABUAaQBqAGgAYwBpADIAMAAwADUAXwBmAGkAcwBjAGgAZQByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWpoY2kyMDA1X2Zpc2NoZXIucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@article{dabrowski2011iwc,
	Abstract = {For over 40 years, system response time has been a topic of interest and controversy in computer science. Since the late 1960s, the field has seen numerous studies conducted and articles written addressing the issue. Many factors were measured in these studies including: users' accuracy and error rates with different levels of system response time, user performance speed and the efficiency of the commands used, how user interactions with the computer changed as a result of changes in system response time, how their bodies reacted physiologically to those same changes and even how happy, satisfied, anxious or annoyed they were as system response times changed.

In this paper, we summarize the major issues in system response time research and look at what can be concluded from them. Generally, researchers have suggested specific response-time guidelines based on the complexity of the task or the type of interaction with the computer. We suggest that rather than system response time being task- or expectation-focused, instead interactions with a computer fall into two categories: control tasks and conversational tasks. For control tasks, immediate response times are necessary for optimal user performance whereas for conversational tasks, some delays may be necessary to maintain the optimal pacing of the on-going conversation. The location and duration of these delays will depend on both task complexity and user expectations. Future system response time research is needed to further quantify limits of delay detection, and the location and duration of inter-task delays to optimize user performance and satisfaction with computers.},
	Author = {Jim Dabrowski and Ethan V. Munson},
	Date-Added = {2013-08-26 12:54:29 +0000},
	Date-Modified = {2013-08-26 12:57:03 +0000},
	Journal = {Interacting with Computers},
	Number = {5},
	Pages = {555--564},
	Title = {40 Years of searching for the best computer system response time},
	Volume = {23},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pd2MyMDExX2RhYnJvd3NraS5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWl3YzIwMTFfZGFicm93c2tpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADmRcXOPjenAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADOPm/nAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpd2MyMDExX2RhYnJvd3NraS5wZGYADgAsABUAaQB3AGMAMgAwADEAMQBfAGQAYQBiAHIAbwB3AHMAawBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaXdjMjAxMV9kYWJyb3dza2kucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{Mockus2006,
	Author = {Audris Mockus},
	Booktitle = {{Proc. of the Int'l Conf. on Empirical Software Engineering Issues: Critical Assessment and Future Directions}},
	Pages = {91--99},
	Title = {Software support tools and experimental work},
	Year = {2007}}

@inproceedings{dietrich2012splc,
	Abstract = {With more than 11,000 optional and alternative features, the Linux kernel is a highly configurable piece of software. Linux is generally perceived as a textbook example for preprocessor-based product derivation, but more than 65 percent of all features are actually handled by the build system. Hence, variability-aware static analysis tools have to take the build system into account.
However, extracting variability information from the build system is difficult due to the declarative and turing-complete MAKE lan- guage. Existing approaches based on text processing do not cover this challenges and tend to be tailored to a specific Linux version and architecture. This renders them practically unusable as a basis for variability-aware tool support -- Linux is a moving target!
We describe a robust approach for extracting implementation variability from the Linux build system. Instead of extracting the variability information by a text-based analysis of all build scripts, our approach exploits the build system itself to produce this infor- mation. As our results show, our approach is robust and works for all versions and architectures from the (git-)history of Linux.},
	Author = {Christian Dietrich and Reinhard Tartler and Wolfgang Schr\"{o}der-Preikschat and Daniel Lohmann},
	Booktitle = {{Proc. of the 16th Int'l Software Product Line Conference (SPLC)}},
	Date-Added = {2013-06-04 13:17:37 +0000},
	Date-Modified = {2013-06-04 13:22:22 +0000},
	Pages = {21--30},
	Title = {{A Robust Approach for Variability Extraction from the Linux Build System}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9zcGxjMjAxMl9kaWV0cmljaC5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFXNwbGMyMDEyX2RpZXRyaWNoLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1xs7N012MAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADN05XMAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBzcGxjMjAxMl9kaWV0cmljaC5wZGYADgAsABUAcwBwAGwAYwAyADAAMQAyAF8AZABpAGUAdAByAGkAYwBoAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvc3BsYzIwMTJfZGlldHJpY2gucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@misc{google_moz,
	Date-Added = {2013-05-28 14:02:52 +0000},
	Date-Modified = {2013-05-28 14:10:23 +0000},
	Howpublished = {\href{https://blog.mozilla.org/blog/2011/12/20/mozilla-and-google-sign-new-agreement-for-default-search-in-firefox/}{{\tt https://blog.mozilla.org/blog/2011/12/20/mozilla-and-google-sign-new-agreement-for-default-search-in-firefox/}}},
	Title = {{Mozilla and Google Sign New Agreement for Default Search in Firefox}}}

@article{vickers2002iwc,
	Abstract = {The audio channel remains little used in most computing applications, often its use being relegated to providing trivial sound effects whose novelty value soon wears off. Nevertheless, in principle sound offers much to the process of human$\pm$computer interaction as for most people the notion of auditory imagery is easily accepted.
In this paper we explore how sound, speci{\textregistered}cally musical sound, can be used to communicate computing information. The {\textregistered}ndings of two studies are presented. The {\textregistered}rst investigated how pitch intervals and musical phrases of complex (non-sinusoidal) tones can be recognised. The second study aimed to demonstrate that musical structures could communicate information about high-level programming language structures and program run-time behaviour. Both studies showed that music could successfully be used as a communication medium and that listeners did not need to be musically trained to bene{\textregistered}t from the audio signals. Finally, recommendations for further work are made.},
	Author = {Paul Vickers and James L. Alty},
	Date-Added = {2013-05-27 20:56:32 +0000},
	Date-Modified = {2013-05-27 20:57:34 +0000},
	Journal = {Interacting with Computers},
	Pages = {435--456},
	Title = {Using music to communicate computing information},
	Volume = {14},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pd2MyMDAyX3ZpY2tlcnNfMi5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWl3YzIwMDJfdmlja2Vyc18yLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABSGPfNlr8YAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADNlvdYAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpd2MyMDAyX3ZpY2tlcnNfMi5wZGYADgAsABUAaQB3AGMAMgAwADAAMgBfAHYAaQBjAGsAZQByAHMAXwAyAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaXdjMjAwMl92aWNrZXJzXzIucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@article{vickers2002iwc2,
	Abstract = {In The Songs of Insects, Pierce (1949) described the striped ground cricket, Nemobius fasciatus- fasciatus, which chirps at a rate proportional to ambient air temperature. Twenty chirps-per-second tell us it is 31.4 8C; 16 chirps and it is 27 8C. This is a natural example of an auditory display, a mechanism for communicating data with sound. By applying auditory display techniques to computer programming we have attempted to give the bugs that live in software programs their own songs. We have developed the CAITLIN musical program auralisation system Vickers and Alty, 2002b) to allow structured musical mappings to be made of the constructs in Pascal programs. Initial experimental evaluation [Interacting with Computers (2002a,b)] showed that subjects could interpret the musical motifs used to represent the various Pascal language constructs.
In this paper we describe how the CAITLIN system was used to study the effects of musical program auralisation on debugging tasks performed by novice Pascal programmers. The results of the experiment indicate that a formal musical framework can act as a medium for communicating information about program behaviour, and that the information communicated could be used to assist with the task of locating bugs in faulty programs.},
	Author = {Paul Vickers and James L. Alty},
	Date-Added = {2013-05-27 20:34:00 +0000},
	Date-Modified = {2013-05-27 20:55:43 +0000},
	Journal = {Interacting with Computers},
	Pages = {793--819},
	Title = {When bugs sing},
	Volume = {14},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pd2MyMDAyX3ZpY2tlcnMucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpd2MyMDAyX3ZpY2tlcnMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQto3zXXBGwAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzXX5WwAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaXdjMjAwMl92aWNrZXJzLnBkZgAOACgAEwBpAHcAYwAyADAAMAAyAF8AdgBpAGMAawBlAHIAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2l3YzIwMDJfdmlja2Vycy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@incollection{robles2007ifip,
	Author = {Gregorio Robles and Santiago {Due\~{n}as} and Jesus M. Gonzalez-Barahona},
	Booktitle = {{Open Source Development, Adoption and Innovation}},
	Date-Added = {2013-05-27 03:23:37 +0000},
	Date-Modified = {2013-05-27 03:32:51 +0000},
	Pages = {121--132},
	Publisher = {Springer},
	Series = {{The International Federation for Information Processing (IFIP)}},
	Title = {{Corporate Involvement of Libre Software: Study of Presence in Debian Code over Time}},
	Volume = {234},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pZmlwMjAwN19yb2JsZXMucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpZmlwMjAwN19yb2JsZXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbSb0zchLcAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzciDsAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWZpcDIwMDdfcm9ibGVzLnBkZgAOACgAEwBpAGYAaQBwADIAMAAwADcAXwByAG8AYgBsAGUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2lmaXAyMDA3X3JvYmxlcy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{vanderstorm2008csmr,
	Abstract = {Failing integration builds are show stoppers. Development activity is stalled because developers have to wait with integrating new changes until the problem is fixed and a successful build has been run. We show how backtracking can be used to mitigate the impact of build failures in the context of component-based software development. This way, even in the face of failure, development may continue and a working version is always available.},
	Author = {Tijs van der Storm},
	Booktitle = {{Proc. of the 12th European Conf. on Software Maintenance and Reengineering (CSMR)}},
	Date-Added = {2013-05-15 02:56:24 +0000},
	Date-Modified = {2013-05-15 02:59:06 +0000},
	Pages = {233-242},
	Title = {{Backtracking Incremental Continuous Integration}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIi4uL1BhcGVycy9jc21yMjAwOF92YW5kZXJzdG9ybS5wZGbSFwsYGVdOUy5kYXRhTxEBrAAAAAABrAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OGGNzbXIyMDA4X3ZhbmRlcnN0b3JtLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmxajNuHIhAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADNuKphAAAAAQAMAAoODgAJZz8ACWc8AAIAQ01hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBjc21yMjAwOF92YW5kZXJzdG9ybS5wZGYAAA4AMgAYAGMAcwBtAHIAMgAwADAAOABfAHYAYQBuAGQAZQByAHMAdABvAHIAbQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAM1VzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2NzbXIyMDA4X3ZhbmRlcnN0b3JtLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCzALgAwAJwAnICdwKCAosCmQKdAqQCrQKyAr8CwgLUAtcC3AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALe}}

@inproceedings{shihab2011fse,
	Abstract = {The relationship between various software-related phenomena (e.g., code complexity) and post-release software defects has been thoroughly examined. However, to date these predictions have a limited adoption in practice. The most commonly cited reason is that the prediction identifies too much code to review without distinguishing the impact of these defects. Our aim is to address this drawback by focusing on high-impact defects for customers and practitioners. Customers are highly impacted by defects that break pre-existing functionality (breakage defects), whereas practitioners are caught off-guard by defects in files that had relatively few pre-release changes (surprise defects). The large commercial software system that we study already had an established concept of breakages as the highest-impact defects, however, the concept of surprises is novel and not as well established. We find that surprise defects are related to incomplete requirements and that the common assumption that a fix is caused by a previous change does not hold in this project. We then fit prediction models that are effective at identifying files containing breakages and surprises. The number of pre-release defects and file size are good indicators of breakages, whereas the number of co-changed files and the amount of time between the latest pre-release change and the release date are good indicators of surprises. Although our prediction models are effective at identifying files that have breakages and surprises, we learn that the prediction should also identify the nature or type of defects, with each type being specific enough to be easily identified and repaired.},
	Author = {Emad Shihab and Audris Mockus and Yasutaka Kamei and Bram Adams and Ahmed E. Hassan},
	Booktitle = {{Proc. of the 8th joint meeting of the European Software Engineering Conf. and the Symposium on the Foundations of Software Engineering (ESEC/FSE)}},
	Date-Added = {2013-05-13 02:12:30 +0000},
	Date-Modified = {2014-03-21 14:52:40 +0000},
	Pages = {300--310},
	Title = {{High-Impact Defects: A Study of Breakage and Surprise Defects}},
	Year = {2011}}

@inproceedings{guo2010icse,
	Abstract = {We performed an empirical study to characterize factors that affect which bugs get fixed in Windows Vista and Windows 7, focusing on factors related to bug report edits and relationships between people involved in handling the bug. We found that bugs reported by people with better reputations were more likely to get fixed, as were bugs handled by people on the same team and working in geographical proximity. We reinforce these quantitative results with survey feedback from 358 Microsoft employees who were involved in Windows bugs. Survey respondents also mentioned additional qualitative influences on bug fixing, such as the importance of seniority and interpersonal skills of the bug reporter. Informed by these findings, we built a statistical model to predict the probability that a new bug will be fixed (the first known one, to the best of our knowledge). We trained it on Windows Vista bugs and got a precision of 68% and recall of 64% when predicting Windows 7 bug fixes. Engineers could use such a model to prioritize bugs during triage, to estimate developer workloads, and to decide which bugs should be closed or migrated to future product versions.},
	Author = {Philip J. Guo and Thomas Zimmermann and Nachiappan Nagappan and Brendan Murphy},
	Booktitle = {{Proc. of the 32nd Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2013-05-12 23:07:43 +0000},
	Date-Modified = {2013-05-12 23:10:52 +0000},
	Pages = {495--504},
	Title = {{{Characterizing and Predicting Which Bugs Get Fixed: An Empirical Study of Microsoft Windows}}},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy9pY3NlMjAxMF9ndW8ucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhBpY3NlMjAxMF9ndW8ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg49zOAH8gAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzOBOQgAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTIwMTBfZ3VvLnBkZgAADgAiABAAaQBjAHMAZQAyADAAMQAwAF8AZwB1AG8ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pY3NlMjAxMF9ndW8ucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@book{continuous_delivery,
	Author = {Jez Humble and David Farley},
	Date-Added = {2013-05-09 01:51:43 +0000},
	Date-Modified = {2013-05-09 01:55:27 +0000},
	Publisher = {Addison-Wesley},
	Title = {{{Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation}}},
	Year = {2010}}

@article{mantyla2006emse,
	Abstract = {This paper presents the results of an empirical study on the subjective evaluation of code smells that identify poorly evolvable structures in software. We propose use of the term software evolvability to describe the ease of further developing a piece of software and outline the research area based on four different viewpoints. Furthermore, we describe the differences between human evaluations and automatic program analysis based on software evolvability metrics. The empirical component is based on a case study in a Finnish software product company, in which we studied two topics. First, we looked at the effect of the evaluator when subjectively evaluating the existence of smells in code modules. We found that the use of smells for code evaluation purposes can be difficult due to conflicting perceptions of different evaluators. However, the demographics of the evaluators partly explain the variation. Second, we applied selected source code metrics for identifying four smells and compared these results to the subjective evaluations. The metrics based on automatic program analysis and the human-based smell evaluations did not fully correlate. Based upon our results, we suggest that organizations should make decisions regarding software evolvability improvement based on a combination of subjective evaluations and code metrics. Due to the limitations of the study we also recognize the need for conducting more refined studies and experiments in the area of software evolvability.},
	Author = {Mika V. M\"{a}ntyl\"{a} and Casper Lassenius},
	Date-Added = {2013-05-02 15:39:07 +0000},
	Date-Modified = {2013-05-02 15:42:11 +0000},
	Journal = {Empirical Software Engineering (EMSE)},
	Number = {3},
	Pages = {395--431},
	Title = {Subjective evaluation of software evolvability using code smells: An empirical study},
	Volume = {11},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9lbXNlMjAwNl9tYW50eWxhLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UZW1zZTIwMDZfbWFudHlsYS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF3CnM2n/l4AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM2oNp4AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGVtc2UyMDA2X21hbnR5bGEucGRmAAAOACoAFABlAG0AcwBlADIAMAAwADYAXwBtAGEAbgB0AHkAbABhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvZW1zZTIwMDZfbWFudHlsYS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{nadi2013msr,
	Abstract = {The Linux kernel is one of the largest configurable open source software systems implementing static variability. In Linux, variability is scattered over three different artifacts: source code files, KCONFIG files, and Makefiles. Previous work detected inconsistencies between these artifacts that led to anoma- lies in the intended variability of Linux. We call these variability anomalies. However, there has been no work done to analyze how these variability anomalies are introduced in the first place, and how they get fixed. In this work, we provide an analysis of the causes and fixes of variability anomalies in Linux. We first perform an exploratory case study that uses an existing set of patches which solve variability anomalies to identify patterns for their causes. The observations we make from this dataset allow us to develop four research questions which we then answer in a confirmatory case study on the scope of the whole Linux kernel. We show that variability anomalies exist for several releases in the kernel before they get fixed, and that contrary to our initial suspicion, typos in feature names do not commonly cause these anomalies. Our results show that variability anomalies are often introduced through incomplete patches that change KCONFIG definitions without properly propagating these changes to the rest of the system. Anomalies are then commonly fixed through changes to the code rather than to KCONFIG files.},
	Author = {Sarah Nadi and Christian Dietrich and Reinhard Tartler and Richard C. Holt and Daniel Lohmann},
	Booktitle = {{Proc. of the 10th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2013-04-25 15:57:47 +0000},
	Date-Modified = {2013-04-25 16:00:09 +0000},
	Pages = {111--120},
	Title = {{Linux Variability Anomalies: What Causes Them and How Do They Get Fixed?}},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGS4uL1BhcGVycy9tc3IyMDEzbmFkaS5wZGbSFwsYGVdOUy5kYXRhTxEBhgAAAAABhgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OD21zcjIwMTNuYWRpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZDBXNnsQzAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADNnvxzAAAAAQAMAAoODgAJZz8ACWc8AAIAOk1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBtc3IyMDEzbmFkaS5wZGYADgAgAA8AbQBzAHIAMgAwADEAMwBuAGEAZABpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAqVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvbXNyMjAxM25hZGkucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AqgCvALcCQQJDAkgCUwJcAmoCbgJ1An4CgwKQApMCpQKoAq0AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACrw==}}

@article{kwan2011tse,
	Abstract = {Socio-technical congruence is an approach that measures coordination by examining the alignment between the technical dependencies and the social coordination in the project. We conduct a case study of coordination in the IBM Rational Team Concert project, which consists of 151 developers over seven geographically distributed sites, and expect that high congruence leads to a high probability of successful builds. We examine this relationship by applying two congruence measurements: an unweighted congruence measure from previous literature, and a weighted measure that overcomes limitations of the existing measure. We discover that there is a relationship between socio-technical congruence and build success probability, but only for certain build types, and observe that in some situations, higher congruence actually leads to lower build success rates. We also observe that a large proportion of zero-congruence builds are successful, and that socio-technical gaps in successful builds are larger than gaps in failed builds. Analysis of the social and technical aspects in IBM Rational Team Concert allows us to discuss the effects of congruence on build success. Our findings provide implications with respect to the limits of applicability of socio-technical congruence and suggest further improvements of socio-technical congruence to study coordination.},
	Author = {Irwin Kwan and Adrian Schr\"{o}ter and Daniela Damian},
	Date-Added = {2013-04-15 21:04:40 +0000},
	Date-Modified = {2013-04-15 21:08:48 +0000},
	Journal = {Transactions on Software Engineering (TSE)},
	Month = {May/June},
	Number = {3},
	Pages = {307--324},
	Title = {{{Does Socio-Technical Congruence Have An Effect on Software Build Success? A Study of Coordination in a Software Project?}}},
	Volume = {37},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy90c2UyMDExX2t3YW4ucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhB0c2UyMDExX2t3YW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATvwozZHLFgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzZIDVgAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdHNlMjAxMV9rd2FuLnBkZgAADgAiABAAdABzAGUAMgAwADEAMQBfAGsAdwBhAG4ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy90c2UyMDExX2t3YW4ucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@incollection{lampson2004cs,
	Annote = {For many years programmers have dreamed of building systems from a library of reusable software components together with a little new code. The closest we've come is Unix commands connected by pipes. This paper discusses the fundamental reasons why software components of this kind have not worked in the past and are unlikely to work in the future. Then it explains how the dream has come true in spite of this failure, and why most people haven't noticed.},
	Author = {Butler W. Lampson},
	Booktitle = {{{Computer Systems}}},
	Date-Added = {2013-04-12 15:31:56 +0000},
	Date-Modified = {2013-04-12 16:23:24 +0000},
	Editor = {Andrew Herbert and Karen Sp\"{a}rck Jones},
	Pages = {137--145},
	Publisher = {Springer},
	Series = {{Monographs in Computer Science}},
	Title = {{{Software Components: Only the Giants Survive}}},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9jczIwMDRfbGFtcHNvbi5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmNzMjAwNF9sYW1wc29uLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNSfbNjJvAAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADNjNQAAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBjczIwMDRfbGFtcHNvbi5wZGYAAA4AJgASAGMAcwAyADAAMAA0AF8AbABhAG0AcABzAG8AbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2NzMjAwNF9sYW1wc29uLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{briscoe2011jnc,
	Abstract = {We view Digital Ecosystems to be the digital counterparts of biological ecosystems. Here, we are concerned with the creation of these Digital Ecosystems, exploiting the self-organising properties of biological ecosystems to evolve high-level software applications. Therefore, we created the Digital Ecosystem, a novel optimisation technique inspired by biological ecosystems, where the optimisation works at two levels: a first optimisation, migration of agents which are distributed in a decentralised peer-to-peer network, operating continuously in time; this process feeds a second optimisation based on evolutionary computing that operates locally on single peers and is aimed at finding solutions to satisfy locally relevant constraints. The Digital Ecosystem was then measured experimentally through simulations, with measures originating from theoretical ecology, evaluating its likeness to biological ecosystems. This included its responsiveness to requests for applications from the user base, as a measure of the ecological succession (ecosystem maturity). Overall, we have advanced the understanding of Digital Ecosystems, creating Ecosystem-Oriented Architectures (EOA) where the word ecosystem is more than just a metaphor.},
	Author = {Gerard Briscoe and Suzanne Sadedin and Philippe De Wilde},
	Date-Added = {2013-03-26 14:18:25 +0000},
	Date-Modified = {2013-03-26 14:25:59 +0000},
	Journal = {Journal of Natural Computing},
	Number = {3},
	Pages = {1143--1194},
	Title = {{Digital Ecosystems: Ecosystem-Oriented Architectures}},
	Volume = {10},
	Year = {2011}}

@article{amos2007ijuc,
	Abstract = {Bacterial colonies are able to detect and react to changes in their environment. The distributed self-organisation of large numbers of bacteria into well-defined spatial structures is a form of computation that is deserving of further attention. In this paper we review how one particular collective response - bacterial chemotaxis - has been modelled in silico to generate novel algorithms. We describe how such models may be further extended for the purposes of directed pattern-formation in bacteria, and conclude with a discussion of some fundamental questions that we aim to address with this approach.},
	Author = {Martyn Amos and David A. Hodgson and Alan Gibbons},
	Journal = {Int'l Journal of Unconventional Computing},
	Pages = {199--210},
	Title = {{Bacterial Self-Organisation and Computation}},
	Volume = {3},
	Year = {2007}}

@article{langdon2008jnc,
	Abstract = {Evolved genetic programming trees contain many repeated code fragments. Size fair crossover limits bloat in automatic programming, preventing the evolution of recurring motifs. We examine these complex properties in detail using depth vs. size Catalan binary tree shape plots, subgraph and subtree matching, information entropy, sensitivity analysis, syntactic and semantic fitness correlations. Programs evolve in a self-similar fashion, akin to fractal random trees, with diffuse introns. Data mining frequent patterns reveals that as software is progressively improved a large proportion of it is exactly repeated subtrees as well as exactly repeated subgraphs. We relate this emergent phenomenon to building blocks in GP and suggest GP works by jumbling subtrees which already have high fitness on the whole problem to give incremental improvements and create complete solutions with multiple identical components of different importance.},
	Author = {William B. Langdon and Wolfgang Banzhaf},
	Journal = {Journal of Natural Computing},
	Number = {4},
	Pages = {589--613},
	Title = {{Repeated patterns in genetic programming}},
	Volume = {7},
	Year = {2008}}

@article{toffoli2005ijuc,
	Abstract = {Most work on computation deals with its structural aspects - what it is composed of, how the individual elements work in isolation and how they are connected to one another, how best they can be implemented by a physical systems, etc. - in sum, it concerns itself with a proximate account of computation's mechanisms. We argue that, though that kind of work is of course indispensable, computation cannot be understood or even properly defined if it is not placed in the context of the evolutionary feedback loop that brought it into being and continually monitors its adaptive fitness with respect to its ultimate goals within the organism that employs it.
Far from treating it as an optional, somewhat marginal activity, this viewpoint assigns to unconventional computing a fundamental role in the above evolutionary process, namely, to generate and support through their initial stages those variations - those experiments and explorations - that will then be evaluated by evolution's differential-survival engine.},
	Author = {Tommaso Toffoli},
	Date-Added = {2013-03-26 14:12:06 +0000},
	Date-Modified = {2013-03-26 14:15:12 +0000},
	Journal = {Int'l Journal of Unconventional Computing},
	Pages = {3--29},
	Title = {{Nothing Makes Sense in Computing Except in the Light of Evolution}},
	Volume = {1},
	Year = {2005}}

@article{liu2013jnc,
	Abstract = {Evolutionary multi-objective optimization (EMO) algorithms have been used in various real-world applications. However, most of the Pareto domination based multi-objective optimization evolutionary algorithms are not suitable for many-objective optimization. Recently, EMO algorithm incorporated decision maker's preferences became a new trend for solving many-objective problems and showed a good performance. In this paper, we first use a new selection scheme and an adaptive rank based clone scheme to exploit the dynamic information of the online antibody population. Moreover, a special differential evolution (DE) scheme is combined with directional information by selecting parents for the DE calculation according to the ranks of individuals within a population. So the dominated solutions can learn the information of the non-dominated ones by using directional information. The proposed method has been extensively compared with two-archive algorithm, light beam search non-dominated sorting genetic algorithm II and preference rank immune memory clone selection algorithm over several benchmark multi-objective optimization problems with from two to ten objectives. The experimental results indicate that the proposed algorithm achieves competitive results.},
	Author = {Ruochen Liu and Xiao Wang and Jing Liu and Lingfen Fang and Licheng Jiao},
	Journal = {Journal of Natural Computing},
	Number = {1},
	Pages = {109--132},
	Title = {{A preference multi-objective optimization based on adaptive rank clone and differential evolution}},
	Volume = {12},
	Year = {2008}}

@inproceedings{zimmermann2006msr,
	Abstract = {Files, classes, or methods have frequently been investigated in recent research on co-change. In this paper, we present a first study at the level of lines. To identify line changes across several versions, we define the annotation graph which captures how lines evolve over time. The annotation graph provides more fine-grained software evolution information such as life cycles of each line and related changes: "Whenever a developer changed line 1 of version.txt she also changed line 25 of Library.java."},
	Author = {Thomas Zimmermann and Sunghun Kim and Andreas Zeller and E. James Whitehead, Jr.},
	Booktitle = {{Proc. of the 3rd Int'l Workshop on Mining Software Repositories (MSR)}},
	Date-Added = {2012-12-13 22:39:43 +0000},
	Date-Modified = {2013-01-29 13:06:19 +0000},
	Pages = {72--75},
	Title = {{Mining Version Archives for Co-changed Lines}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9tc3IyMDA2X3ppbW1lcm1hbm4ucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZtc3IyMDA2X3ppbW1lcm1hbm4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7TzO/ElAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzPAK5AAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAbXNyMjAwNl96aW1tZXJtYW5uLnBkZgAADgAuABYAbQBzAHIAMgAwADAANgBfAHoAaQBtAG0AZQByAG0AYQBuAG4ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9tc3IyMDA2X3ppbW1lcm1hbm4ucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@book{logisticregression,
	Author = {D W Hosmer and S Lemeshow},
	Date-Added = {2012-12-06 19:44:55 +0000},
	Date-Modified = {2012-12-06 19:55:47 +0000},
	Edition = {2},
	Publisher = {John Wiley \& Sons},
	Title = {{Applied Logistic Regression}},
	Year = {2000}}

@misc{wikiextractor,
	Author = {Giuseppe Attardi and Antonio Fuschetto},
	Date-Added = {2012-11-22 19:54:42 +0000},
	Date-Modified = {2012-11-22 20:01:40 +0000},
	Howpublished = {"\url{http://medialab.di.unipi.it/wiki/Wikipedia_Extractor}"},
	Title = {{Wikipedia Extractor}},
	Year = {Last viewed: 22-Nov-2012}}

@inproceedings{mockus2009msr,
	Abstract = {The source code and its history represent the output and process of software development activities and are an invaluable resource for study and improvement of software development practice. While individual projects and groups of projects have been extensively analyzed, some fundamental questions, such as the spread of innovation or genealogy of the source code, can be answered only by considering the entire universe of publicly available source code and its history. We describe methods we developed over the last six years to gather, index, and update an approximation of such a universal repository for publicly accessible version control systems and for the source code inside a large corporation. While challenging, the task is achievable with limited resources. The bottlenecks in network bandwidth, processing, and disk access can be dealt with using inherent parallelism of the tasks and suitable tradeoffs between the amount of storage and computations, but a completely automated discovery of public version control systems may require enticing participation of the sampled projects. Such universal repository would allow studies of global properties and origins of the source code that are not possible through other means.},
	Author = {Audris Mockus},
	Booktitle = {{Proc. of the 6th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Added = {2012-10-31 17:50:53 +0000},
	Date-Modified = {2012-10-31 17:54:03 +0000},
	Pages = {11--20},
	Title = {{Amassing and indexing a large sample of version control systems: Towards the census of public source code history}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9tc3IyMDA5X21vY2t1cy5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEm1zcjIwMDlfbW9ja3VzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDtbMtt2gAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMtxXgAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBtc3IyMDA5X21vY2t1cy5wZGYAAA4AJgASAG0AcwByADIAMAAwADkAXwBtAG8AYwBrAHUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL21zcjIwMDlfbW9ja3VzLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{german2007wcre,
	Abstract = {The notion of functional or modular dependency is fundamental to understand the architecture and inner workings of any software system. In this paper, we propose to extend that notion to consider dependencies at a larger scale, between software applications (usually programs or libraries themselves). These dependencies, which we call inter-dependencies are of exceptional importance in free and open source software (FOSS), where it is common to build new applications by taking advantage of a rich and complex environment of programs and libraries whose functionality is available. To explore this concept, a methodology and visualization for studying inter-dependencies of a complex software system is presented and applied to one of the largest distributions of FOSS: Debian GNU/Linux.},
	Author = {Daniel M. German and Jesus M. Gonzalez-Barahona and Gregorio Robles},
	Booktitle = {{Proc of the 14th Working Conf. on Reverse Engineering (WCRE)}},
	Date-Added = {2012-10-09 12:37:16 +0000},
	Date-Modified = {2012-10-09 12:41:29 +0000},
	Pages = {140--149},
	Title = {{A Model to Understand the Building and Running Inter-Dependencies of Software}},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy93Y3JlMjAwN19nZXJtYW4ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN3Y3JlMjAwN19nZXJtYW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChUUzIYixAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzIZbBAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAd2NyZTIwMDdfZ2VybWFuLnBkZgAOACgAEwB3AGMAcgBlADIAMAAwADcAXwBnAGUAcgBtAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3djcmUyMDA3X2dlcm1hbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{nadi2012csmr,
	Abstract = {The Linux kernel is extensively specialized or configured so that it can be used for many purposes. This variability is implemented by means of three distinct artifacts: source code files, Kconfig (configuration) files, and Make files. Any inconsistencies between these three can lead to undesirable anomalies which can lead to increased maintenance efforts or decreased reliability. This paper extends published work that had found anomalies (dead and undead code blocks) by concentrating largely on code and Kconfig files. We detect further anomalies in the Linux kernel when we also consider the Make files. At the level of code blocks, our work exposes many additional anomalies -- more than we could study manually. We found that when we lift the level from code blocks to code files, the detected anomalies became easier to study and understand and thus more useful to the developer. By means of examples, we illustrate how the anomalies we detect can lead to undesired behavior. We show how, over time, developers tend to find and delete such anomalies. We suggest that automatic detection of such anomalies has the potential to decrease maintenance efforts and increase reliability.},
	Author = {Sarah Nadi and Ric Holt},
	Booktitle = {{Proc. of the 16th European Conf. on Software Maintenance and Reengineering (CSMR)}},
	Date-Added = {2012-10-09 12:31:28 +0000},
	Date-Modified = {2012-10-09 12:34:33 +0000},
	Pages = {107--116},
	Title = {{Mining Kbuild to Detect Variability Anomalies in Linux}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9jc21yMjAxMl9uYWRpLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RY3NtcjIwMTJfbmFkaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoVA8xj9+0AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxkMC0AAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGNzbXIyMDEyX25hZGkucGRmAA4AJAARAGMAcwBtAHIAMgAwADEAMgBfAG4AYQBkAGkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9jc21yMjAxMl9uYWRpLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@inproceedings{alkofahi2012icsm,
	Abstract = {Build code in a Makefile represents the build rules with the dependencies among the files, and how they must be built together to produce a software system. As software evolves, its build code evolves as well to accommodate necessary changes in the build process. As part of software maintenance, it is crucial to understand how the build code is changed (e.g. changes in build rules or dependencies), and to verify and validate the correctness of the build process with different build configurations. Due to Make's dynamic nature, understanding and managing the changes to Makefiles is not trivial.

In this paper, we introduce a set of semantic changes to build code in Makefiles. We also develop MkDiff, a tool to detect the changes to a Makefile at the semantic level. MkDiff uses symbolic dependency graphs (SDG) to find all possible concrete rules from a Makefile, and the dependencies among them. For two SDGs built from a Makefile at two versions, it first detects changed and unchanged nodes via its SDG matching algorithm. Then, from those results, it derives the semantic changes to the Makefile. Our empirical evaluation for MkDiff showed that it can accurately detect semantic changes in Makefiles.},
	Author = {Jafar M. Al-Kofahi and Hung Viet Nguyen and Anh Tuan Nguyen and Tung Thanh Nguyen and Tien N. Nguyen},
	Booktitle = {{Proc. of the 28th Int'l Conf. on Software Maintenance (ICSM)}},
	Date-Added = {2012-10-07 14:49:27 +0000},
	Date-Modified = {2012-12-16 17:13:08 +0000},
	Pages = {150--159},
	Title = {{Detecting Semantic Changes in Makefile Build Code}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pY3NtMjAxMl9uZ3V5ZW4ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpY3NtMjAxMl9uZ3V5ZW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7DzJcP+gAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzJdIOgAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzbTIwMTJfbmd1eWVuLnBkZgAOACgAEwBpAGMAcwBtADIAMAAxADIAXwBuAGcAdQB5AGUAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc20yMDEyX25ndXllbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{tamrawi2012icse,
	Abstract = {Build process is crucial in software development. However, the analysis support for build code is still limited. In this paper, we present SYMake, an infrastructure and tool for the analysis of build code in make. Due to the dynamic nature of make language, it is challenging to understand and maintain complex Makefiles. SYMake provides a symbolic evaluation algorithm that processes Makefiles and produces a symbolic dependency graph (SDG), which represents the build dependencies (i.e. rules) among files via commands. During the symbolic evaluation, for each resulting string value in an SDG that represents a part of a file name or a command in a rule, SYMake provides also an acyclic graph (called T-model) to represent its symbolic evaluation trace. We have used SYMake to develop algorithms and a tool 1) to detect several types of code smells and errors in Makefiles, and 2) to support build code refactoring, e.g. renaming a variable/target even if its name is fragmented and built from multiple substrings. Our empirical evaluation for SYMake's renaming on several real-world systems showed its high accuracy in entity renaming. Our controlled experiment showed that with SYMake, developers were able to understand Makefiles better and to detect more code smells as well as to perform refactoring more accurately.},
	Author = {Tamrawi, A. and Hoan Anh Nguyen and Hung Viet Nguyen and Nguyen, T.N.},
	Booktitle = {{Proc. of the 34th Int'l Conf. on Software Engineering (ICSE)}},
	Pages = {650--660},
	Title = {{Build Code Analysis with Symbolic Evaluation}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NlMjAxMl90YW1yYXdpLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzZTIwMTJfdGFtcmF3aS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOQMz3fiAAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMz3xHAAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc2UyMDEyX3RhbXJhd2kucGRmAAAOACoAFABpAGMAcwBlADIAMAAxADIAXwB0AGEAbQByAGEAdwBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMTJfdGFtcmF3aS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{cunningham1992,
	Abstract = {N/A},
	Author = {Ward Cunningham},
	Booktitle = {{Addendum to the Proc. of the 7th Conf. on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)}},
	Date-Added = {2012-09-19 15:09:45 +0000},
	Date-Modified = {2012-09-19 15:13:59 +0000},
	Pages = {29--30},
	Title = {{The WyCash Portfolio Management System}},
	Year = {1992},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIy4uL1BhcGVycy9vb3BzbGExOTkyX2N1bm5pbmdoYW0ucGRm0hcLGBlXTlMuZGF0YU8RAa4AAAAAAa4AAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhlvb3BzbGExOTkyX2N1bm5pbmdoYW0ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7bzH9ZXQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzH+RnQAAAAEADAAKDg4ACWc/AAlnPAACAERNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAb29wc2xhMTk5Ml9jdW5uaW5naGFtLnBkZgAOADQAGQBvAG8AcABzAGwAYQAxADkAOQAyAF8AYwB1AG4AbgBpAG4AZwBoAGEAbQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIANFVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL29vcHNsYTE5OTJfY3VubmluZ2hhbS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC0ALkAwQJzAnUCegKFAo4CnAKgAqcCsAK1AsICxQLXAtoC3wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALh}}

@inproceedings{morgenthaler2012mtd,
	Abstract = {With a large and rapidly changing codebase, Google software engineers are constantly paying interest on various forms of technical debt. Google engineers also make efforts to pay down that debt, whether through special Fixit days, or via dedicated teams, variously known as janitors, cultivators, or demolition experts. We describe several related efforts to measure and pay down technical debt found in Google's BUILD files and associated dead code. We address debt found in dependency specifications, unbuildable targets, and unnecessary command line flags. These efforts often expose other forms of technical debt that must first be managed.},
	Author = {J. David Morgenthaler and Misha Gridnev and Raluca Sauciuc and Sanjay Bhansali},
	Booktitle = {{Proc. of the 3rd Int'l Workshop on Managing Technical Debt (MTD)}},
	Date-Added = {2012-09-19 15:01:46 +0000},
	Date-Modified = {2014-08-10 22:26:45 +0000},
	Pages = {1--6},
	Title = {{Searching for Build Debt: Experiences Managing Technical Debt at Google}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJC4uL1BhcGVycy9pd210ZDIwMTJfbW9yZ2VudGhhbGVyLnBkZtIXCxgZV05TLmRhdGFPEQG0AAAAAAG0AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4aaXdtdGQyMDEyX21vcmdlbnRoYWxlci5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOysx/TP8AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMx/hT8AAAABAAwACg4OAAlnPwAJZzwAAgBFTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGl3bXRkMjAxMl9tb3JnZW50aGFsZXIucGRmAAAOADYAGgBpAHcAbQB0AGQAMgAwADEAMgBfAG0AbwByAGcAZQBuAHQAaABhAGwAZQByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA1VXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaXdtdGQyMDEyX21vcmdlbnRoYWxlci5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AtQC6AMICegJ8AoECjAKVAqMCpwKuArcCvALJAswC3gLhAuYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6A==}}

@misc{debian,
	Author = {{Debian Contributors}},
	Date-Added = {2012-09-17 18:35:48 +0000},
	Date-Modified = {2012-09-17 18:39:14 +0000},
	Howpublished = {\url{http://www.debian.org/}},
	Title = {{Debian - The Universal Operating System}},
	Year = {Last viewed: 17-Sep-2012}}

@misc{freebsd,
	Author = {{FreeBSD Contributors}},
	Date-Added = {2012-09-17 18:32:56 +0000},
	Date-Modified = {2012-09-17 18:39:26 +0000},
	Howpublished = {\url{http://www.freebsd.org/}},
	Title = {{The FreeBSD Project}},
	Year = {Last viewed: 17-Sep-2012}}

@article{mcilroy1978,
	Author = {Malcolm Douglas McIlroy and Elliot N. Pinson and B. A. Tague},
	Date-Added = {2012-09-14 20:07:33 +0000},
	Date-Modified = {2012-09-14 20:15:05 +0000},
	Journal = {The Bell System Technical Journal},
	Month = {July-August},
	Number = {6},
	Pages = {1899--1904},
	Title = {UNIX Time-Sharing System: Foreward},
	Volume = {57},
	Year = {1978},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9ic3RqMTk3OF9tY2lscm95LnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UYnN0ajE5NzhfbWNpbHJveS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOE8x5CF8AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMx5QJ8AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGJzdGoxOTc4X21jaWxyb3kucGRmAAAOACoAFABiAHMAdABqADEAOQA3ADgAXwBtAGMAaQBsAHIAbwB5AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvYnN0ajE5NzhfbWNpbHJveS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@article{lampson_hints,
	Abstract = {Experience with the design and implementation of a number of computer systems, and study of many other systems, has led to some general hints for system design which are described here. They are illustrated by a number of examples, ranging from hardware such as the Alto and the Dorado to applications programs such as Bravo and Star.},
	Author = {Butler W. Lampson},
	Date-Added = {2012-09-14 15:12:03 +0000},
	Date-Modified = {2012-09-14 15:14:29 +0000},
	Journal = {SIGOPS Operating System Review},
	Month = {October},
	Number = {5},
	Pages = {33-48},
	Title = {Hints for computer system design},
	Volume = {17},
	Year = {1983},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9zb3NyMTk4M19sYW1wc29uLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4Uc29zcjE5ODNfbGFtcHNvbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoVAMx4wicAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMx4+mcAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHNvc3IxOTgzX2xhbXBzb24ucGRmAAAOACoAFABzAG8AcwByADEAOQA4ADMAXwBsAGEAbQBwAHMAbwBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvc29zcjE5ODNfbGFtcHNvbi5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@article{barahona2009emse,
	Abstract = {Software evolution studies have traditionally focused on individual products. In this study we scale up the idea of software evolution by considering software compilations composed of a large quantity of independently developed products, engineered to work together. With the success of libre (free, open source) software, these compilations have become common in the form of `software distributions', which group hundreds or thousands of software applications and libraries into an integrated system. We have performed an exploratory case study on one of them, Debian GNU/Linux, finding some significant results. First, Debian has been doubling in size every 2 years, totalling about 300 million lines of code as of 2007. Second, the mean size of packages has remained stable over time. Third, the number of dependencies between packages has been growing quickly. Finally, while C is still by far the most commonly used programming language for applications, use of the C++, Java, and Python languages have all significantly increased. The study helps not only to understand the evolution of Debian, but also yields insights into the evolution of mature libre software systems in general.},
	Author = {Jesus M. Gonzalez-Barahona and Gregorio Robles and Martin Michlmayr and Juan Amor and Daniel German},
	Date-Added = {2012-09-14 12:48:17 +0000},
	Date-Modified = {2012-09-14 12:51:13 +0000},
	Journal = {Empirical Software Engineering (EMSE)},
	Number = {3},
	Pages = {262--285},
	Title = {Macro-level software evolution: a case study of a large software compilation},
	Volume = {14},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9lbXNlMjAwOV9iYXJhaG9uYS5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWVtc2UyMDA5X2JhcmFob25hLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKFQTMeJ7RAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMeNcRAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBlbXNlMjAwOV9iYXJhaG9uYS5wZGYADgAsABUAZQBtAHMAZQAyADAAMAA5AF8AYgBhAHIAYQBoAG8AbgBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvZW1zZTIwMDlfYmFyYWhvbmEucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{nadi2011wcre,
	Abstract = {The Linux kernel has long been an interesting subject of study in terms of its source code. Recently, it has also been studied in terms of its variability since the Linux kernel can be configured to include or omit certain features according to the user's selection. These features are defined in the Kconfig files included in the Linux kernel code. Several articles study both the source code and Kconfig files to ensure variability is correctly implemented and to detect anomalies. However, these studies ignore the Make files which are another important component that controls the variability of the Linux kernel. The Make files are responsible for specifying what actually gets compiled and built into the final kernel. With over 1,300 Make files, more than 35,000 source code files, and over 10,000 Kconfig features, inconsistencies and anomalies are inevitable. In this paper, we explore the Linux's Make files (Kbuild) to detect anomalies. We develop three rules to identify anomalies in the Make files. Using these rules, we detect 89 anomalies in the latest release of the Linux kernel (2.6.38.6). We also perform a longitudinal analysis to study the evolution of Kbuild anomalies over time, and the solutions implemented to correct them. Our results show that many of the anomalies we detect are eventually corrected in future releases. This work is a first attempt at exploring the consistency of the variability implemented in Kbuild with the rest of the kernel. Such work opens the door for automatic anomaly detection in build systems which can save developers time in the future.},
	Author = {Sarah Nadi and Ric Holt},
	Booktitle = {Proc. of the 18th Working Conf. on Reverse Engineering (WCRE)},
	Date-Added = {2012-09-10 21:44:03 +0000},
	Date-Modified = {2012-09-10 21:47:46 +0000},
	Pages = {315--324},
	Title = {{Make it or Break it: Mining Anomalies in Linux Kbuild}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy93Y3JlMjAxMV9uYWRpLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4Rd2NyZTIwMTFfbmFkaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoVGMxj99sAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxkMBsAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHdjcmUyMDExX25hZGkucGRmAA4AJAARAHcAYwByAGUAMgAwADEAMQBfAG4AYQBkAGkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy93Y3JlMjAxMV9uYWRpLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@misc{gnu_build_targets,
	Author = {Richard Stallman and Roland McGrath and Paul D. Smith and others},
	Date-Added = {2012-09-10 12:42:31 +0000},
	Date-Modified = {2012-09-10 12:49:49 +0000},
	Howpublished = {\url{http://www.gnu.org/software/make/manual/make.html\#Standard-Targets}},
	Title = {{Standard Targets for (GNU) Users}},
	Year = {Last viewed: 10-Sep-2012}}

@inproceedings{neitsch2012icsm,
	Abstract = {Building software from source is often viewed as a ``solved problem'' by software engineers, as there are many mature, well-known tools and techniques. However, anecdotal evidence suggests that these tools often do not effectively address the complexities of building multilanguage software. To investigate this apparent problem, we have performed a qualitative study on a set of five multilanguage open source software packages. Surprisingly, we found build system problems that prevented us from building many of these packages out-of-the-box. Our key finding is that there are commonalities among build problems that can be systematically addressed. In this paper, we describe the results of this exploratory study, identify a set of common build patterns and anti-patterns, and outline research directions for improving the build process. One such finding is that multilanguage packages avoid certain build problems by supporting compilation-free extension. As well, we find evidence that concerns from the application and implementation domains may ``leak'' into the build model, with both positive and negative effects on the resulting build systems.},
	Author = {Andrew Neitsch and Kenny Wong and Michael W. Godfrey},
	Booktitle = {{Proc. of the 28th Int'l Conf. on Software Maintenance}},
	Date-Added = {2012-09-07 01:40:03 +0000},
	Date-Modified = {2012-09-07 01:43:21 +0000},
	Pages = {140--149},
	Title = {{Build System Issues in Multilanguage Software}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NtMjAxMl9uZWl0c2NoLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzbTIwMTJfbmVpdHNjaC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOwsxuJ44AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxuX84AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc20yMDEyX25laXRzY2gucGRmAAAOACoAFABpAGMAcwBtADIAMAAxADIAXwBuAGUAaQB0AHMAYwBoAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTIwMTJfbmVpdHNjaC5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{wright2012icse,
	Abstract = {The release and deployment phase of the software development process is often overlooked as part of broader software engineering research. In this paper, we discuss early results from a set of multiple semi-structured interviews with practicing release engineers. Subjects for the interviews are drawn from a number of different commercial software development organizations, and our interviews focus on why release process faults and failures occur, how organizations recover from them, and how they can be predicted, avoided or prevented in the future. Along the way, the interviews provide insight into the state of release engineering today, and interesting relationships between software architecture and release processes.},
	Author = {Hyrum K. Wright and Dewayne E. Perry},
	Booktitle = {{Proc. of the 34th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Added = {2012-09-06 18:24:17 +0000},
	Date-Modified = {2012-09-06 18:27:39 +0000},
	Pages = {1281--1284},
	Title = {{Release Engineering Practices and Pitfalls}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pY3NlMjAxMl93cmlnaHQucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpY3NlMjAxMl93cmlnaHQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg5BzG5ccAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzG6UsAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTIwMTJfd3JpZ2h0LnBkZgAOACgAEwBpAGMAcwBlADIAMAAxADIAXwB3AHIAaQBnAGgAdAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2UyMDEyX3dyaWdodC5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{hochstein2011esem,
	Abstract = {All compiled software systems a build system: a set of scripts to invoke compilers and linkers to generate the final executable binaries. For scientific software, these build scripts can become extremely complex. Anecdotes suggest that scientific programmers have long been dissatisfied with the current software build toolchains. In this paper, we describe preliminary results from a case study of two projects to estimate the fraction of effort devoted to maintaining these scripts, which we refer to as the `build tax'. While estimates based on line counts are on the order of only 5%, estimates based on activity- related metrics suggest much higher values.},
	Author = {Lorin Hochstein and Yang Jiao},
	Booktitle = {Proc. of the 5th International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	Date-Added = {2012-08-29 21:04:09 +0000},
	Date-Modified = {2012-08-29 21:11:42 +0000},
	Pages = {384--387},
	Title = {The cost of the build tax in scientific software},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9lc2VtMjAxMV9ob2Noc3RlaW4ucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZlc2VtMjAxMV9ob2Noc3RlaW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4qzGP7ewAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzGQzuwAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZXNlbTIwMTFfaG9jaHN0ZWluLnBkZgAADgAuABYAZQBzAGUAbQAyADAAMQAxAF8AaABvAGMAaABzAHQAZQBpAG4ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9lc2VtMjAxMV9ob2Noc3RlaW4ucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@inproceedings{suvorov2012icsm,
	Abstract = {As the build system, i.e. the infrastructure that constructs executable deliverables out of source code and other resources, tries to catch up with the ever-evolving source code base, its size and already significant complexity keep on growing. Recently, this has forced some major software projects to migrate their build systems towards more powerful build system technologies. Since at all times software developers, testers and QA personnel rely on a functional build system to do their job, a build system migration is a risky and possibly costly undertaking, yet no methodology, nor best practices have been devised for it. In order to understand the build system migration process, we empirically studied two failed and two successful attempts of build system migration in two major open source projects, i.e. Linux and KDE, by mining source code repositories and tens of thousands of developer mailing list messages. The major contributions of this paper are: (a) isolating the phases of a common methodology for build system migrations, which is similar to the spiral model for source code development (multiple iterations of a waterfall process); (b) identifying four of the major challenges associated with this methodology: requirements gathering, communication issues, performance vs. complexity of build system code, and effective evaluation of build system prototypes; (c) detailed analysis of the first challenge, i.e., requirements gathering for the new build system, which revealed that the failed migrations did not gather requirements rigorously. Based on our findings, practitioners will be able to make more informed decisions about migrating their build system, potentially saving them time and money.},
	Author = {Roman Suvorov and Meiyappan Nagappan and Ahmed E. Hassan and Ying Zou and Bram Adams},
	Booktitle = {Proc. of the 28th Int'l Conf. on Software Maintenance (ICSM)},
	Date-Added = {2012-08-29 20:33:14 +0000},
	Date-Modified = {2012-08-29 20:42:34 +0000},
	Pages = {160--169},
	Title = {{An Empirical Study of Build System Migrations in Practice: Case Studies on KDE and the Linux Kernel}},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NtMjAxMl9zdXZvcm92LnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzbTIwMTJfc3V2b3Jvdi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOxMxj9cEAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxkLgEAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc20yMDEyX3N1dm9yb3YucGRmAAAOACoAFABpAGMAcwBtADIAMAAxADIAXwBzAHUAdgBvAHIAbwB2AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTIwMTJfc3V2b3Jvdi5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@techreport{epperly2011doe,
	Abstract = {The majority of scientific software is distributed as source code. As the number of library dependencies and supported platforms increases, so does the complexity of describing the rules for configuring and building software. In this project, we have performed an empirical study of the magnitude of the build problem by examining the development history of two DOE-funded scientific software projects. We have developed MixDown, a meta-build tool, to simplify the task of building applications that depend on multiple third- party libraries. The results of this research indicate that the effort that scientific programmers spend takes a significant fraction of the total development effort and that the use of MixDown can significantly simplify the task of building software with multiple dependencies.},
	Author = {Thomas G. W. Epperly and Lorin Hochstein},
	Date-Added = {2012-08-29 02:15:39 +0000},
	Date-Modified = {2012-10-09 12:35:34 +0000},
	Institution = {Lawrence Livermore National Laboratory},
	Number = {LLNL-TR-499074},
	Title = {Software Construction and Composition Tools for Petascale Computing},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9kb2UyMDExX2VwcGVybHkucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNkb2UyMDExX2VwcGVybHkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4izGP0ugAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzGQs+gAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZG9lMjAxMV9lcHBlcmx5LnBkZgAOACgAEwBkAG8AZQAyADAAMQAxAF8AZQBwAHAAZQByAGwAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2RvZTIwMTFfZXBwZXJseS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{belady1976,
	Abstract = {Discussed are observations made on the development of OS/360 and its subsequent enhancements and releases. Some modeling approaches to organizing these observations are also presented.},
	Author = {Laszlo A. Belady and Meir M. Lehman},
	Date-Modified = {2012-08-11 15:49:14 +0000},
	Journal = {IBM Systems Journal},
	Number = {3},
	Pages = {225--252},
	Publisher = {Citeseer},
	Title = {A Model of Large Program Development},
	Volume = {15},
	Year = {1976},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QKi4uL1BhcGVycy9pYm1zeXN0ZW1zam91cm5hbDE5NzZfYmVsYWR5LnBkZtIXCxgZV05TLmRhdGFPEQHKAAAAAAHKAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4faWJtc3lzdGVtc2pvdXJuYWwxOTc2I0EwRTMxLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOMcxL9twAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxMLxwAAAABAAwACg4OAAlnPwAJZzwAAgBKTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGlibXN5c3RlbXNqb3VybmFsMTk3NiNBMEUzMS5wZGYADgBCACAAaQBiAG0AcwB5AHMAdABlAG0AcwBqAG8AdQByAG4AYQBsADEAOQA3ADYAXwBiAGUAbABhAGQAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAO1VzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2libXN5c3RlbXNqb3VybmFsMTk3Nl9iZWxhZHkucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALsAwADIApYCmAKdAqgCsQK/AsMCygLTAtgC5QLoAvoC/QMCAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAwQ=}}

@article{lehman1980,
	Abstract = {The paper presents interpretations of some recently discovered laws of evolution and conservation in the largeprogram life cycle.

Program development and maintenance processes are managed and implemented by people; thus in the long term they could be expected to be unpredictable, dependant on the judgments, whims, and actions of programming process participants (e.g., managers, programmers, and product users). Yet, observed, measured, and modeled regularities suggest laws that are closer to biological laws or those of modern physics than to those currently formulated in other areas subject to human influence (e.g., economics and sociology).

After a brief discussion of the first four laws, to highlight underlying phenomena and natural attributes of the program evolution process, the paper concentrates on a fifth law and shows how, and why, this law represents a conservation phenomenon: the Conservation of Familiarity.},
	Author = {Meir M. Lehman},
	Date-Modified = {2012-08-12 16:54:00 +0000},
	Journal = {Journal of Systems and Software},
	Number = {3},
	Pages = {213--221},
	Title = {{On Understanding Laws, Evolution and Conservation in the Large Program Life Cycle}},
	Volume = {1},
	Year = {1980},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9qc3MxOTgwX2xlaG1hbi5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmpzczE5ODBfbGVobWFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDs7MTVhuAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTZCuAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBqc3MxOTgwX2xlaG1hbi5wZGYAAA4AJgASAGoAcwBzADEAOQA4ADAAXwBsAGUAaABtAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2pzczE5ODBfbGVobWFuLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{graves2000tse,
	Abstract = {This paper is an attempt to understand the processes by which software ages. We define code to be aged or decayed if its structure makes it unnecessarily difficult to understand or change and we measure the extent of decay by counting the number of faults in code in a period of time. Using change management data from a very large, long-lived software system, we explore the extent to which measurements from the change history are successful in predicting the distribution over modules of these incidences of faults. In general, process measures based on the change history are more useful in predicting fault rates than product metrics of the code: For instance, the number of times code has been changed is a better indication of how many faults it will contain than is its length. We also compare the fault rates of code of various ages, finding that if a module is, on the average, a year older than an otherwise similar module, the older module will have roughly a third fewer faults. Our most successful model measures the fault potential of a module as the sum of contributions from all of the times the module has been changed, with large, recent changes receiving the most weight.},
	Author = {Todd L. Graves and Alan F. Karr and J. S. Marron and Harvey Siy},
	Date-Modified = {2013-11-18 05:39:04 +0000},
	Journal = {Transactions on Software Engineering (TSE)},
	Number = {7},
	Pages = {653--661},
	Title = {{Predicting Fault Incidence using Software Change History}},
	Volume = {26},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy90c2UyMDAwX2dyYXZlcy5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEnRzZTIwMDBfZ3JhdmVzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKFRDMTV2/AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTZX/AAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgB0c2UyMDAwX2dyYXZlcy5wZGYAAA4AJgASAHQAcwBlADIAMAAwADAAXwBnAHIAYQB2AGUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3RzZTIwMDBfZ3JhdmVzLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{storey7manipulating,
	Abstract = {An effective approach to program understanding involves browsing, exploring, and creating views that document software structures at mulitiple levels of abstraction. While exploring the many relationships in a multi-million line legacy software system, one can easily lose context. One approach to alleviate this problem is to visualize these structures using fisheye-view techniques. This chapter introduces Simple Hierarchical Multi-Perspective (SHriMP) views. The SHriMP visualization technique has been incorporated into the Rigi reverse engineering system, greatly enhancing its capabilities for documenting software abstractions. The applicability and usefullness of SHriMP views are illustrated with selected softare visualization tasks.},
	Author = {Storey, M.A.D. and Muller, H.A. and Wong, K.},
	Date-Modified = {2012-08-11 18:44:00 +0000},
	Journal = {Software Visualisation (Series on Software Engineering and Knowledge Engineering)},
	Pages = {244--263},
	Title = {{Manipulating and documenting software structures}},
	Volume = {7},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9zb2Z0dmlzX3N0b3JleS5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEnNvZnR2aXNfc3RvcmV5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKFP3MTB+/AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTFf/AAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBzb2Z0dmlzX3N0b3JleS5wZGYAAA4AJgASAHMAbwBmAHQAdgBpAHMAXwBzAHQAbwByAGUAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3NvZnR2aXNfc3RvcmV5LnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{d2008analyzing,
	Abstract = {Software repositories such as versioning systems, defect tracking systems, and archived communication between project personnel are used to help manage the progress of software projects. Software practitioners and researchers increasingly recognize the potential benefit of mining this information to support the maintenance of software systems, improve software design or reuse, and empirically validate novel ideas and techniques. Research is now proceeding to uncover ways in which mining these repositories can help to understand software development, to support predictions about software development, and to plan various evolutionary aspects of software projects.
This chapter presents several analysis and visualization techniques to understand software evolution by exploiting the rich sources of artifacts that are available. Based on the data models that need to be developed to cover sources such as modification and bug reports we describe how to use a Release History Database for evolution analysis. For that we present approaches to analyze developer effort for particular software entities. Further we present change coupling analyses that can reveal hidden change dependencies among software entities. Finally, we show how to investigate architectural shortcomings over many releases and to identify trends in the evolution. Kiviat graphs can be effectively used to visualize such analysis results.},
	Author = {D'Ambros, M. and Gall, H. and Lanza, M. and Pinzger, M.},
	Date-Modified = {2012-08-11 15:55:40 +0000},
	Journal = {Software Evolution},
	Pages = {37--67},
	Publisher = {Springer},
	Title = {Analyzing software repositories to understand software evolution},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIi4uL1BhcGVycy9zb2Z0ZXZvbDIwMDhfZGFtYnJvcy5wZGbSFwsYGVdOUy5kYXRhTxEBrAAAAAABrAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OGHNvZnRldm9sMjAwOF9kYW1icm9zLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKFPzMS/iuAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTDDuAAAAAQAMAAoODgAJZz8ACWc8AAIAQ01hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBzb2Z0ZXZvbDIwMDhfZGFtYnJvcy5wZGYAAA4AMgAYAHMAbwBmAHQAZQB2AG8AbAAyADAAMAA4AF8AZABhAG0AYgByAG8AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAM1VzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3NvZnRldm9sMjAwOF9kYW1icm9zLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCzALgAwAJwAnICdwKCAosCmQKdAqQCrQKyAr8CwgLUAtcC3AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALe}}

@article{feldman1979,
	Abstract = {In a programming project, it is easy to lose track of which files need to be reprocessed or recompiled after a change is made in some part of the source. Make provides a simple mechanism for maintaining up-to-date versions of programs that result from many operations on a number of files. It is possible to tell Make the sequence of commands that create certain files, and the list of files that require other files to be current before the operations can be done. Whenever a change is made in any part of the program, the Make command will create the proper files simply, correctly, and with a minimum amount of effort.
The basic operation of Make is to find the name of a needed target in the description, ensure that all of the files on which it depends exist and are up to date, and then create the target if it has not been modified since its generators were. The description file really defines the graph of dependencies; Make does a depth-first search of this graph to determine what work is really necessary.
Make also provides a simple macro substitution facility and the ability to encapsulate commands in a single file for convenient administration.},
	Author = {Feldman, S.I.},
	Date-Modified = {2012-08-11 18:41:48 +0000},
	Journal = {Software - Practice and Experience},
	Number = {4},
	Pages = {255--265},
	Title = {Make - A Program for Maintaining Computer Programs},
	Volume = {9},
	Year = {1979},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIi4uL1BhcGVycy9zb2Z0d2FyZTE5NzlfZmVsZG1hbi5wZGbSFwsYGVdOUy5kYXRhTxEBrAAAAAABrAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OGHNvZnR3YXJlMTk3OV9mZWxkbWFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKFP7MTB98AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTFe8AAAAAQAMAAoODgAJZz8ACWc8AAIAQ01hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBzb2Z0d2FyZTE5NzlfZmVsZG1hbi5wZGYAAA4AMgAYAHMAbwBmAHQAdwBhAHIAZQAxADkANwA5AF8AZgBlAGwAZABtAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAM1VzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3NvZnR3YXJlMTk3OV9mZWxkbWFuLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCzALgAwAJwAnICdwKCAosCmQKdAqQCrQKyAr8CwgLUAtcC3AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALe}}

@article{adams2007eceasst,
	Author = {Bram Adams and Kris De Schutter and Herman Tromp and Wolfgang De Meuter},
	Date-Modified = {2012-08-29 23:38:33 +0000},
	Journal = {Electronic Communications of the ECEASST},
	Title = {{The Evolution of the Linux Build System}},
	Volume = {8},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9lY2Vhc3N0MjAwN19hZGFtcy5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWVjZWFzc3QyMDA3X2FkYW1zLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDiPMTYAQAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTbhQAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBlY2Vhc3N0MjAwN19hZGFtcy5wZGYADgAsABUAZQBjAGUAYQBzAHMAdAAyADAAMAA3AF8AYQBkAGEAbQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvZWNlYXNzdDIwMDdfYWRhbXMucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@article{robles2006,
	Abstract = {Current software systems contain increasingly more elements that have not usually been considered in software engineering research and studies. Source artifacts, understood as the source components needed to obtain a binary, ready to use version of a program, comprise in many systems more than just the elements written in a programming language (source code). Especially when we move apart from systems-programming and enter the realm of end-user applications, we find files for documentation, interface specifications, internationalization and localization modules and multimedia data. All of them are source artifacts in the sense that developers work directly with them, and that applications are built automatically using them as input. This paper discusses the differences and relationships between source code (usually written in a programming language) and these other files, by analyzing the KDE software versioning repository (with about 6,800,000 commits and 450,000 files). A comprehensive study of those files, and their evolution in time, is performed, looking for patterns and trying to infer from them the related behaviors of developers with different profiles, from where we conclude that studying those `other' source artifacts can provide a great deal of insight on a software system.},
	Address = {New York, NY, USA},
	Author = {Robles, Gregorio and Gonzalez-Barahona, Jesus M. and Merelo, Juan Julian},
	Date-Modified = {2012-08-11 16:01:04 +0000},
	Journal = {Journal of Systems and Software},
	Number = {9},
	Pages = {1233--1248},
	Publisher = {Elsevier Science Inc.},
	Title = {{Beyond Source Code: The Importance of Other Artifacts in Software Development (A Case Study)}},
	Volume = {79},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9qc3MyMDA2X3JvYmxlcy5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmpzczIwMDZfcm9ibGVzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDs/MS/psAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTDKsAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBqc3MyMDA2X3JvYmxlcy5wZGYAAA4AJgASAGoAcwBzADIAMAAwADYAXwByAG8AYgBsAGUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2pzczIwMDZfcm9ibGVzLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@article{deJonge2005tse,
	Abstract = {Reuse between software systems is often not optimal. An important reason is that while at the functional level well-known modularization principles are applied for structuring functionality in modules, this is not the case at the build level for structuring files in directories. This leads to a situation where files are entangled in directory hierarchies and build processes, making it hard to extract functionality and to make functionality suitable for reuse. Consequently, software may not come available for reuse at all, or only in rather large chunks of functionality, which may lead to extra software dependencies. In this paper, we propose to improve this situation by applying component-based software engineering (CBSE) principles to the build level. We discuss how existing software systems break CBSE principles, we introduce the notion of build-level components, and we define rules for developing such components. To make our techniques feasible, we define a reengineering process for semiautomatically transforming existing software systems into build-level components. Our techniques are demonstrated in two case studies where we decouple the source tree of Graphviz into 46 build-level components and analyze the source tree of Mozilla.},
	Author = {Merijn de Jonge},
	Date-Modified = {2012-08-11 16:06:54 +0000},
	Journal = {Transactions on Software Engineering (TSE)},
	Number = {7},
	Pages = {588--600},
	Title = {Build-Level Components},
	Volume = {31},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy90c2UyMDA1X2Rlam9uZ2UucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN0c2UyMDA1X2Rlam9uZ2UucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChURzEv+MAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzEw2cAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdHNlMjAwNV9kZWpvbmdlLnBkZgAOACgAEwB0AHMAZQAyADAAMAA1AF8AZABlAGoAbwBuAGcAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3RzZTIwMDVfZGVqb25nZS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{zaidman2008icst,
	Abstract = {Engineering software systems is a multidisciplinary activity, whereby a number of artifacts must be created --- and maintained --- synchronously. In this paper we investigate whether production code and the accompanying tests co-evolve by exploring a project's versioning system, code coverage reports and size-metrics. Our main aim for studying this co-evolution is to create awareness with developers and managers alike about the testing process that is followed. We explore the possibilities of our technique through two open source case studies and observe a number of different co-evolution scenarios. We evaluate our results both with the help of log-messages and the original developers of the software system.},
	Author = {Andy Zaidman and Bart Van Rompaey and Serge Demeyer and Arie van Deursen},
	Date-Modified = {2012-08-11 18:55:02 +0000},
	Journal = {Proc. of the 1st Int'l Conf. on Software Testing, Verification, and Validation (ICST)},
	Pages = {220-229},
	Title = {Mining Software Repositories to Study Co-Evolution of Production \& Test Code},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3N0MjAwOF96YWlkbWFuLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzdDIwMDhfemFpZG1hbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOxsxMIqoAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxMWuoAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc3QyMDA4X3phaWRtYW4ucGRmAAAOACoAFABpAGMAcwB0ADIAMAAwADgAXwB6AGEAaQBkAG0AYQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzdDIwMDhfemFpZG1hbi5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@article{antipatterns,
	Address = {New York, NY, USA},
	Author = {Koenig, Andrew},
	Book = {The patterns handbooks: techniques, strategies, and applications},
	Pages = {383--389},
	Publisher = {Cambridge University},
	Title = {Patterns and antipatterns},
	Year = {1998}}

@article{zimmermann2005tse,
	Abstract = {We apply data mining to version histories in order to guide programmers along related changes: ``Programmers who changed these functions also changed. . . ''. Given a set of existing changes, such rules (a) suggest and predict likely further changes, (b) show up item coupling that is indetectable by program analysis, and (c) prevent errors due to incomplete changes. After an initial change, our ROSE prototype can correctly predict 26% of further files to be changed---and 15% of the precise functions or variables. The topmost three suggestions contain a correct location with a likelihood of 64%.},
	Author = {Thomas Zimmermann and Peter Weissgerber and Stephan Diehl and Andreas Zeller},
	Date-Modified = {2012-08-12 02:26:40 +0000},
	Journal = {IEEE Transactions on Software Engineering},
	Month = {June},
	Number = {6},
	Pages = {429--445},
	Title = {Mining Version Histories to Guide Software Changes},
	Volume = {31},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9pY3NlMjAwNF96aW1tZXJtYW4ucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZpY3NlMjAwNF96aW1tZXJtYW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg43zEwlPgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzExdfgAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTIwMDRfemltbWVybWFuLnBkZgAADgAuABYAaQBjAHMAZQAyADAAMAA0AF8AegBpAG0AbQBlAHIAbQBhAG4ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pY3NlMjAwNF96aW1tZXJtYW4ucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@article{mcintosh2012emse,
	Abstract = {Build systems are responsible for transforming static source code artifacts into executable software. While build systems play such a crucial role in software development and maintenance, they have been largely ignored by software evolution researchers. However, a firm understanding of build system aging processes is needed in order to allow project managers to allocate personnel and resources to build system maintenance tasks effectively, and reduce the build maintenance overhead on regular development activities. In this paper, we study the evolution of build systems based on two popular Java build languages (i.e., ANT and Maven) from two perspectives: (1) a static perspective, where we examine the complexity of build system specifications using software metrics adopted from the source code domain; and (2) a dynamic perspective, where the complexity and coverage of representative build runs are measured. Case studies of the build systems of six open source build projects with a combined history of 172 releases show that build system and source code size are highly correlated, with source code restructurings often requiring build system restructurings. Furthermore, we find that Java build systems evolve dynamically in terms of duration and recursive depth of the directory hierarchy.},
	Author = {Shane McIntosh and Bram Adams and Ahmed E. Hassan},
	Date-Modified = {2012-09-19 02:02:36 +0000},
	Journal = {Empirical Software Engineering (EMSE)},
	Month = {August},
	Number = {4-5},
	Pages = {578--608},
	Title = {The evolution of {Java} build systems},
	Volume = {17},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9lbXNlMjAxMl9tY2ludG9zaC5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWVtc2UyMDEyX21jaW50b3NoLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDifMTW1XAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTaWXAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBlbXNlMjAxMl9tY2ludG9zaC5wZGYADgAsABUAZQBtAHMAZQAyADAAMQAyAF8AbQBjAGkAbgB0AG8AcwBoAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvZW1zZTIwMTJfbWNpbnRvc2gucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@article{vasilescu2012emse,
	Abstract = {Most empirical studies of open source software repositories focus on the analysis of isolated projects, or restrict themselves to the study of the relationships between technical artifacts. In contrast, we have carried out a case study that focuses on the actual contributors to software ecosystems, being collections of software projects that are maintained by the same community. To this aim, we defined a new series of workload and involvement metrics, as well as a novel approach for reporting the results of comparing multiple distributions through the use of T-graphs. We used these techniques to statistically study how workload and involvement of ecosystem contributors varies across projects and across activity types, and we explored to which extent projects and contributors specialise in particular activity types. Using Gnome as a case study we observed that, next to coding, the activities of localization, development documentation and building are prevalent throughout the ecosystem. We also observed notable differences between frequent and occasional contributors in terms of the activity types they are involved in and the number of projects they contribute to. Occasional contributors and contributors that are involved in many different projects tend to be more involved in the localization activity, while frequent contributors tend to be more involved in the coding activity in a limited number of projects.},
	Author = {Bogdan Vasilescu and Alexander Serebrenik and Mathieu Goeminne and Tom Mens},
	Journal = {Empirical Software Engineering (EMSE)},
	Note = {To appear},
	Title = {On the variation and specialisation of workload - A case study of the {GNOME} ecosystem community},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9lbXNlMjAxMl92YXNpbGVzY3UucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZlbXNlMjAxMl92YXNpbGVzY3UucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHE4QzOAJBgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzOBPVgAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZW1zZTIwMTJfdmFzaWxlc2N1LnBkZgAADgAuABYAZQBtAHMAZQAyADAAMQAyAF8AdgBhAHMAaQBsAGUAcwBjAHUALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9lbXNlMjAxMl92YXNpbGVzY3UucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@article{apr2009cacmKV,
	Abstract = {Comparing the potential benefits of system changes that help and the detriments of changes made for the sake of change.},
	Author = {George V. Neville-Neal},
	Date-Modified = {2012-08-11 16:20:20 +0000},
	Journal = {Communications of the ACM},
	Month = {April},
	Number = {4},
	Pages = {25--26},
	Publisher = {{ACM}},
	Title = {Kode Vicious: System Changes and Side Effects},
	Volume = {52},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIy4uL1BhcGVycy9jYWNtMjAwOV9uZXZpbGxlLW5laWwucGRm0hcLGBlXTlMuZGF0YU8RAa4AAAAAAa4AAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhljYWNtMjAwOV9uZXZpbGxlLW5laWwucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4UzEv+oQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzEw24QAAAAEADAAKDg4ACWc/AAlnPAACAERNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAY2FjbTIwMDlfbmV2aWxsZS1uZWlsLnBkZgAOADQAGQBjAGEAYwBtADIAMAAwADkAXwBuAGUAdgBpAGwAbABlAC0AbgBlAGkAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIANFVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2NhY20yMDA5X25ldmlsbGUtbmVpbC5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC0ALkAwQJzAnUCegKFAo4CnAKgAqcCsAK1AsICxQLXAtoC3wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALh}}

@article{adamsr1994,
	Abstract = {When a single software module in a large system is modified, a potentially large number of other modules may have to be recompiled. By reducing both the number of compilations and the amount of input processed by each compilation run, the turnaround time after changes can be reduced significantly. Potential time savings are measured in a medium-sized, industrial software project over a three-year period. The results indicate that a large number of compilations caused by traditional compilation unit dependencies may be redundant. On the available data, a mechanism that compares compiler output saves about 25 percent, smart recompilation saves 50 percent, and smartest recompilation may save up to 80 percent of compilation work. Furthermore, all compilation methods other than smartest recompilation process large amounts of unused environment data. In the project analyzed, the average environment symbols are actually used. Reading only the actually used symbols would reduce total compiler input by about 50 percent. Combining smart recompilation with a reduction in environment processing might double to triple perceived compilation speed and double linker speed, without sacrificing static type safety.},
	Author = {Rolf Adams and Walter Tichy and Annette Weinert},
	Date-Modified = {2013-05-09 02:48:13 +0000},
	Journal = {Transactions On Software Engineering and Methodology (TOSEM)},
	Month = {January},
	Number = {1},
	Pages = {3--28},
	Title = {{{The Cost of Selective Recompilation and Environment Processing}}},
	Volume = {3},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy90b3NlbTE5OTRfYWRhbXMucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN0b3NlbTE5OTRfYWRhbXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChUPzE1sHAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE2kXAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAdG9zZW0xOTk0X2FkYW1zLnBkZgAOACgAEwB0AG8AcwBlAG0AMQA5ADkANABfAGEAZABhAG0AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3Rvc2VtMTk5NF9hZGFtcy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{agrawal1993,
	Abstract = {We are given a large database of customer transactions. Each transaction consists of items purchased by a customer in a visit. We present an efficient algorithm that generates all
significant association rules between items in the database. The algorithm incorporates buffer management and novel estimation and pruning techniques. We also present results of applying this algorithm to sales data obtained from a large retailing company, which shows the effectiveness of the algorithm},
	Author = {Rakesh Agrawal and Tomasz Imielinski and Arun Swami},
	Date-Modified = {2012-08-11 18:49:23 +0000},
	Journal = {ACM SIGMOD Records},
	Number = {2},
	Pages = {207--216},
	Publisher = {ACM},
	Title = {{Mining Association Rules between Sets of Items in Large Databases}},
	Volume = {22},
	Year = {1993},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9zaWdtb2QxOTkzX2FncmF3YWwucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZzaWdtb2QxOTkzX2FncmF3YWwucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChT6zEwhOwAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzExZewAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAc2lnbW9kMTk5M19hZ3Jhd2FsLnBkZgAADgAuABYAcwBpAGcAbQBvAGQAMQA5ADkAMwBfAGEAZwByAGEAdwBhAGwALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9zaWdtb2QxOTkzX2FncmF3YWwucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@article{maint,
	Abstract = {Although many firms have rapidly and enthusiastically adopted the distributed architectures, many more are stuck with mainframe-based mission-critical systems that continue to isolate them from their partner, supplier, and customer systems. Indeed, IDC estimates there are more than 10,000 large IBM mainframe sites worldwide with 200 billion lines of legacy code still in use.},
	Author = {Len Erlikh},
	Date-Modified = {2012-08-11 18:37:50 +0000},
	Journal = {IT Professional},
	Month = {May/June},
	Number = {3},
	Pages = {17--23},
	Title = {{Leveraging Legacy System Dollars for E-Business}},
	Volume = {2},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJy4uL1BhcGVycy9pdHByb2Zlc3Npb25hbDIwMDBfZXJsaWtoLnBkZtIXCxgZV05TLmRhdGFPEQG+AAAAAAG+AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4daXRwcm9mZXNzaW9uYWwyMDAwX2VybGlraC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOycxMHnsAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxMVrsAAAABAAwACg4OAAlnPwAJZzwAAgBITWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGl0cHJvZmVzc2lvbmFsMjAwMF9lcmxpa2gucGRmAA4APAAdAGkAdABwAHIAbwBmAGUAcwBzAGkAbwBuAGEAbAAyADAAMAAwAF8AZQByAGwAaQBrAGgALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADhVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pdHByb2Zlc3Npb25hbDIwMDBfZXJsaWtoLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALgAvQDFAocCiQKOApkCogKwArQCuwLEAskC1gLZAusC7gLzAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAvU=}}

@article{beanplot,
	Author = {Peter Kampstra},
	Journal = {Journal of Statistical Software, Code Snippets},
	Number = {1},
	Pages = {1--9},
	Title = {Beanplot: A Boxplot Alternative for Visual Comparison of Distributions},
	Url = {http://www.jstatsoft.org/v28/c01/},
	Volume = {28},
	Year = {2008},
	Bdsk-Url-1 = {http://www.jstatsoft.org/v28/c01/}}

@inproceedings{capiluppi2007,
	Abstract = {We have analyzed evolution patterns over two and a half years for a system developed using eXtreme Programming. We find that the system shows a smooth pattern of growth overall, that (McCabe) code complexity is low, and that the relative amount of complexity control work (e.g. refactoring) is higher than in other systems we have studied. To interpret these results, we have drawn on qualitative data including the results of an observational study, records of progress and productivity, and comments on our findings from team members.},
	Author = {Andrea Capiluppi and Juan Fernandez-Ramil and Julian Higman and Helen C. Sharp and Neil Smith},
	Booktitle = {Proc. of the 29th Int'l Conf. on Software Engineering (ICSE)},
	Date-Modified = {2012-08-13 23:56:28 +0000},
	Pages = {511--518},
	Title = {An Empirical Study of the Evolution of an Agile-Developed Software System},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9pY3NlMjAwN19jYXBpbHVwcGkucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZpY3NlMjAwN19jYXBpbHVwcGkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg47zE8MRAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE9EhAAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTIwMDdfY2FwaWx1cHBpLnBkZgAADgAuABYAaQBjAHMAZQAyADAAMAA3AF8AYwBhAHAAaQBsAHUAcABwAGkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pY3NlMjAwN19jYXBpbHVwcGkucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@inproceedings{godfrey2000,
	Abstract = {Most studies of software evolution have been performed on systems developed within a single company using traditional management techniques. With the widespread availability of several large software systems that have been developed using an "open source" development approach, we now have a chance to examine these systems in detail, and see if their evolutionary narratives are significantly different from commercially developed systems. This paper summarizes our preliminary investigations into the evolution of the best known open source system: the Linux operating system kernel. Because Linux is large (over two million lines of code in the most recent version) and because its development model is not as tightly planned and managed as most industrial software processes, we had expected to find that Linux was growing more slowly as it got bigger and more complex. Instead, we have found that Linux has been growing at a super-linear rate for several years. In this paper, we explore the evolution of the Linux kernel both at the system level and within the major subsystems, and we discuss why we think Linux continues to exhibit such strong growth.},
	Author = {Godfrey, Michael W. and Tu, Qiang},
	Booktitle = {Proc. of the 8th Int'l Conf. on Software Maintenance (ICSM)},
	Date-Modified = {2013-05-27 17:37:00 +0000},
	Pages = {131--142},
	Title = {{Evolution in Open Source Software: A Case Study}},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NtMjAwMF9nb2RmcmV5LnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzbTIwMDBfZ29kZnJleS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOusxPEFEAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxPSJEAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc20yMDAwX2dvZGZyZXkucGRmAAAOACoAFABpAGMAcwBtADIAMAAwADAAXwBnAG8AZABmAHIAZQB5AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTIwMDBfZ29kZnJleS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@conference{lehman1997,
	Abstract = {The process of E-type software development and evolution has proven most difficult to improve, possibly due to the fact that the process is a multi-input, multi-output system involving feedback at many levels. This observation, first recorded in the early 1970s during an extended study of OS/360 evolution, was recently captured in a FEAST (Feedback, Evolution And Software Technology) hypothesis: a hypothesis being studied in on-going two-year project, FEAST/1. Preliminary conclusions based on a study of a financial transaction system-Logica's Fastwire (FW)-are outlined and compared with those reached during the earlier OS/360 study. The new analysis supports, or better does not contradict, the laws of software evolution, suggesting that the 1970s approach to metric analysis of software evolution is still relevant today. It is hoped that FEAST/1 will provide a foundation for mastering the feedback aspects of the software evolution process, opening up new paths for process modelling and improvement},
	Author = {Meir M. Lehman and Juan F. Ramil and Paul D. Wernick and Dewayne E. Perry and Wladyslaw M. Turski},
	Booktitle = {Proc. of the 4th Int'l Software Metrics Symposium (METRICS)},
	Date-Modified = {2012-08-12 20:35:20 +0000},
	Title = {Metrics and Laws of Software Evolution -- The Nineties View},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9tZXRyaWNzMTk5N19sZWhtYW4ucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZtZXRyaWNzMTk5N19sZWhtYW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7QzE2L3AAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE3EHAAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAbWV0cmljczE5OTdfbGVobWFuLnBkZgAADgAuABYAbQBlAHQAcgBpAGMAcwAxADkAOQA3AF8AbABlAGgAbQBhAG4ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9tZXRyaWNzMTk5N19sZWhtYW4ucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@conference{miller1998,
	Abstract = {For large UNIX projects, the traditional method of building the project is to use recursive make. On some projects, this results in build times which are unacceptably large, when all you want to do is change one file. In examining the source of the overly long build times, it became evident that a number of apparently unrelated problems combine to pro- duce the delay, but on analysis all have the same root cause.
This paper explores a number of problems regarding the use of recursive make, and shows that they are all symptoms of the same problem. Symptoms that the UNIX com- munity have long accepted as a fact of life, but which need not be endured any longer. These problems include recursive makes which take ``forever'' to work out that they need to do nothing, recursive makes which do too much, or too little, recursive makes which are overly sensitive to changes in the source code and require constant Makefile inter- vention to keep them working.
The resolution of these problems can be found by looking at what make does, from first principles, and then analyzing the effects of introducing recursive make to this activity. The analysis shows that the problem stems from the artificial partitioning of the build into separate subsets. This, in turn, leads to the symptoms described. To avoid the symptoms, it is only necessary to avoid the separation; to use a single make session to build the whole project, which is not quite the same as a single Makefile.
This conclusion runs counter to much accumulated folk wisdom in building large projects on UNIX. Some of the main objections raised by this folk wisdom are examined and shown to be unfounded. The results of actual use are far more encouraging, with routine development performance improvements significantly faster than intuition may indicate, and without the intuitvely expected compromise of modularity. The use of a whole project make is not as difficult to put into practice as it may at first appear.},
	Author = {Miller, P.A.},
	Booktitle = {Australian Unix User Group Newsletter},
	Date-Modified = {2012-08-12 20:39:17 +0000},
	Pages = {14--25},
	Title = {Recursive Make Considered Harmful},
	Volume = {19},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9hdXVnMTk5N19taWxsZXIucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNhdXVnMTk5N19taWxsZXIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4SyWoJVQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAyWpPpQAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAYXV1ZzE5OTdfbWlsbGVyLnBkZgAOACgAEwBhAHUAdQBnADEAOQA5ADcAXwBtAGkAbABsAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2F1dWcxOTk3X21pbGxlci5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@conference{robles2005,
	Abstract = {Software evolution research has recently focused on new development paradigms, studying whether laws found in more classic development environments also apply. Previous works have pointed out that at least some laws seem not to be valid for these new environments and even Lehman has labeled those (up to the moment few) cases as anomalies and has suggested that further research is needed to clarify this issue. In this line, we consider in this paper a large set of libre (free, open source) software systems featuring a large community of users and developers. In particular, we analyze a number of projects found in literature up to now, including the Linux kernel. For comparison, we include other libre software kernels from the BSD family, and for completeness we consider a wider range of libre software applications. In the case of Linux and the other operating system kernels we have studied growth patterns also at the subsystem level. We have observed in the studied sample that super-linearity occurs only exceptionally, that many of the systems follow a linear growth pattern and that smooth growth is not that common. These results differ from the ones found generally in classical software evolution studies. Other behaviors and patterns give also a hint that development in the libre software world could follow different laws than those known, at least in some cases.},
	Author = {Robles, G. and Amor, J.J. and Gonzalez-Barahona, J.M. and Herraiz, I.},
	Booktitle = {Proc. of the Int'l Workshop on Principles of Software Evolution (IWPSE)},
	Date-Modified = {2012-08-12 20:10:20 +0000},
	Pages = {165--174},
	Title = {Evolution and Growth in Large Libre Software Projects},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pd3BzZTIwMDVfcm9ibGVzLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaXdwc2UyMDA1X3JvYmxlcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOzMxNioEAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxNwsEAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGl3cHNlMjAwNV9yb2JsZXMucGRmAAAOACoAFABpAHcAcABzAGUAMgAwADAANQBfAHIAbwBiAGwAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaXdwc2UyMDA1X3JvYmxlcy5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{abreu2009how,
	Abstract = {Communication between developers plays a very central role in team-based software development for a variety of tasks such as coordinating development and maintenance activities, discussing requirements for better comprehension, assessing alternative solutions to complex problems, and like. However, the frequency of communication varies from time to time - sometimes developers exchange more messages with each other than at other times.

In this paper, we investigate whether developer communication has any bearing with software quality by examining the relationship between communication frequency and number of bugs injected into the software. The data used for this study is drawn from the bug database, version archive, and mailing lists of the JDT sub-project in ECLIPSE.

Our results show a statistically significant positive correlation between communication frequency and number of injected bugs in the software. We also noted that communication levels of key developers in the project do no correlate with number of injected bugs. Moreover, we show that defect prediction models can accommodate social aspects of the development process and potentially deliver more reliable results.},
	Author = {Abreu, Roberto and Premraj, Rahul},
	Booktitle = {Proc. of the joint int'l and annual ERCIM workshops on Principles of software evolution and software evolution workshops (IWPSE-Evol)},
	Date-Modified = {2012-08-28 19:09:54 +0000},
	Pages = {153--158},
	Publisher = {ACM},
	Title = {{How Developer Communication Frequency Relates to Bug Introducing Changes}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pd3BzZTIwMDlfYWJyZXUucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpd3BzZTIwMDlfYWJyZXUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7NzGKPIQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzGLHYQAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaXdwc2UyMDA5X2FicmV1LnBkZgAOACgAEwBpAHcAcABzAGUAMgAwADAAOQBfAGEAYgByAGUAdQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2l3cHNlMjAwOV9hYnJldS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{wolf2009icse,
	Abstract = {A critical factor in work group coordination, communication has been studied extensively. Yet, we are missing objective evidence of the relationship between successful coordination outcome and communication structures. Using data from IBM's Jazz{\texttrademark} project, we study communication structures of development teams with high coordination needs. We conceptualize coordination outcome by the result of their code integration build processes (successful or failed) and study team communication structures with social network measures. Our results indicate that developer communication plays an important role in the quality of software integrations. Although we found that no individual measure could indicate whether a build will fail or succeed, we leveraged the combination of communication structure measures into a predictive model that indicates whether an integration will fail. When used for five project teams, our predictive model yielded recall values between 55% and 75%, and precision values between 50% to 76%.},
	Address = {Washington, DC, USA},
	Author = {Wolf, Timo and Schr\"{o}ter, Adrian and Damian, Daniela and Nguyen, Thanh},
	Booktitle = {Proc. of the 31st Int'l Conf. on Software Engineering (ICSE)},
	Date-Modified = {2012-08-28 19:29:33 +0000},
	Pages = {1--11},
	Title = {Predicting build failures using social network analysis on developer communication},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9pY3NlMjAwOV93b2xmLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RaWNzZTIwMDlfd29sZi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOPMxilCcAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxizGcAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc2UyMDA5X3dvbGYucGRmAA4AJAARAGkAYwBzAGUAMgAwADAAOQBfAHcAbwBsAGYALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pY3NlMjAwOV93b2xmLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@inproceedings{tu2001icsm,
	Abstract = {Research and practice in the application of software architecture has reaffirmed the need to consider software systems from several distinct points of view. Previous work by P. Kruchten (1995) and C. Hofmeister et al. (2000) suggests that four or five points of view may be sufficient: the logical view (i.e., the domain object model), the (static) code view, the process/concurrency view, the deployment/execution view, plus scenarios and use-cases. We have found that some classes of software systems exhibit interesting and complex build-time properties that are not explicitly addressed by previous models. In this paper, we present the idea of build-time architectural views. We explain what they are, how to represent them, and how they fit into traditional models of software architecture. We present three case studies of software systems with interesting build-time architectural views, and show how modelling their build-time architectures can improve developer understanding of what the system is and how it is created. Finally, we introduce a new architectural style, the "code robot" that is often present in systems with interesting build-time views},
	Author = {Qiang Tu and Michael W. Godfrey},
	Booktitle = {{Proc. of the 17th Int'l Conf. on Software Maintenance (ICSM)}},
	Date-Modified = {2014-08-03 14:22:00 +0000},
	Pages = {398--407},
	Title = {{The Build-Time Software Architecture View}},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGS4uL1BhcGVycy9pY3NtMjAwMV90dS5wZGbSFwsYGVdOUy5kYXRhTxEBhgAAAAABhgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OD2ljc20yMDAxX3R1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDrvMTY1kAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTcWkAAAAAQAMAAoODgAJZz8ACWc8AAIAOk1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtMjAwMV90dS5wZGYADgAgAA8AaQBjAHMAbQAyADAAMAAxAF8AdAB1AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAqVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTIwMDFfdHUucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AqgCvALcCQQJDAkgCUwJcAmoCbgJ1An4CgwKQApMCpQKoAq0AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACrw==}}

@inproceedings{zadok2002,
	Abstract = {The GNU automatic software configuration tools, Au- toconf, Automake, and Libtool, were designed to help the portability of software to multiple platforms. Such autotools also help improve the readability of code and speed up the development cycle of software packages. In this paper we quantify how helpful such autotools are to the open-source software development process. We study several large packages that use these autotools and measure the complexity of their code. We show that total code size is not an accurate measure of code complex- ity for portability; two better metrics are the distribution of CPP conditionals in that code and the number of new special-purpose Autoconf macros that are written for the package.
We studied one package in detail---Am-utils, the Berkeley Automounter. As maintainers and developers of this package, we tracked its evolution over ten years. This package was ported to dozens of different platforms and in 1997 was converted to use GNU autotools. We show how this conversion (autotooling) resulted in a dra- matic reduction in code size by over 33%. In addition, the conversion helped speed code development of the Am-utils package by allowing new features and ports to be integrated easily: for the first year after the conversion to GNU autotools, the Am-utils package grew by over 70% in size, adding many new features, and all without increasing the average code complexity.},
	Author = {Zadok, Erez},
	Booktitle = {Proc. of the FREENIX Track on the USENIX Technical Conf.},
	Date-Modified = {2012-12-13 22:34:35 +0000},
	Pages = {287--297},
	Publisher = {USENIX Association},
	Title = {{Overhauling Amd for the '00s: A Case Study of GNU Autotools}},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy91c2VuaXgyMDAyX3phZG9rLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UdXNlbml4MjAwMl96YWRvay5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoVE8xikrUAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxiyvUAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHVzZW5peDIwMDJfemFkb2sucGRmAAAOACoAFAB1AHMAZQBuAGkAeAAyADAAMAAyAF8AegBhAGQAbwBrAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvdXNlbml4MjAwMl96YWRvay5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@conference{adams2007icsm,
	Abstract = {The build system forms an indispensable part of any software project. It needs to evolve in parallel with the source code in order to build, test and install the software. Unfortunately, little tool support exists to help maintainers gain insight into the build system, much less to refactor it. In this paper, we therefore present the design and implementation of a re(verse)-engineering framework for build systems named MAKAO. At its heart the framework makes the build's dependency graph available in a tangible way. Aside from visualisation, this enables powerful querying of all build-related data, as well as various filtering techniques to define views on the build architecture. If desired, all this gathered information can be put to use to write aspects for refactoring the build. Afterwards, validation rules can help in assessing failure or success. We applied our implementation on an industrial C system and the Linux 2.6.16.18 kernel, with good results.},
	Author = {Adams, B. and De Schutter, K. and Tromp, H. and Meuter, WD},
	Booktitle = {Proc. of the 23rd Int'l Conf. on Software Maintenance (ICSM)},
	Date-Modified = {2012-08-12 20:08:21 +0000},
	Location = {Paris, France},
	Pages = {114--123},
	Title = {Design Recovery and Maintenance of Build Systems},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9pY3NtMjAwN19hZGFtcy5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmljc20yMDA3X2FkYW1zLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDr/MTYUqAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTb1qAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtMjAwN19hZGFtcy5wZGYAAA4AJgASAGkAYwBzAG0AMgAwADAANwBfAGEAZABhAG0AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc20yMDA3X2FkYW1zLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{mccabemetric,
	Abstract = {This paper describes a graph-theoretic complexity measure and illustrates how it can be used to manage and control program complexity. The paper first explains how the graph theory concepts apply and gives an intuitive explanation of the graph concepts in programming terms. The control graphs of several actual FORTRAN programs are then presented to illustrate the correlation between intuitive complexity and the graph theoretic complexity. Several properties of the graph-theoretic complexity are then proved which show, for example, that complexity is independent of physical size (adding or subtracting functional statements leaves complexity unchanged) and complexity depends only on the decision structure of a program. The issue of using non-structured control flow is also discussed. A characterization of non-structured control graphs is given and a method of measuring the ``structuredness'' of a program is developed. The relationship between structure and reducibility is illustrated with several examples. The last section of the paper deals with a testing methodology used in conjunction with the complexity measure; a testing strategy is defined that dictates that a program can either admit of a certain minimal testing level or the program can be structurally reduced.},
	Author = {McCabe, Thomas J.},
	Booktitle = {Proc. of the 2nd Int'l Conf. on Software Engineering (ICSE)},
	Date-Modified = {2012-08-12 21:24:44 +0000},
	Location = {San Francisco, California, United States},
	Pages = {407},
	Title = {A Complexity Measure},
	Year = {1976}}

@inproceedings{deJonge2004icsr,
	Abstract = {Reuse between software systems is often not optimal. An important reason is that while at the functional level well-known modularization principles are applied for structuring functionality in modules, this is not the case at the build level for structuring files in directories. This leads to a situation where files are entangled in directory hierarchies and build processes, making it hard to extract functionality and to make functionality suitable for reuse. Consequently, software may not come available for reuse at all, or only in rather large chunks of functionality, which may lead to extra software dependencies. In this paper we propose to improve this situation by applying component-based software engineering (CBSE) principles to the build level. We discuss how existing software systems break CBSE principles, we introduce the notion of buildlevel components, and we define rules for developing such components. To make our techniques feasible, we define a reengineering process for semi-automatically transforming existing software systems into build-level components. Our techniques are demonstrated in a case study where we decouple the source tree of Graphviz into 47 build-level components},
	Author = {Merijn de Jonge},
	Booktitle = {Proc of the 8th Int'l Conf. on Software Reuse (ICSR)},
	Date-Modified = {2012-08-14 00:05:21 +0000},
	Editor = {J. Bosch and C. Krueger},
	Month = {July},
	Pages = {215--231},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Decoupling Source Trees into Build-Level Components},
	Volume = {3107},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NyMjAwNF9kZWpvbmdlLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzcjIwMDRfZGVqb25nZS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOxcxPDgMAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxPRkMAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc3IyMDA0X2Rlam9uZ2UucGRmAAAOACoAFABpAGMAcwByADIAMAAwADQAXwBkAGUAagBvAG4AZwBlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzcjIwMDRfZGVqb25nZS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{mcintosh2010msr,
	Abstract = {Build systems are responsible for transforming static source code artifacts into executable software. While build systems play such a crucial role in software development and maintenance, they have been largely ignored by software evolution researchers. With a firm understanding of build system aging processes, project managers could allocate personnel and resources to build system maintenance tasks more effectively, reducing the build maintenance overhead on regular development activities. In this paper, we study the evolution of ANT build systems from two perspectives: (1) a static perspective, where we examine the build system specifications using software metrics adopted from the source code domain; and (2) a dynamic perspective where representative sample build runs are conducted and their output logs are analyzed. Case studies of four open source ANT build systems with a combined history of 152 releases show that not only do ANT build systems evolve, but also that they need to react in an agile manner to changes in the source code.},
	Author = {Shane McIntosh and Bram Adams and Ahmed E. Hassan},
	Booktitle = {{Proc. of the 7th Working Conf. on Mining Software Repositories (MSR)}},
	Date-Modified = {2012-10-09 12:36:52 +0000},
	Pages = {42--51},
	Title = {{The Evolution of ANT Build Systems}},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9tc3IyMDEwX21jaW50b3NoLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UbXNyMjAxMF9tY2ludG9zaC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoO2cxilr8AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxizv8AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AG1zcjIwMTBfbWNpbnRvc2gucGRmAAAOACoAFABtAHMAcgAyADAAMQAwAF8AbQBjAGkAbgB0AG8AcwBoAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvbXNyMjAxMF9tY2ludG9zaC5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{nagappan2007esem,
	Abstract = {Commercial software development is a complex task that requires a thorough understanding of the architecture of the software system. We analyze the Windows Server 2003 operating system in order to assess the relationship between its software dependencies, churn measures and post-release failures. Our analysis indicates the ability of software dependencies and churn measures to be efficient predictors of post-release failures. Further, we investigate the relationship between the software dependencies and churn measures and their ability to assess failure-proneness probabilities at statistically significant levels.},
	Author = {Nagappan, Nachiappan and Ball, Thomas},
	Booktitle = {{Proc. of the 1st Int'l Symposium on Empirical Software Engineering and Measurement (ESEM)}},
	Date-Modified = {2013-12-06 14:09:39 +0000},
	Pages = {364--373},
	Title = {{Using Software Dependencies and Churn Metrics to Predict Field Failures: An Empirical Case Study}},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9lc2VtMjAwN19uYWdhcHBhbi5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWVzZW0yMDA3X25hZ2FwcGFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDinMYpudAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMYtPdAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBlc2VtMjAwN19uYWdhcHBhbi5wZGYADgAsABUAZQBzAGUAbQAyADAAMAA3AF8AbgBhAGcAYQBwAHAAYQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvZXNlbTIwMDdfbmFnYXBwYW4ucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{ibrahim2010msr,
	Abstract = {Development mailing lists play a central role in facilitating communication in open source projects. Since these lists frequently host design and project discussions, knowledgeable contribution to these discussion threads is essential to avoid miscommunication that might slow-down the progress of a project. However, given the sheer volume of emails on these lists, it is easy to miss important discussions. To find out how developers are able to deal with mailing list discussions, we study the main factors that encourage developers to contribute to the development mailing lists. We develop personalized models to automatically identify discussion threads that a developer would contribute to based on his previous contribution behavior. Case studies on development mailing lists of three open source projects (Apache, PostgreSQL and Python) show that the average accuracy of our models is 89--85% and that the models vary significantly between different developers.},
	Author = {Ibrahim, Walid and Bettenburg, Nicolas and Shihab, Emad and Adams, Bram and Hassan, Ahmed E.},
	Booktitle = {Proc. of the 7th working conf. on Mining Software Repositories (MSR)},
	Date-Modified = {2012-08-28 19:36:17 +0000},
	Location = {Cape Town, South Africa},
	Title = {Should {I} contribute to this discussion?},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9tc3IyMDEwX2licmFoaW0ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNtc3IyMDEwX2licmFoaW0ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7YzGKWLQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzGLObQAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAbXNyMjAxMF9pYnJhaGltLnBkZgAOACgAEwBtAHMAcgAyADAAMQAwAF8AaQBiAHIAYQBoAGkAbQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL21zcjIwMTBfaWJyYWhpbS5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{nagappan2005icse,
	Abstract = {Software systems evolve over time due to changes in requirements, optimization of code, fixes for security and reliability bugs etc. Code churn, which measures the changes made to a component over a period of time, quantifies the extent of this change. We present a technique for early prediction of system defect density using a set of relative code churn measures that relate the amount of churn to other variables such as component size and the temporal extent of churn. Using statistical regression models, we show that while absolute measures of code churn are poor predictors of defect density, our set of relative measures of code churn is highly predictive of defect density. A case study performed on Windows Server 2003 indicates the validity of the relative code churn measures as early indicators of system defect density. Furthermore, our code churn metric suite is able to discriminate between fault and not fault-prone binaries with an accuracy of 89.0 percent.},
	Author = {Nagappan, Nachiappan and Ball, Thomas},
	Booktitle = {{Proc. of the 27th Int'l Conf. on Software Engineering (ICSE)}},
	Date-Modified = {2013-11-18 05:41:12 +0000},
	Pages = {284--292},
	Title = {{Use of relative code churn measures to predict system defect density}},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NlMjAwNV9uYWdhcHBhbi5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc2UyMDA1X25hZ2FwcGFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDjnMYppUAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMYtKUAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAwNV9uYWdhcHBhbi5wZGYADgAsABUAaQBjAHMAZQAyADAAMAA1AF8AbgBhAGcAYQBwAHAAYQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMDVfbmFnYXBwYW4ucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{zimmerman2007,
	Abstract = {We have mapped defects from the bug database of Eclipse (one of the largest open-source projects) to source code locations. The resulting data set lists the number of pre- and post-release defects for every package and file in the Eclipse releases 2.0, 2.1, and 3.0. We additionally annotated the data with common complexity metrics. All data is publicly available and can serve as a benchmark for defect prediction models.},
	Author = {Zimmermann, Thomas and Premraj, Rahul and Zeller, Andreas},
	Booktitle = {Proc. of the 3rd Int'l Workshop on Predictor Models in Software Engineering (PROMISE)},
	Date-Modified = {2012-08-28 19:30:59 +0000},
	Pages = {9},
	Title = {Predicting Defects for Eclipse},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJC4uL1BhcGVycy9wcm9taXNlMjAwN196aW1tZXJtYW5uLnBkZtIXCxgZV05TLmRhdGFPEQG0AAAAAAG0AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4acHJvbWlzZTIwMDdfemltbWVybWFubi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoU98xilI0AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxizM0AAAABAAwACg4OAAlnPwAJZzwAAgBFTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHByb21pc2UyMDA3X3ppbW1lcm1hbm4ucGRmAAAOADYAGgBwAHIAbwBtAGkAcwBlADIAMAAwADcAXwB6AGkAbQBtAGUAcgBtAGEAbgBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA1VXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvcHJvbWlzZTIwMDdfemltbWVybWFubi5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AtQC6AMICegJ8AoECjAKVAqMCpwKuArcCvALJAswC3gLhAuYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6A==}}

@inproceedings{gall1998icsm,
	Abstract = {Code-based metrics such as coupling and cohesion are used to measure a system's structural complexity. But dealing with large systems-those consisting of several millions of lines- at the code level faces many problems. An alternative approach is to concentrate on the system's building blocks such as programs or modules as the unit of examination. We present an approach that uses information in a release history of a system to uncover logical dependencies and change patterns among modules. We have developed the approach by working with 20 releases of a large Telecommunications Switching System. We use release information such as version numbers of programs, modules, and subsystems together with change reports to discover common change behavior (i.e. change patterns) of modules. Our approach identifies logical coupling among modules in such a way that potential structural shortcomings can be identified and further examined, pointing to restructuring or reengineering opportunities.},
	Author = {Gall, Harald and Hajek, Karin and Jazayeri, Mehdi},
	Booktitle = {Proc. of the 14th Int'l Conf. on Software Maintenance (ICSM)},
	Date-Modified = {2012-12-12 13:51:09 +0000},
	Pages = {190--198},
	Title = {Detection of Logical Coupling Based on Product Release History},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9pY3NtMTk5OF9nYWxsLnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RaWNzbTE5OThfZ2FsbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOucxPDzUAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxPR3UAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc20xOTk4X2dhbGwucGRmAA4AJAARAGkAYwBzAG0AMQA5ADkAOABfAGcAYQBsAGwALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pY3NtMTk5OF9nYWxsLnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@conference{kiczales97,
	Abstract = {We have found many programming problems for which neither procedural nor object-oriented programming techniques are sufficient to clearly capture some of the important design decisions the program must implement. This forces the implementation of those design decisions to be scattered throughout the code, resulting in ``tangled'' code that is excessively difficult to develop and maintain.  We present an analysis of why certain design decisions have been so difficult to clearly capture in actual code.  We call the properties these decisions address aspects, and show that the reason they have been hard to capture is that they  cross-cut the system's basic functionality. We present the basis for a new programming technique, called aspectoriented programming, that makes it possible to clearly express programs involving such aspects, including appropriate isolation, composition and reuse of the aspect code.  The discussion is rooted in systems we have built using aspect-oriented programming},
	Author = {Kiczales, G. and Lamping, J. and Mendhekar, A. and Maeda, C. and Lopes, C. and Loingtier, J. and Irwin, J.},
	Booktitle = {Proc. of the 11th European Conference on Object-Oriented Programming (ECOOP)},
	Date-Modified = {2012-08-12 20:05:40 +0000},
	Title = {Aspect-oriented programming},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9lY29vcDE5OTdfa2ljemFsZXMucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZlY29vcDE5OTdfa2ljemFsZXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4lzE2DtQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE279QAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZWNvb3AxOTk3X2tpY3phbGVzLnBkZgAADgAuABYAZQBjAG8AbwBwADEAOQA5ADcAXwBrAGkAYwB6AGEAbABlAHMALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9lY29vcDE5OTdfa2ljemFsZXMucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@inproceedings{hassan2006ase,
	Abstract = {Large teams of practitioners (developers, testers, etc.) usually work in parallel on the same code base. A major concern when working in parallel is the introduction of integration bugs in the latest shared code. These latent bugs are likely to slow down the project unless they are discovered as soon as possible. Many companies have adopted daily or weekly processes which build the latest source code and certify it by executing simple manual smoke/sanity tests or extensive automated integration test suites. Other members of a team can then use the certified build to develop new features or to perform additional analysis, such as performance or usability testing. For large projects the certification process may take a few days. This long certification process forces team members to either use outdated or uncertified (possibly buggy) versions of the code. In this paper, we create decision trees to predict ahead of time the certification result of a build. By accurately predicting the outcome of the certification process, members of large software teams can work more effectively in parallel. Members can start using the latest code without waiting for the certification process to be completed. To perform our study, we mine historical information (code changes and certification results) for a large software project which is being developed at the IBM Toronto Labs. Our study shows that using a combination of project attributes (such as the number of modified subsystems in a build and certification results of previous builds), we can correctly predict 69% of the time that a build will fail certification. We can as well correctly predict 95% of the time if a build will pass certification},
	Author = {Ahmed E. Hassan and Ken Zhang},
	Booktitle = {Proc. of the 21st Int'l Conf. on Automated Software Engineering (ASE)},
	Date-Modified = {2012-08-28 19:58:00 +0000},
	Pages = {189--198},
	Title = {{Using Decision Trees to Predict the Certification Result of a Build}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9hc2UyMDA2X2hhc3Nhbi5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmFzZTIwMDZfaGFzc2FuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDhDMYpr2AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMYtM2AAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBhc2UyMDA2X2hhc3Nhbi5wZGYAAA4AJgASAGEAcwBlADIAMAAwADYAXwBoAGEAcwBzAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2FzZTIwMDZfaGFzc2FuLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{barandela03,
	Abstract = {The problem of imbalanced training sets in supervised pattern recognition methods is receiving growing attention. Imbalanced training sample means that one class is represented by a large number of examples while the other is represented by only a few. It has been observed that this situation, which arises in several practical situations, may produce an important deterioration of the classification accuracy, in particular with patterns belonging to the less represented classes. In the present paper, we introduce a new approach to design an instance-based classifier in such imbalanced environments.},
	Author = {Barandela, R. and S{\'a}nchez, JS and Garc{\'\i}a, V. and Ferri, FJ},
	Booktitle = {Proc. of the 1st Iberian Conf. on Pattern Recognition and Image Analysis (IbPRIA)},
	Date-Modified = {2012-08-28 19:18:22 +0000},
	Title = {{Learning from Imbalanced sets through resampling and weighting}},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIi4uL1BhcGVycy9pYnByaWEyMDAzX2JhcmFuZGVsYS5wZGbSFwsYGVdOUy5kYXRhTxEBrAAAAAABrAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OGGlicHJpYTIwMDNfYmFyYW5kZWxhLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDjLMYpGMAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMYsnMAAAAAQAMAAoODgAJZz8ACWc8AAIAQ01hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpYnByaWEyMDAzX2JhcmFuZGVsYS5wZGYAAA4AMgAYAGkAYgBwAHIAaQBhADIAMAAwADMAXwBiAGEAcgBhAG4AZABlAGwAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAM1VzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2licHJpYTIwMDNfYmFyYW5kZWxhLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCzALgAwAJwAnICdwKCAosCmQKdAqQCrQKyAr8CwgLUAtcC3AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALe}}

@inproceedings{estabrooks2001ida,
	Abstract = {Re-Sampling methods are some of the different types of approaches proposed to deal with the class-imbalance problem. Although such approaches are very simple, tuning them most effectively is not an easy task. In particular, it is unclear whether oversampling is more effective than undersampling and which oversampling or undersampling rate should be used. This paper presents an experimental study of these questions and concludes that combining different expressions of the resampling approach in a mixture of experts framework is an effective solution to the tuning problem. The proposed combination scheme is evaluated on a subset of the REUTERS-21578 text collection (the 10 top categories) and is shown to be very effective when the data is drastically imbalanced.},
	Author = {Estabrooks, A. and Japkowicz, N.},
	Booktitle = {Proc. of the 4th Int. Conf. on Advances in Intelligent Data Analysis (IDA)},
	Date-Modified = {2012-08-13 23:47:36 +0000},
	Pages = {34--43},
	Title = {A Mixture-of-Experts Framework for Learning from Imbalanced Data Sets},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9pZGEyMDAxX2VzdGFicm9va3MucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZpZGEyMDAxX2VzdGFicm9va3MucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7HzE8LKQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE9DaQAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWRhMjAwMV9lc3RhYnJvb2tzLnBkZgAADgAuABYAaQBkAGEAMgAwADAAMQBfAGUAcwB0AGEAYgByAG8AbwBrAHMALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9pZGEyMDAxX2VzdGFicm9va3MucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@inproceedings{bird2009msr,
	Abstract = {We are now witnessing the rapid growth of decentralized source code management (DSCM) systems, in which every developer has her own repository. DSCMs facilitate a style of collaboration in which work output can flow sideways (and privately) between collaborators, rather than always up and down (and publicly) via a central repository. Decentralization comes with both the promise of new data and the peril of its misinterpretation. We focus on git, a very popular DSCM used in high-profile projects. Decentralization, and other features of git, such as automatically recorded contributor attribution, lead to richer content histories, giving rise to new questions such as ``How do contributions flow between developers to the official project repository?'' However, there are pitfalls. Commits may be reordered, deleted, or edited as they move between repositories. The semantics of terms common to SCMs and DSCMs sometimes differ markedly, potentially creating confusion. For example, a commit is immediately visible to all developers in centralized SCMs, but not in DSCMs. Our goal is to help researchers interested in DSCMs avoid these and other perils when mining and analyzing git data.},
	Author = {Christian Bird and Peter C. Rigby and Earl T. Barr and David J. Hamilton and Daniel M. German and Prem Devanbu},
	Booktitle = {Proc. of the 6th Working Conf. on Mining Software Repositories (MSR)},
	Date-Modified = {2012-08-28 19:51:25 +0000},
	Title = {{The Promises and Perils of Mining Git}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy9tc3IyMDA5X2JpcmQucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhBtc3IyMDA5X2JpcmQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7UzGKZZAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzGLRpAAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAbXNyMjAwOV9iaXJkLnBkZgAADgAiABAAbQBzAHIAMgAwADAAOQBfAGIAaQByAGQALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9tc3IyMDA5X2JpcmQucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@conference{kohavi95,
	Abstract = {We review accuracy estimation methods and compare the two most common methods crossvalidation and bootstrap. Recent experimental results on artificial data and theoretical re cults in restricted settings have shown that for selecting a good classifier from a set of classifiers (model selection), ten-fold cross-validation may be better than the more expensive leaveone-out cross-validation. We report on a largescale experiment--over half a million runs of C4.5 and a Naive-Bayes algorithm--to estimate the effects of different parameters on these algrithms on real-world datasets. For crossvalidation we vary the number of folds and whether the folds are stratified or not, for bootstrap, we vary the number of bootstrap samples. Our results indicate that for real-word datasets similar to ours, The best method to use for model selection is ten fold stratified cross validation even if computation power allows using more folds.},
	Author = {Kohavi, R.},
	Booktitle = {Int'l Joint Conf. on Artificial Intelligence (IJCAI)},
	Date-Modified = {2012-08-12 20:00:11 +0000},
	Pages = {1137--1145},
	Title = {A Study of Cross-Validation and Bootstrap for Accuracy Estimation and Model Selection},
	Volume = {14},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pamNhaTE5OTVfa29oYXZpLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWpjYWkxOTk1X2tvaGF2aS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOyMxNg14AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxNu54AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGlqY2FpMTk5NV9rb2hhdmkucGRmAAAOACoAFABpAGoAYwBhAGkAMQA5ADkANQBfAGsAbwBoAGEAdgBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWpjYWkxOTk1X2tvaGF2aS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@conference{herraiz2006csmr,
	Abstract = {There are some concerns in the research community about the convenience of using low-level metrics (such as SLOC, source lines of code) for characterizing the evolution of software, instead of the more traditional higher lever metrics (such as the number of modules or files). This issue has been raised in particular after some studies that suggest that libre (free, open source) software evolves differently than 'traditional' software, and therefore it does not conform to Lehman's laws of software evolution. Since those studies on libre software evolution use SLOCs as the base metric, while Lehman's and other traditional studies use modules or files, it is difficult to compare both cases. To overcome this difficulty, and to explore the differences between SLOC and files/modules counts in libre software projects, we have selected a large sample of programs and have calculated both size metrics over time. Our study shows that in those cases the evolution patterns in both cases (counting SLOCs or files) is the same, and that some patterns not conforming to Lehman's laws are indeed apparent.},
	Author = {Herraiz, I. and Robles, G. and Gonzalez-Barahona, J.M. and Capiluppi, A. and Ramil, J.F.},
	Booktitle = {{Proc. of the 10th European Conf. on Software Maintenance and Reengineering (CSMR)}},
	Date-Modified = {2014-01-02 19:10:10 +0000},
	Pages = {213--221},
	Title = {{Comparison between SLOCs and number of files as size metrics for software evolution analysis}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9jc21yMjAwNl9oZXJyYWl6LnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UY3NtcjIwMDZfaGVycmFpei5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOHMxNhI4AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxNvM4AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGNzbXIyMDA2X2hlcnJhaXoucGRmAAAOACoAFABjAHMAbQByADIAMAAwADYAXwBoAGUAcgByAGEAaQB6AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvY3NtcjIwMDZfaGVycmFpei5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{swanson1976,
	Abstract = {The area of software maintenance has been described by one author as an ``iceberg.'' (EDP Analyzer, 1972) Much goes on here that does not currently meet the eye. In part, this is the consequence of measurement difficulties. Practitioners and researchers can benefit from an understanding of the ``dimensionality'' of the maintenance problem. Some measures are suggested for coming to grips with this dimensionality, and problems of utilization associated with these measures are explored.},
	Author = {Swanson, E. B.},
	Booktitle = {{Proc. of the 2nd Int'l Conf. on Software Engineering (ICSE)}},
	Date-Modified = {2012-08-28 19:38:49 +0000},
	Title = {{The Dimensions of Maintenance}},
	Year = {1976},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NlMTk3Nl9zd2Fuc29uLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzZTE5NzZfc3dhbnNvbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoONMxilmQAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxizqQAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc2UxOTc2X3N3YW5zb24ucGRmAAAOACoAFABpAGMAcwBlADEAOQA3ADYAXwBzAHcAYQBuAHMAbwBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTE5NzZfc3dhbnNvbi5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{robles2006msr,
	Abstract = {With the success of libre (free, open source) software, a new type of software compilation has become increasingly common. Such compilations, often referred to as 'distributions', group hundreds, if not thousands, of software applications and libraries written by independent parties into an integrated system. Software compilations raise a number of questions that have not been targeted so far by software evolution, which usually focuses on the evolution of single applications. Undoubtedly, the challenges that software compilations face differ from those found in single software applications. Nevertheless, it can be assumed that both, the evolution of applications and that of software compilations, have similarities and dependencies.In this sense, we identify a dichotomy, common to that in economics, of software evolution in the small (micro-evolution) and in the large (macro-evolution). The goal of this paper is to study the evolution of a large software compilation, mining the publicly available repository of a well-known Linux distribution, Debian. We will therefore investigate changes related to hundreds of millions of lines of code over seven years. The aspects that will be covered in this paper are size (in terms of number of packages and of number of lines of code), use of programming languages, maintenance of packages and file sizes.},
	Author = {Robles, G. and Gonzalez-Barahona, J. M. and Michlmayr, M. and Amor, J. J.},
	Booktitle = {Proc. of the 3rd Int'l Workshop on Mining Software Repositories (MSR)},
	Date-Modified = {2012-09-14 15:32:05 +0000},
	Title = {{Mining Large Software Compilations over Time: Another Perspective of Software Evolution}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9tc3IyMDA2X3JvYmxlcy5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEm1zcjIwMDZfcm9ibGVzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDtLMYpHmAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMYsomAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBtc3IyMDA2X3JvYmxlcy5wZGYAAA4AJgASAG0AcwByADIAMAAwADYAXwByAG8AYgBsAGUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL21zcjIwMDZfcm9ibGVzLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{yu2005icsm,
	Abstract = {Large-scale legacy programs take long time to compile, thereby hampering productivity. This paper presents algorithms that reduce compilation time by analyzing syntactic dependencies in fine-grain program units, and by removing redundancies as well as false dependencies. These algorithms are combined with parallel compilation techniques (compiler farms, compiler caches), to further reduce build time. We demonstrate through experiments their effectiveness in achieving significant speedup for both fresh and incremental builds.},
	Author = {Yijun Yu and Homayoun Dayani-Fard and John Mylopoulos and Periklis Andritsos},
	Booktitle = {Proc. of the 21st Int'l Conf. on Software Maintenance (ICSM)},
	Date-Modified = {2012-08-28 19:33:08 +0000},
	Pages = {59--68},
	Title = {{Reducing Build Time Through Precompilations for Evolving Large Software}},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGS4uL1BhcGVycy9pY3NtMjAwNV95dS5wZGbSFwsYGVdOUy5kYXRhTxEBhgAAAAABhgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OD2ljc20yMDA1X3l1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDr7MYpTlAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMYs0lAAAAAQAMAAoODgAJZz8ACWc8AAIAOk1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtMjAwNV95dS5wZGYADgAgAA8AaQBjAHMAbQAyADAAMAA1AF8AeQB1AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAqVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTIwMDVfeXUucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AqgCvALcCQQJDAkgCUwJcAmoCbgJ1An4CgwKQApMCpQKoAq0AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACrw==}}

@inproceedings{yu2003cascon,
	Abstract = {The development of large software systems involves a continual lengthy build process that may include preprocessing, compilation and linking of tens of thousands of source code files. In many cases, much of this build time is wasted because of false dependencies between implementation files and their respective header files. We present a graph algorithm and a programming tool that discovers and removes false dependencies among files. We show experimentally that the resulting preprocessed code is more compact, thereby contributing to faster build processes.},
	Author = {Yijun Yu and Homy Dayani-Fard and John Mylopoulos},
	Booktitle = {Proc. of the 13th IBM Centre for Advanced Studies Conference (CASCON)},
	Date-Modified = {2012-08-28 19:34:40 +0000},
	Pages = {343--352},
	Title = {{Removing False Code Dependencies to Speedup Software Build Processes}},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGy4uL1BhcGVycy9jYXNjb24yMDAzX3l1LnBkZtIXCxgZV05TLmRhdGFPEQGOAAAAAAGOAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4RY2FzY29uMjAwM195dS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOFcxilXsAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxizbsAAAABAAwACg4OAAlnPwAJZzwAAgA8TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGNhc2NvbjIwMDNfeXUucGRmAA4AJAARAGMAYQBzAGMAbwBuADIAMAAwADMAXwB5AHUALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACxVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9jYXNjb24yMDAzX3l1LnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKwAsQC5AksCTQJSAl0CZgJ0AngCfwKIAo0CmgKdAq8CsgK3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArk=}}

@inproceedings{sutton2007,
	Abstract = {An in-depth investigation of C preprocessor usage for portability and configuration management is presented. Three heavily-ported and widely used C++ libraries are examined.  A core set of header files responsible for configuration management is identified in each system. Then macro usage is extracted and analyzed both manually and with the help of program analysis tools. The configuration structure of each library is discussed in details and commonalities between the systems, including conventions and patterns are discussed. A common configuration architecture for managing portability concerns is derived and presented.},
	Author = {Andrew Sutton and Jonathan I. Maletic},
	Booktitle = {Proc. of the 23rd Int'l Conf. on Software Maintenance (ICSM)},
	Date-Modified = {2012-08-28 19:10:56 +0000},
	Title = {{How We Manage Portability and Configuration with the C Preprocessor}},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pY3NtMjAwN19zdXR0b24ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpY3NtMjAwN19zdXR0b24ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg7AzGKP8AAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzGLIMAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzbTIwMDdfc3V0dG9uLnBkZgAOACgAEwBpAGMAcwBtADIAMAAwADcAXwBzAHUAdAB0AG8AbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc20yMDA3X3N1dHRvbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{lubsen2009msr,
	Abstract = {Unit tests are generally acknowledged as an important aid to produce high quality code, as they provide quick feedback to developers on the correctness of their code. In order to achieve high quality, well-maintained tests are needed. Ideally, tests co-evolve with the production code to test changes as soon as possible. In this paper, we explore an approach based on association rule mining to determine whether production and test code co-evolve synchronously. Through two case studies, one with an open source and another one with an industrial software system, we show that our association rule mining approach allows one to assess the co-evolution of product and test code in a software project and, moreover, to uncover the distribution of programmer effort over pure coding, pure testing, or a more test-driven-like practice.},
	Author = {Zeeger Lubsen and Andy Zaidman and Martin Pinzger},
	Booktitle = {Proc. of the 6th Working Conf. on Mining Software Repositories (MSR)},
	Date-Modified = {2012-08-28 19:56:55 +0000},
	Title = {{Using Association Rules to Study the Co-evolution of Production \& Test Code}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9tc3IyMDA5X2x1YnNlbi5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEm1zcjIwMDlfbHVic2VuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDtXMYpqyAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMYtLyAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBtc3IyMDA5X2x1YnNlbi5wZGYAAA4AJgASAG0AcwByADIAMAAwADkAXwBsAHUAYgBzAGUAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL21zcjIwMDlfbHVic2VuLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@incollection{azevedo2007,
	Abstract = {We study the predictive ability of some association rule measures typically used to assess descriptive interest. Such measures, namely conviction, lift and χ 2 are compared with confidence, Laplace, mutual information, cosine, Jaccard and φ-coefficient. As prediction models, we use sets of association rules. Classification is done by selecting the best rule, or by weighted voting. We performed an evaluation on 17 datasets with different characteristics and conclude that conviction is on average the best predictive measure to use in this setting. We also provide some meta-analysis insights for explaining the results.},
	Author = {Azevedo, Paulo and Jorge, Al{\'\i}pio},
	Booktitle = {Machine Learning: ECML 2007},
	Date-Modified = {2012-08-12 20:51:12 +0000},
	Editor = {Kok, Joost and Koronacki, Jacek and Mantaras, Raomon and Matwin, Stan and Mladenic, Dunja and Skowron, Andrzej},
	Pages = {510--517},
	Publisher = {Springer Berlin / Heidelberg},
	Series = {Lecture Notes in Computer Science},
	Title = {Comparing Rule Measures for Predictive Association Rules},
	Volume = {4701},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9lY21sMjAwN19hemV2ZWRvLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UZWNtbDIwMDdfYXpldmVkby5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOJMxNj1cAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxNx5cAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGVjbWwyMDA3X2F6ZXZlZG8ucGRmAAAOACoAFABlAGMAbQBsADIAMAAwADcAXwBhAHoAZQB2AGUAZABvAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvZWNtbDIwMDdfYXpldmVkby5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@incollection{alipio2005,
	Abstract = {In this paper we study a new technique we call post-bagging, which consists in resampling parts of a classification model rather then the data. We do this with a particular kind of model: large sets of classification association rules, and in combination with ordinary best rule and weighted voting approaches. We empirically evaluate the effects of the technique in terms of classification accuracy. We also discuss the predictive power of different metrics used for association rule mining, such as confidence, lift, conviction and χ 2. We conclude that, for the described experimental conditions, post-bagging improves classification results and that the best metric is conviction.},
	Author = {Jorge, Al{\'\i}pio and Azevedo, Paulo},
	Booktitle = {Discovery Science},
	Date-Modified = {2012-08-12 20:46:06 +0000},
	Editor = {Hoffmann, Achim and Motoda, Hiroshi and Scheffer, Tobias},
	Pages = {137-149},
	Publisher = {Springer Berlin / Heidelberg},
	Series = {Lecture Notes in Computer Science},
	Title = {An Experiment with Association Rules and Classification: Post-Bagging and Conviction},
	Volume = {3735},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QKC4uL1BhcGVycy9kaXNjb3ZlcnlzY2llbmNlMjAwNV9qb3JnZS5wZGbSFwsYGVdOUy5kYXRhTxEBxAAAAAABxAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OHmRpc2NvdmVyeXNjaWVuY2UyMDA1X2pvcmdlLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDh/MTY6SAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTcbSAAAAAQAMAAoODgAJZz8ACWc8AAIASU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBkaXNjb3ZlcnlzY2llbmNlMjAwNV9qb3JnZS5wZGYAAA4APgAeAGQAaQBzAGMAbwB2AGUAcgB5AHMAYwBpAGUAbgBjAGUAMgAwADAANQBfAGoAbwByAGcAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAOVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2Rpc2NvdmVyeXNjaWVuY2UyMDA1X2pvcmdlLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC5AL4AxgKOApAClQKgAqkCtwK7AsICywLQAt0C4ALyAvUC+gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL8}}

@inproceedings{fischer2003,
	Abstract = {Version control and bug tracking systems contain large amounts of historical information that can give deep insight into the evolution of a software project. Unfortunately, these systems provide only insufficient support for a detailed analysis of software evolution aspects. We address this problem and introduce an approach for populating a release history database that combines version data with bug tracking data and adds missing data not covered by version control systems such as merge points. Then simple queries can be applied to the structured data to obtain meaningful views showing the evolution of a software project. Such views enable more accurate reasoning of evolutionary aspects and facilitate the anticipation of software evolution. We demonstrate our approach on the large open source project Mozilla that offers great opportunities to compare results and validate our approach.},
	Author = {Michael Fischer and Martin Pinzger and Harald Gall},
	Booktitle = {Proc. of the 19th Int'l Conf. on Software Maintenance (ICSM)},
	Date-Modified = {2012-08-28 19:24:55 +0000},
	Pages = {23--32},
	Title = {{Populating a Release History Database from Version Control and Bug Tracking Systems}},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NtMjAwM19maXNjaGVyLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzbTIwMDNfZmlzY2hlci5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOvMxiky4AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxiy24AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc20yMDAzX2Zpc2NoZXIucGRmAAAOACoAFABpAGMAcwBtADIAMAAwADMAXwBmAGkAcwBjAGgAZQByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTIwMDNfZmlzY2hlci5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{brin1997,
	Abstract = {We consider the problem of analyzing market-basket data and present several important contributions. First, we present a new algorithm for finding large itemsets which uses fewer passes over the data than classic algorithms, and yet uses fewer candidate itemsets than methods based on sampling. We investigate the idea of item reordering, which can improve the low-level efficiency of the algorithm. Second, we present a new way of generating ``implication rules,'' which are normalized based on both the antecedent and the consequent and are truly implications (not simply a measure of co-occurrence), and we show how they produce more intuitive results than other methods. Finally, we show how different characteristics of real data, as opposed by synthetic data, can dramatically affect the performance of the system and the form of the results.},
	Author = {Sergey Brin and Rajeev Motwani and Jeffrey D. Ullman and Shalom Tsur},
	Booktitle = {Proc. of the 1997 ACM SIGMOD Int'l Conf. on Management Of Data},
	Date-Modified = {2012-08-14 00:11:19 +0000},
	Pages = {255--264},
	Publisher = {ACM},
	Title = {Dynamic Itemset Counting and Implication Rules for Market Basket Data},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9zaWdtb2QxOTk3X2JyaW4ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNzaWdtb2QxOTk3X2JyaW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChT7zE8QAAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE9IQAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAc2lnbW9kMTk5N19icmluLnBkZgAOACgAEwBzAGkAZwBtAG8AZAAxADkAOQA3AF8AYgByAGkAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3NpZ21vZDE5OTdfYnJpbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{berger2010ase,
	Abstract = {Variability models represent the common and variable features of products in a product line. Several variability modeling languages have been proposed in academia and industry; however, little is known about the practical use of such languages. We study and compare the constructs, semantics, usage and tools of two variability modeling languages, Kconfig and CDL. We provide empirical evidence for the real-world use of the concepts known from variability modeling research. Since variability models provide basis for automated tools (feature dependency checkers and product configurators), we believe that our findings will be of interest to variability modeling language and tool designers.},
	Author = {Thorsten Berger and Steven She and Rafael Lotufo and Andrzej Wasowski and Krzysztof Czarnecki},
	Booktitle = {Proc. of the 25th Int'l Conf. on Automated Software Engineering (ASE)},
	Date-Modified = {2012-08-28 20:01:47 +0000},
	Location = {Antwerp, Belgium},
	Title = {{Variability Modeling in the Real: A Perspective from the Operating Systems Domain}},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy9hc2UyMDEwX2Jlcmdlci5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEmFzZTIwMTBfYmVyZ2VyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDhHMYpvbAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMYtQbAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBhc2UyMDEwX2Jlcmdlci5wZGYAAA4AJgASAGEAcwBlADIAMAAxADAAXwBiAGUAcgBnAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2FzZTIwMTBfYmVyZ2VyLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{dmitriev2002,
	Abstract = {Keeping the code of a Java application consistent (code is consistent if all of the project classes can be recompiled together without errors) prevents late linking errors, and thus may significantly improve development turnaround time. In this paper we describe a make technology for the Java programming language, that is based on smart dependency checking, guarantees consistency of the project code, and at the same time reduces the number of source code recompilations to the minimum. After project code consistency is initially assured by complete recompilation, the information extracted from the binary classes is stored in a so-called project database. Whenever the source code for some class C is changed, its recompiled binary is compared to the old version of C preserved in the project database. As a result, we find a minimum subset of classes that depend on C and may be affected by the particular change made to it. These are recompiled in turn, and absence of compilation errors at this phase guarantees the consistency of the new project code. To determine which dependent classes to recompile, we categorize all source incompatible changes, and for each category establish a criterion for finding the smallest possible subset of dependent classes.},
	Author = {Mikhail Dmitriev},
	Booktitle = {Proc. of the 17th Conf. on Object-Oriented Programming, Systems, Languages \& Applications (OOPSLA)},
	Date-Modified = {2012-08-28 19:15:57 +0000},
	Publisher = {ACM},
	Title = {{Language-Specific Make Technology for the Java Programming Language}},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIS4uL1BhcGVycy9vb3BzbGEyMDAyX2RtaXRyaWV2LnBkZtIXCxgZV05TLmRhdGFPEQGmAAAAAAGmAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4Xb29wc2xhMjAwMl9kbWl0cmlldi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoO3MxikL0AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxiyP0AAAABAAwACg4OAAlnPwAJZzwAAgBCTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AG9vcHNsYTIwMDJfZG1pdHJpZXYucGRmAA4AMAAXAG8AbwBwAHMAbABhADIAMAAwADIAXwBkAG0AaQB0AHIAaQBlAHYALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADJVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9vb3BzbGEyMDAyX2RtaXRyaWV2LnBkZgATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALIAtwC/AmkCawJwAnsChAKSApYCnQKmAqsCuAK7As0C0ALVAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtc=}}

@inproceedings{bird2009fse,
	Abstract = {Software engineering researchers have long been interested in where and why bugs occur in code, and in predicting where they might turn up next. Historical bug-occurence data has been key to this research. Bug tracking systems, and code version histories, record when, how and by whom bugs were fixed; from these sources, datasets that relate file changes to bug fixes can be extracted. These historical datasets can be used to test hypotheses concerning processes of bug introduction, and also to build statistical bug prediction models. Unfortunately, processes and humans are imperfect, and only a fraction of bug fixes are actually labelled in source code version histories, and thus become available for study in the extracted datasets. The question naturally arises, are the bug fixes recorded in these historical datasets a fair representation of the full population of bug fixes? In this paper, we investigate historical data from several software projects, and find strong evidence of systematic bias. We then investigate the potential effects of unfair, imbalanced" datasets on the performance of prediction techniques. We draw the lesson that bias is a critical problem that threatens both the effectiveness of processes that rely on biased datasets to build prediction models and the generalizability of hypotheses tested on biased data.},
	Author = {Christian Bird and Adrian Bachmann and Eirik Aune and John Duffy and Abraham Bernstein and Vladimir Filkov and Premkumar Devanbu},
	Booktitle = {{Proc. of the 7th joint meeting of the European Software Engineering Conf. and the Symposium on the Foundations of Software Engineering (ESEC/FSE)}},
	Date-Modified = {2014-01-21 03:33:05 +0000},
	Pages = {121--130},
	Title = {{Fair and Balanced? Bias in Bug-Fix Datasets}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy9mc2UyMDA5X2JpcmQucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhBmc2UyMDA5X2JpcmQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4uzE8R2wAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE9KGwAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZnNlMjAwOV9iaXJkLnBkZgAADgAiABAAZgBzAGUAMgAwADAAOQBfAGIAaQByAGQALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9mc2UyMDA5X2JpcmQucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@inproceedings{mockus00,
	Abstract = {According to its proponents, open source style software development has the capacity to compete successfully, and perhaps in many cases displace, traditional commercial development methods. In order to begin investigating such claims, we examine the development process of a major open source application, the Apache web server. By using email archives of source code change history and problem reports we quantify aspects of developer participation, core team size, code ownership, productivity, defect density, and problem resolution interval for this OSS project. This analysis reveals a unique process, which performs well on important measures. We conclude that hybrid forms of development that borrow the most effective techniques from both the OSS and commercial worlds may lead to high performance software processes.},
	Author = {Mockus, Audris and Fielding, Roy T. and Herbsleb, James},
	Booktitle = {Proc. of the 22nd Int'l Conf. on Software Engineering (ICSE)},
	Date-Modified = {2012-08-12 21:22:16 +0000},
	Pages = {263--272},
	Title = {A case study of open source software development: the Apache server},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9pY3NlMjAwMF9tb2NrdXMucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNpY3NlMjAwMF9tb2NrdXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg41zE2WgAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE3OwAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZTIwMDBfbW9ja3VzLnBkZgAOACgAEwBpAGMAcwBlADIAMAAwADAAXwBtAG8AYwBrAHUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2UyMDAwX21vY2t1cy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{nguyen2010wcre,
	Abstract = {Software quality researchers build software quality models by recovering traceability links between bug reports in issue tracking repositories and source code files. However, all too often the data stored in issue tracking repositories is not explicitly tagged or linked to source code. Researchers have to resort to heuristics to tag the data (e.g., to determine if an issue is a bug report or a work item), or to link a piece of code to a particular issue or bug.
Recent studies by Bird et al. and by Antoniol et al. suggest that software models based on imperfect datasets with missing links to the code and incorrect tagging of issues, exhibit biases that compromise the validity and generality of the quality models built on top of the datasets. In this study, we verify the effects of such biases for a commercial project that enforces strict development guidelines and rules on the quality of the data in its issue tracking repository. Our results show that even in such a perfect setting, with a near-ideal dataset, biases do exist -- leading us to conjecture that biases are more likely a symptom of the underlying software development process instead of being due to the used heuristics.},
	Author = {Nguyen, Thanh H. D. and Adams, Bram and Hassan, Ahmed E.},
	Booktitle = {{Proc. of the 17th Working Conf. on Reverse Engineering (WCRE)}},
	Date-Modified = {2014-01-21 03:28:56 +0000},
	Pages = {259--268},
	Title = {{A Case Study of Bias in Bug-Fix Datasets}},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy93Y3JlMjAxMF9uZ3V5ZW4ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN3Y3JlMjAxMF9uZ3V5ZW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChUWzEvxmwAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzEwp2wAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAd2NyZTIwMTBfbmd1eWVuLnBkZgAOACgAEwB3AGMAcgBlADIAMAAxADAAXwBuAGcAdQB5AGUAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3djcmUyMDEwX25ndXllbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{vanderstorm07,
	Abstract = {Integration hell is a prime example of software evolution gone out of control. The Sisyphus continuous integration system is designed to prevent this situation in the context of component-based software configuration management. We show how incremental and backtracking techniques are applied to strike a balance between maximal feedback and being up-to-the-minute, and how these techniques enable automation of release and delivery.},
	Author = {Tijs van der Storm},
	Booktitle = {Proc. of the 11th Conf. on Software Maintenance and Reengineering (CSMR)},
	Date-Modified = {2012-08-28 19:54:31 +0000},
	Title = {The {Sisyphus} Continuous Integration System},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJC4uL1BhcGVycy9jc21yMjAwN192YW5fZGVyX3N0b3JtLnBkZtIXCxgZV05TLmRhdGFPEQG0AAAAAAG0AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4aY3NtcjIwMDdfdmFuX2Rlcl9zdG9ybS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOHcximfwAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxi0jwAAAABAAwACg4OAAlnPwAJZzwAAgBFTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGNzbXIyMDA3X3Zhbl9kZXJfc3Rvcm0ucGRmAAAOADYAGgBjAHMAbQByADIAMAAwADcAXwB2AGEAbgBfAGQAZQByAF8AcwB0AG8AcgBtAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA1VXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvY3NtcjIwMDdfdmFuX2Rlcl9zdG9ybS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AtQC6AMICegJ8AoECjAKVAqMCpwKuArcCvALJAswC3gLhAuYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6A==}}

@inproceedings{dolstra04,
	Abstract = {The deployment of software components frequently failsbecause dependencies on other components are not declaredexplicitly or are declared imprecisely. This resultsin an incomplete reproduction of the environment necessaryfor proper operation, or in interference between incompatiblevariants. In this paper we show that these deploymenthazards are similar to pointer hazards in memory models ofprogramming languages and can be countered by imposinga memory management discipline on software deployment.Based on this analysis we have developed a generic, platformand language independent, discipline for deploymentthat allows precise dependency verification; exact identification of component variants; computation of complete closures containing all components on which a component depends;maximal sharing of components between such closures;and concurrent installation of revisions and variantsof components. We have implemented the approach in theNix deployment system, and used it for the deployment of alarge number of existing Linux packages. We compare its effectivenessto other deployment systems.},
	Author = {Eelco Dolstra and Eelco Visser and Merijn de Jonge},
	Booktitle = {Proc. of the 26th Int'l Conf. on Software Engineering (ICSE)},
	Date-Modified = {2012-08-28 19:13:29 +0000},
	Pages = {583--592},
	Title = {Imposing a Memory Management Discipline on Software Deployment},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3NlMjAwNF9kb2xzdHJhLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNzZTIwMDRfZG9sc3RyYS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoONsxikG8AAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxiyK8AAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljc2UyMDA0X2RvbHN0cmEucGRmAAAOACoAFABpAGMAcwBlADIAMAAwADQAXwBkAG8AbABzAHQAcgBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMDRfZG9sc3RyYS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{mcintosh2011icse,
	Abstract = {The build system of a software project is responsible for transforming source code and other development artifacts into executable programs and deliverables. Similar to source code, build system specifications require maintenance to cope with newly implemented features, changes to imported Ap- plication Program Interfaces (APIs), and source code re- structuring. In this paper, we mine the version histories of one proprietary and nine open source projects of different sizes and domain to analyze the overhead that build mainte- nance imposes on developers. We split our analysis into two dimensions: (1) Build Coupling, i.e., how frequently source code changes require build changes, and (2) Build Owner- ship, i.e., the proportion of developers responsible for build maintenance. Our results indicate that, despite the differ- ence in scale, the build system churn rate is comparable to that of the source code, and build changes induce more rel- ative churn on the build system than source code changes induce on the source code. Furthermore, build maintenance yields up to a 27% overhead on source code development and a 44% overhead on test development. Up to 79% of source code developers and 89% of test code developers are significantly impacted by build maintenance, yet investment in build experts can reduce the proportion of impacted de- velopers to 22% of source code developers and 24% of test code developers.},
	Author = {Shane McIntosh and Bram Adams and Thanh H. D. Nguyen and Yasutaka Kamei and Ahmed E. Hassan},
	Booktitle = {Proc. of the 33rd Int'l Conf. on Software Engineering (ICSE)},
	Date-Modified = {2012-08-13 23:53:26 +0000},
	Location = {Honolulu, Hawaii, USA},
	Pages = {141--150},
	Title = {{An Empirical Study of Build Maintenance Effort}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NlMjAxMV9tY2ludG9zaC5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc2UyMDExX21jaW50b3NoLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATvVHMTwuUAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMT0PUAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAxMV9tY2ludG9zaC5wZGYADgAsABUAaQBjAHMAZQAyADAAMQAxAF8AbQBjAGkAbgB0AG8AcwBoAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMTFfbWNpbnRvc2gucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@conference{antoniol2005,
	Abstract = {Feature identification is a well-known technique to iden- tify subsets of a program source code activated when exercising a functionality. Several approaches have been proposed to identify features. We present an approach to feature identification and comparison for large object-oriented multi-threaded programs using both static and dynamic data. We use processor emulation, knowledge filtering, and probabilistic ranking to overcome the difficulties of collecting dynamic data, i.e., imprecision and noise. We use model transformations to compare and to visualise identified features. We compare our approach with a naive approach and a concept analysis-based approach using a case study on a real-life large object-oriented multi-threaded program, Mozilla, to show the advantages of our approach. We also use the case study to compare processor emulation with statistical profiling.},
	Author = {Giuliano Antoniol and Yann-Ga{\"e}l Gu{\'e}h{\'e}neuc},
	Booktitle = {Proc. of the 21st Int'l Conf. on Software Maintenance (ICSM)},
	Date-Modified = {2012-08-12 20:33:44 +0000},
	Pages = {357--366},
	Title = {Feature Identification: A Novel Approach and a Case Study},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NtMjAwNV9hbnRvbmlvbC5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc20yMDA1X2FudG9uaW9sLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKDr3MTYtYAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMTcOYAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtMjAwNV9hbnRvbmlvbC5wZGYADgAsABUAaQBjAHMAbQAyADAAMAA1AF8AYQBuAHQAbwBuAGkAbwBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTIwMDVfYW50b25pb2wucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{khomh2009wcre,
	Abstract = {Code smells are poor implementation choices, thought to make object-oriented systems hard to maintain. In this study, we investigate if classes with code smells are more change-prone than classes without smells. Specifically, we test the general hypothesis: classes with code smells are not more change prone than other classes. We detect 29 code smells in 9 releases of Azureus and in 13 releases of Eclipse, and study the relation between classes with these code smells and class change-proneness. We show that, in almost all releases of Azureus and Eclipse, classes with code smells are more change-prone than others, and that specific smells are more correlated than others to change-proneness. These results justify a posteriori previous work on the specification and detection ofcode smells and could help focusing quality assurance and testing activities.},
	Author = {Foutse Khomh and Massimiliano Di Penta and Yann-Ga{\"e}l Gu{\'e}h{\'e}neuc},
	Booktitle = {Proc. of the 16th Working Conf. on Reverse Engineering (WCRE)},
	Date-Modified = {2012-08-13 23:59:40 +0000},
	Location = {Lille, France},
	Pages = {75--84},
	Title = {{An Exploratory Study of the Impact of Code Smells on Software Change-proneness}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHC4uL1BhcGVycy93Y3JlMjAwOV9raG9taC5wZGbSFwsYGVdOUy5kYXRhTxEBlAAAAAABlAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OEndjcmUyMDA5X2tob21oLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKFRXMTw0KAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADMT0VKAAAAAQAMAAoODgAJZz8ACWc8AAIAPU1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgB3Y3JlMjAwOV9raG9taC5wZGYAAA4AJgASAHcAYwByAGUAMgAwADAAOQBfAGsAaABvAG0AaAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALVVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3djcmUyMDA5X2tob21oLnBkZgAAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCtALIAugJSAlQCWQJkAm0CewJ/AoYCjwKUAqECpAK2ArkCvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALA}}

@inproceedings{khomh2011wcre,
	Abstract = {A crash is an unexpected termination of an application during normal execution. Crash reports record stack traces and run-time information once a crash occurs. A group of similar crash reports represents a crash-type. The triaging of crash-types is critical to shorten the development and maintenance process. Crash triaging process decides the priority of crash-types to be fixed. The decision typically depends on many factors, such as the impact of the crash-type, (i.e., its severity), the frequency of occurring, and the effort required to implement a fix for the crash-type. In this paper, we propose the use of entropy region graphs to triage crash- types. An entropy region graph captures the distribution of the occurrences of crash-types among the users of a system. We conduct an empirical study on crash reports and bugs, collected from 10 beta releases of Firefox 4. We show that our proposed triaging technique enables a better classification of crash-types than the current triaging used by Firefox teams. Developers and managers could use such a technique to prioritize crash- types during triage, to estimate developer workloads, and to decide which crash-types patches should be included in a next release.},
	Author = {Foutse Khomh and Brian Chan and Ying Zou and Ahmed E. Hassan},
	Booktitle = {Proc. of the 18th Working Conf. on Reverse Engineering (WCRE)},
	Pages = {261--270},
	Title = {{An Entropy Evaluation Approach for Triaging Field Crashes: A Case Study of Mozilla Firefox}},
	Year = {2011}}

@inproceedings{hassan2008fosm,
	Abstract = {Source control repositories, bug repositories, archived communications, deployment logs, and code repositories are examples of software repositories that are commonly available for most software projects. The mining software repositories (MSR) field analyzes and cross-links the rich data available in these repositories to uncover interesting and actionable information about software systems. By transforming these repositories from static record-keeping ones into active repositories, we can guide decision processes in modern software projects. For example, data in source control repositories, traditionally used to archive code, could be linked with data in bug repositories to help practitioners propagate complex changes and to warn them about risky code based on prior changes and bugs. In this paper, we present a brief history of the MSR field and discuss several recent achievements and results of using MSR techniques to support software research and practice. We then discuss the various opportunities and challenges that lie in the road ahead for this important and emerging field.},
	Author = {Ahmed E. Hassan},
	Booktitle = {Proc. of the Frontiers of Software Maintenance at the 24th Int'l Conf. on Software Maintenance (ICSM)},
	Date-Modified = {2012-08-28 19:52:38 +0000},
	Location = {Beijing, China},
	Pages = {48--57},
	Title = {{The Road Ahead for Mining Software Repositories}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9mb3NtMjAwOF9oYXNzYW4ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNmb3NtMjAwOF9oYXNzYW4ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4szGKZngAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzGLR3gAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZm9zbTIwMDhfaGFzc2FuLnBkZgAOACgAEwBmAG8AcwBtADIAMAAwADgAXwBoAGEAcwBzAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2Zvc20yMDA4X2hhc3Nhbi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{bird2011fse,
	Abstract = {Ownership is a key aspect of large-scale software development. We examine the relationship between different ownership measures and software failures in two large software projects: Windows Vista and Windows 7. We find that in all cases, measures of ownership such as the number of low-expertise developers, and the proportion of ownership for the top owner have a relationship with both pre-release faults and post-release failures. We also empirically identify reasons that low-expertise developers make changes to components and show that the removal of low-expertise contributions dramatically decreases the performance of contribution based defect prediction. Finally we provide recommendations for source code change policies and utilization of resources such as code inspections based on our results.},
	Author = {Christian Bird and Nachiappan Nagappan and Brendan Murphy and Harald Gall and Premkumar Devanbu},
	Booktitle = {{Proc. of the 8th joint meeting of the European Software Engineering Conf. and the Symposium on the Foundations of Software Engineering (ESEC/FSE)}},
	Date-Modified = {2014-01-21 03:32:53 +0000},
	Location = {Szeged, Hungary},
	Pages = {4--14},
	Title = {{Don't Touch My Code! Examining the Effects of Ownership on Software Quality}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy9mc2UyMDExX2JpcmQucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhBmc2UyMDExX2JpcmQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABRKFOzE8PfwAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzE9HvwAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZnNlMjAxMV9iaXJkLnBkZgAADgAiABAAZgBzAGUAMgAwADEAMQBfAGIAaQByAGQALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9mc2UyMDExX2JpcmQucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@techreport{kumfert2002,
	Abstract = {``The Build'' is the infrastructure needed to convert software from source code to usable form. It is intimately tied to the software it supports, knowing about every file and automating every transformation needed to produce a working program. Every developer knows that a project spends some labor overhead on ``the build.'' How big is this hidden overhead?
According to 34 scientific software developers we surveyed at Lawrence Livermore National Labs, among col- leagues at other DOE labs, and a handful of academics the ``perceived'' overhead averages around 12%. Individual cases of 20% to 30% were not uncommon. In one project claiming a 20% overhead, we found supporting evidence by combing through their CVS repository.},
	Address = {CA, USA},
	Author = {Kumfert, G.K. and Epperly, T.G.W.},
	Date-Modified = {2012-08-29 21:59:43 +0000},
	Institution = {Lawrence Livermore National Laboratory},
	Number = {UCRL-ID-147343},
	Title = {{Software in the DOE: The Hidden Overhead of ``The Build''}},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9kb2UyMDAyX2t1bWZlcnQucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNkb2UyMDAyX2t1bWZlcnQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4hzGKcIwAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzGLUYwAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZG9lMjAwMl9rdW1mZXJ0LnBkZgAOACgAEwBkAG8AZQAyADAAMAAyAF8AawB1AG0AZgBlAHIAdAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2RvZTIwMDJfa3VtZmVydC5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@phdthesis{shirabadphd,
	Author = {Shirabad, J. S.},
	School = {{University of Ottawa}},
	Title = {{Supporting Software Maintenance by Mining Software Update Records}},
	Year = {2003}}

@mastersthesis{lubsenthesis,
	Address = {Delft, the Netherlands},
	Author = {Zeeger Lubsen},
	School = {{Delft University of Technology}},
	Title = {{Studying Co-evolution of Production and Test Code Using Association Rule Mining}},
	Year = {2008}}

@mastersthesis{shang2010msc,
	Address = {Kingston, Ontario, Canada},
	Author = {Weiyi Shang},
	School = {{Queen's University}},
	Title = {{Enabling Large-Scale Mining Software Repositories (MSR) Studies Using Web-Scale Platforms}},
	Year = {2010}}

@book{halsteadmetrics,
	Address = {New York, NY, USA},
	Author = {Halstead, Maurice H.},
	Isbn = {0444002057},
	Publisher = {Elsevier Science Inc.},
	Title = {Elements of Software Science (Operating and Programming Systems Series)},
	Year = {1977}}

@book{fowler1999,
	Address = {Reading, Mass, USA},
	Author = {Martin Fowler and Kent Beck and John Brant and William Opdyke and Don Roberts},
	Isbn = {0201485672},
	Publisher = {Addison-Wesley Professional},
	Title = {{Refactoring: Improving the Design of Existing Code}},
	Year = {1999}}

@book{cmake,
	Address = {Clifton Park, NY, USA},
	Author = {Martin, Ken and Hoffman, Bill},
	Isbn-13 = {978-1-930934-22-1},
	Publisher = {Kitware Inc.},
	Title = {{Mastering CMake, 5th Edition}},
	Year = {2009}}

@book{codecomplete,
	Author = {McConnell, Steve},
	Isbn = {0735619670},
	Publisher = {Microsoft},
	Title = {{Code Complete, 2nd Edition}},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJC4uL1BhcGVycy9ib29rX2NvZGVjb21wbGV0ZV8yMDA0LnBkZtIXCxgZV05TLmRhdGFPEQG0AAAAAAG0AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4aYm9va19jb2RlY29tcGxldGVfMjAwNC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOGsThhRwAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMThvVwAAAABAAwACg4OAAlnPwAJZzwAAgBFTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGJvb2tfY29kZWNvbXBsZXRlXzIwMDQucGRmAAAOADYAGgBiAG8AbwBrAF8AYwBvAGQAZQBjAG8AbQBwAGwAZQB0AGUAXwAyADAAMAA0AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA1VXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvYm9va19jb2RlY29tcGxldGVfMjAwNC5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AtQC6AMICegJ8AoECjAKVAqMCpwKuArcCvALJAswC3gLhAuYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6A==}}

@book{designpatterns,
	Author = {Gamma, E. and Helm, R. and Johnson, R. and Vlissides, J.},
	Publisher = {Addison-wesley Reading, MA},
	Title = {{Design patterns: elements of reusable object-oriented software}},
	Year = {1995}}

@book{quinlan93,
	Address = {San Francisco, CA, USA},
	Author = {Quinlan, J. Ross},
	Isbn = {1-55860-238-0},
	Publisher = {Morgan Kaufmann Publishers Inc.},
	Title = {{C4.5: Programs for Machine Learning}},
	Year = {1993}}

@book{weka,
	Address = {San Francisco, CA, USA},
	Author = {Witten, Ian H. and Frank, E.},
	Isbn = {0120884070},
	Publisher = {Elsevier},
	Title = {{Data Mining: Practical Machine Learning Tools and Techniques}},
	Year = {2005}}

@misc{sloccount,
	Author = {David A. Wheeler},
	Howpublished = {\url{http://www.dwheeler.com/sloccount/}},
	Note = {last viewed: 26-Feb-2010},
	Title = {SLOCCount}}

@misc{bugzilla,
	Author = {{Mozilla Development Team}},
	Howpublished = {\url{http://www.bugzilla.org/}},
	Note = {last viewed: 14-Aug-2010},
	Title = {Bugzilla: Issue Tracking Software}}

@misc{neagu-wrong,
	Author = {Neagu, A.},
	Howpublished = {\url{http://freecode.net/articles/what-is-wrong-with-make}},
	Note = {last viewed: 23-Jan-2013},
	Title = {{What is Wrong with Make}},
	Year = {2010}}

@misc{conifer-wrong,
	Author = {Conifer Systems},
	Howpublished = {http://www.conifersystems.com/whitepapers/gnu-make/},
	Note = {Last viewed: 07-Jul-2010},
	Title = {{What is wrong with GNU make}}}

@misc{antmanual,
	Howpublished = {\url{http://ant.apache.org/manual/}},
	Title = {{Ant Manual}}}

@misc{argodoc,
	Author = {{ArgoUML Team}},
	Howpublished = {\url{http://argouml-downloads.tigris.org/argouml-0.28.1/}},
	Note = {last viewed: 26-Feb-2010},
	Title = {{ArgoUML Documentation}}}

@misc{kde,
	Author = {Alexander Neundorf},
	Howpublished = {\url{http://lwn.net/Articles/188693/}},
	Note = {last viewed: 06-Mar-2010},
	Title = {Why the {KDE} project switched to {CMake} -- and how (continued)},
	Year = {2010}}

@misc{argobug,
	Author = {{ArgoUML Team}},
	Howpublished = {\url{http://argouml.tigris.org/issues/show_bug.cgi?id=4625}},
	Title = {{ArgoUML Restructuring, Issue 4625}},
	Year = {2008}}

@misc{gbs,
	Howpublished = {\url{http://www.gnu.org/software/hello/manual/automake/GNU-Build-System.html}},
	Note = {last viewed: 16-Mar-2010},
	Title = {{Introducing the GNU Build System}}}

@misc{hibernate_mvn,
	Author = {Ebersole, Steve},
	Howpublished = {http://lists.jboss.org/pipermail/hibernate-dev/2007-May/002075.html},
	Note = {last viewed: 18-Mar-2010},
	Title = {Maven Migration},
	Year = {2007}}

@misc{maven,
	Howpublished = {\url{http://maven.apache.org/}},
	Title = {{Apache Maven}}}

@misc{mozilla,
	Author = {{Mozilla Foundation}},
	Howpublished = {\url{http://www.mozilla.com/}},
	Note = {Viewed on: 11-Apr-2010},
	Title = {Mozilla Communications Suite}}

@misc{gcc,
	Author = {{GNU Development Team}},
	Howpublished = {\url{http://gcc.gnu.org/}},
	Note = {Last viewed: 11-Apr-2010},
	Title = {{GNU Compiler Collection}}}

@misc{perl,
	Author = {{Perl Development Team}},
	Howpublished = {\url{http://www.perl.org/}},
	Note = {Last viewed: 11-Apr-2010},
	Title = {{Perl Scripting Language}}}

@misc{amd,
	Author = {{BSD Development Team}},
	Howpublished = {\url{http://www.am-utils.org/}},
	Note = {Last viewed: 11-Apr-2010},
	Title = {{The Berkeley Automounter Suite of Tools}}}

@misc{ff,
	Howpublished = {\url{http://mozilla.com/firefox/}},
	Title = {Firefox}}

@misc{thunderbird,
	Howpublished = {\url{http://mozilla.com/thunderbird/}},
	Title = {Thunderbird}}

@misc{linux,
	Author = {{L. Torvalds et al}},
	Howpublished = {\url{http://kernel.org/}},
	Note = {Viewed on: 15-Apr-2010},
	Title = {{Linux Kernel}}}

@misc{git,
	Author = {{L. Torvalds et al}},
	Howpublished = {\url{http://git.or.cz/}},
	Note = {Viewed on: 15-Apr-2010},
	Title = {{git: the fast version control system}}}

@misc{kbuild,
	Howpublished = {\url{http://kbuild.sourceforge.net/}},
	Title = {Linux kbuild}}

@misc{freebsd_releng,
	Howpublished = {\url{http://freebsd.org/releng/}},
	Title = {{FreeBSD: RelEng}}}

@misc{cvs2git,
	Author = {{cvs2svn Team}},
	Howpublished = {\url{http://cvs2svn.tigris.org/}},
	Note = {Last viewed: 15-Apr-2010},
	Title = {{cvs2svn Project Homepage}}}

@misc{mysql,
	Author = {Lenz Grimmer},
	Howpublished = {\url{http://www.lenzg.net/archives/291-Building-MySQL-Server-with-CMake-on-LinuxUnix.html}},
	Month = {March},
	Note = {{Last viewed: 20-Aug-2010}},
	Title = {{Building MySQL Server with CMake on Linux/Unix}},
	Year = {2010}}

@misc{secondlife,
	Author = {{Linden Labs}},
	Howpublished = {\url{http://wiki.secondlife.com/wiki/CMake}},
	Month = {July},
	Note = {{Last viewed: 20-Aug-2010}},
	Title = {{CMake}},
	Year = {2010}}

@misc{kde_build_bug,
	Author = {{KDE developer: ``mosfet''}},
	Howpublished = {\url{http://lists.kde.org/?l=kde-core-devel\&m=95953244511288\&w=4}},
	Note = {{Last viewed: 18-Aug-2010}},
	Title = {{Autoconf/Automake errors in kdelibs}}}

@misc{argouml_build_bug,
	Author = {Thomas Neustupny},
	Howpublished = {\url{http://argouml.tigris.org/ds/viewMessage.do?dsForumId=450\&dsMessageId=2618367}},
	Note = {{Last viewed: 18-Aug-2010}},
	Title = {{Build failed in Hudson, what to do?}}}

@misc{mozilla_blocker,
	Author = {Tim Steiner},
	Howpublished = {\url{https://bugzilla.mozilla.org/show_bug.cgi?id=417037}},
	Note = {{Last viewed: 06-Oct-2012}},
	Title = {{mozStorage chokes on databases over AFP}}}

@misc{mozilla_build_bug,
	Author = {Andrew Miller},
	Howpublished = {\url{https://bugzilla.mozilla.org/show\_bug.cgi?id=351377}},
	Note = {{Last viewed: 06-Oct-2012}},
	Title = {{js/Makefile.in gone but still in allmakefiles.sh}}}

@misc{eclipse_build_bug,
	Author = {Douglas Pollock},
	Howpublished = {\url{https://bugs.eclipse.org/bugs/show_bug.cgi?id=121434}},
	Note = {{Last viewed: 18-Aug-2010}},
	Title = {{js/Makefile.in gone but still in allmakefiles.sh}}}

@misc{autotools,
	Howpublished = {\url{http://gnu.org/software/hello/manual/automake/Autotools-Introduction.html}},
	Title = {{GNU Autotools}}}

@misc{maven-migrate,
	Author = {{Apache Foundation}},
	Howpublished = {\url{http://maven.apache.org/guides/mini/guide-m1-m2.html}},
	Note = {{Last viewed: 02-Sep-2010}},
	Title = {{Maven Migration Guide}},
	Year = {2010}}

@misc{build_web,
	Author = {Brandon Savage},
	Date-Modified = {2013-06-03 14:07:41 +0000},
	Howpublished = {\url{http://www.brandonsavage.net/build-systems-relevancy-of-automated-builds-in-a-web-world/}},
	Title = {{Build Systems: Relevancy of Automated Builds in a Web World}},
	Year = {2010}}

@misc{build_smells,
	Author = {Paul Duvall},
	Howpublished = {\url{http://www.ibm.com/developerworks/java/library/j-ap10106/index.html}},
	Note = {Last viewed: 14-Sep-2011},
	Title = {Automation for the people: Remove the smell from your build scripts}}

@inproceedings{mcintosh2011wse,
	Abstract = {AJAX is an asynchronous client-side technology that enables feature-rich, interactive Web 2.0 applications. AJAX applications and technologies are very complex compared to classic web applications, having to cope with asynchronous communication over (unstable) network connections. Yet, AJAX developers still rely on the ad hoc development processes and techniques of the early '00s. To determine how the inherent complexity of AJAX impacts the design and maintenance of AJAX applications, this paper studies the amount of code reuse across the different features of an AJAX application. Furthermore, we analyze how the design of existing AJAX systems deal with AJAX-specific crosscutting concerns, such as handling the loss of network connectivity. We use dynamic analysis to recover the run-time behaviour of AJAX applications in the form of sequence diagrams that are indexed by the different asynchronous communication states that the application can be in. Exploratory case studies on three AJAX applications show that (1) a majority (60-90%) of the run-time behaviour is shared, theoretically simplifying maintenance, and (2) that the studied projects seem unprepared for loss of network connectivity, often presenting the user with an incorrect view of the application state.},
	Author = {Shane McIntosh and Bram Adams and Ahmed E. Hassan and Ying Zou},
	Booktitle = {Proc. of the 13th Int'l Symposium on Web Systems Evolution (WSE)},
	Date-Modified = {2012-08-28 19:59:04 +0000},
	Pages = {1--10},
	Title = {{Using Indexed Sequence Diagrams to Recover the Behaviour of AJAX Applications}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy93c2UyMDExX21jaW50b3NoLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4Ud3NlMjAxMV9tY2ludG9zaC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoVG8xim1IAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAMxi05IAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AHdzZTIwMTFfbWNpbnRvc2gucGRmAAAOACoAFAB3AHMAZQAyADAAMQAxAF8AbQBjAGkAbgB0AG8AcwBoAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvd3NlMjAxMV9tY2ludG9zaC5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{brown2010foser,
	Abstract = {Delivering increasingly complex software-reliant systems demands better ways to manage the long-term effects of short-term expedients. The technical debt metaphor is gaining significant traction in the agile development community as a way to understand and communicate such issues. The idea is that developers sometimes accept compromises in a system in one dimension (e.g., modularity) to meet an urgent demand in some other dimension (e.g., a deadline), and that such compromises incur a "debt": on which "interest" has to be paid and which the "principal" should be repaid at some point for the long-term health of the project. We argue that the software engineering research community has an opportunity to study and improve this concept. We can offer software engineers a foundation for managing such trade-offs based on models of their economic impacts. Therefore, we propose managing technical debt as a part of the future research agenda for the software engineering field.},
	Author = {Brown, Nanette and Cai, Yuanfang and Guo, Yuepu and Kazman, Rick and Kim, Miryung and Kruchten, Philippe and Lim, Erin and MacCormack, Alan and Nord, Robert and Ozkaya, Ipek and Sangwan, Raghvinder and Seaman, Carolyn and Sullivan, Kevin and Zazworka, Nico},
	Booktitle = {{Proc. of the Foundations of Software Engineering (FSE) Workshop on the Future of Software Engineering Research (FoSER)}},
	Date-Modified = {2012-09-19 15:08:26 +0000},
	Pages = {47--52},
	Title = {{Managing Technical Debt in Software-Reliant Systems}},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9mb3NlcjIwMTBfYnJvd24ucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNmb3NlcjIwMTBfYnJvd24ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4rzH9YVgAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzH+QlgAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZm9zZXIyMDEwX2Jyb3duLnBkZgAOACgAEwBmAG8AcwBlAHIAMgAwADEAMABfAGIAcgBvAHcAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2Zvc2VyMjAxMF9icm93bi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@inproceedings{shihab2010wcre,
	Abstract = {Bug fixing accounts for a large amount of the software maintenance resources. Generally, bugs are reported, fixed, verified and closed. However, in some cases bugs have to be re-opened. Re-opened bugs increase maintenance costs, degrade the overall user-perceived quality of the software and lead to unnecessary rework by busy practitioners. In this paper, we study and predict re-opened bugs through a case study on the Eclipse project. We structure our study along 4 dimensions: (1) the work habits dimension (e.g., the weekday on which the bug was initially closed on), (2) the bug report dimension (e.g., the component in which the bug was found) (3) the bug fix dimension (e.g., the amount of time it took to perform the initial fix) and (4) the team dimension (e.g., the experience of the bug fixer). Our case study on the Eclipse Platform 3.0 project shows that the comment and description text, the time it took to fix the bug, and the component the bug was found in are the most important factors in determining whether a bug will be re-opened. Based on these dimensions we create decision trees that predict whether a bug will be re-opened after its closure. Using a combination of our dimensions, we can build explainable prediction models that can achieve 62.9\% precision and 84.5\% recall when predicting whether a bug will be re-opened.},
	Author = {Emad Shihab and Akinori Ihara and Yasutaka Kamei and Walid M. Ibrahim and Masao Ohira and Bram Adams and Ahmed E. Hassan and Ken-ichi Matsumoto},
	Booktitle = {{Proc. of the 17th Working Conf. on Reverse Engineering (WCRE)}},
	Pages = {249--258},
	Title = {{Predicting Re-opened Bugs: A Case Study on the Eclipse Project}},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy93Y3JlMjAxMF9zaGloYWIucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhN3Y3JlMjAxMF9zaGloYWIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHcHczS0z+AAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzS16SAAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAd2NyZTIwMTBfc2hpaGFiLnBkZgAOACgAEwB3AGMAcgBlADIAMAAxADAAXwBzAGgAaQBoAGEAYgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL3djcmUyMDEwX3NoaWhhYi5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@misc{make_scale,
	Author = {Corey Brenner},
	Howpublished = {\url{http://lists.gnu.org/archive/html/help-make/2010-03/msg00049.html}},
	Title = {{Large non-recursive make not scaling. Patch.}},
	Year = {Last viewed: 06-Oct-2012}}

@misc{debian_source_pkg_policy,
	Author = {{Debian Team}},
	Howpublished = {\url{http://www.debian.org/doc/debian-policy/ch-source.html}},
	Title = {{Debian Policy Manual - Source Packages}},
	Year = {Last viewed: 06-Oct-2012}}

@inproceedings{mcintosh2011icsesrc,
	Abstract = {The build system, i.e., the infrastructure that converts source code into deliverables, plays a critical role in the development of a software project. For example, developers rely upon the build system to test and run their source code changes. Without a working build system, development progress grinds to a halt, as the source code is rendered useless. Based on experiences reported by developers, we conjecture that build maintenance for large software systems is considerable, yet this maintenance is not well understood. A firm understanding of build maintenance is essential for project managers to allocate personnel and resources to build maintenance tasks effectively, and reduce the build maintenance overhead on regular development tasks, such as fixing defects and adding new features. In our work, we empirically study build maintenance in one proprietary and nine open source projects of different sizes and domain. Our case studies thus far show that: (1) similar to Lehman's first law of software evolution, build system specifications tend to grow unless effort is invested into restructuring them, (2) the build system accounts for up to 31% of the code files in a project, and (3) up to 27% of development tasks that change the source code also require build maintenance. Currently, we are working on identifying concrete measures that projects can take to reduce the build maintenance overhead.},
	Author = {Shane McIntosh},
	Booktitle = {Proc. of the 33rd Int'l Conf. on Software Engineering (ICSE) ACM Student Research Competition (SRC)},
	Date-Modified = {2013-03-05 16:02:50 +0000},
	Location = {Honolulu, Hawaii, USA},
	Pages = {1167--1169},
	Title = {{Build System Maintenance}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIy4uL1BhcGVycy9pY3NlLXNyYzIwMTFfbWNpbnRvc2gucGRm0hcLGBlXTlMuZGF0YU8RAa4AAAAAAa4AAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhlpY3NlLXNyYzIwMTFfbWNpbnRvc2gucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN1SgzVuBKAAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzVvHeAAAAAEADAAKDg4ACWc/AAlnPAACAERNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAaWNzZS1zcmMyMDExX21jaW50b3NoLnBkZgAOADQAGQBpAGMAcwBlAC0AcwByAGMAMgAwADEAMQBfAG0AYwBpAG4AdABvAHMAaAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIANFVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2ljc2Utc3JjMjAxMV9tY2ludG9zaC5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC0ALkAwQJzAnUCegKFAo4CnAKgAqcCsAK1AsICxQLXAtoC3wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALh}}

@inproceedings{czerwinski2004chi,
	Abstract = {We report on a diary study of the activities of information workers aimed at characterizing how people interleave multiple tasks amidst interruptions. The week-long study revealed the type and complexity of activities performed, the nature of the interruptions experienced, and the difficulty of shifting among numerous tasks. We present key findings from the diary study and discuss implications of the findings. Finally, we describe promising directions in the design of software tools for task management, motivated by the findings.},
	Author = {Mary Czerwinski and Eric Horvitz and Susan Wilhite},
	Booktitle = {{Proc. of the 22nd ACM SIGCHI conference on Human factors in computing systems (CHI)}},
	Date-Modified = {2013-01-29 13:03:03 +0000},
	Pages = {175--182},
	Title = {A diary study of task switching and interruptions},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9jaGkyMDA0X2N6ZXJ3aW5za2kucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZjaGkyMDA0X2N6ZXJ3aW5za2kucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg4YzMUjnQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzMVp7QAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAY2hpMjAwNF9jemVyd2luc2tpLnBkZgAADgAuABYAYwBoAGkAMgAwADAANABfAGMAegBlAHIAdwBpAG4AcwBrAGkALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9jaGkyMDA0X2N6ZXJ3aW5za2kucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@book{yin2008case,
	Author = {Robert K. Yin},
	Publisher = {Sage Publications, Incorporated},
	Title = {Case study research: Design and methods},
	Volume = {5},
	Year = {2008}}

@article{treemap,
	Author = {Shneiderman, B.},
	Journal = {ACM Transactions on Graphics (TOG)},
	Number = {1},
	Pages = {92--99},
	Publisher = {ACM},
	Title = {Tree visualization with tree-maps: 2-d space-filling approach},
	Volume = {11},
	Year = {1992}}

@misc{buildprediction_replication,
	Date-Modified = {2014-05-03 20:33:53 +0000},
	Howpublished = {\url{http://sailhome.cs.queensu.ca/replication/shane/ICSME2014/}},
	Title = {Replication package}}

@misc{buildlangs_replication,
	Howpublished = {\url{http://sailhome.cs.queensu.ca/replication/shane/EMSE2013/}},
	Title = {Replication package}}

@misc{music_replication,
	Date-Modified = {2013-12-06 16:24:00 +0000},
	Howpublished = {\url{http://sailhome.cs.queensu.ca/replication/Orchestrating_Change/}},
	Title = {Supplementary materials}}

@inproceedings{ratzinger2007esem,
	Abstract = {With the advent of open source software repositories the data available for defect prediction in source files increased tremendously. Although traditional statistics turned out to derive reasonable results the sheer amount of data and the problem context of defect prediction demand sophisticated analysis such as provided by current data mining and machine learning techniques.In this work we focus on defect density prediction and present an approach that applies a decision tree learner on evolution data extracted from the Mozilla open source web browser project. The evolution data includes different source code, modification, and defect measures computed from seven recent Mozilla releases. Among the modification measures we also take into account the change coupling, a measure for the number of change-dependencies between source files. The main reason for choosing decision tree learners, instead of for example neural nets, was the goal of finding underlying rules which can be easily interpreted by humans. To find these rules, we set up a number of experiments to test common hypotheses regarding defects in software entities. Our experiments showed, that a simple tree learner can produce good results with various sets of input data.},
	Author = {Jacek Ratzinger and Thomas Sigmund and Peter Vorburger and Harald Gall},
	Booktitle = {Proc. of the 1st Int'l Symposium on Empirical Software Engineering and Measurement (ESEM)},
	Pages = {354--363},
	Title = {{Mining Software Evolution to Predict Refactoring}},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIC4uL1BhcGVycy9lc2VtMjAwN19yYXR6aW5nZXIucGRm0hcLGBlXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhZlc2VtMjAwN19yYXR6aW5nZXIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHU1wzSwFHwAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzSxLbwAAAAEADAAKDg4ACWc/AAlnPAACAEFNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAZXNlbTIwMDdfcmF0emluZ2VyLnBkZgAADgAuABYAZQBzAGUAbQAyADAAMAA3AF8AcgBhAHQAegBpAG4AZwBlAHIALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASADFVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9lc2VtMjAwN19yYXR6aW5nZXIucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALEAtgC+AmYCaAJtAngCgQKPApMCmgKjAqgCtQK4AsoCzQLSAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtQ=}}

@inproceedings{knab2006msr,
	Abstract = {Can we predict locations of future refactoring based on the development history? In an empirical study of open source projects we found that attributes of software evolution data can be used to predict the need for refactoring in the following two months of development. Information systems utilized in software projects provide a broad range of data for decision support. Versioning systems log each activity during the development, which we use to extract data mining features such as growth measures, relationships between classes, the number of authors working on a particular piece of code, etc. We use this information as input into classification algorithms to create prediction models for future refactoring activities. Different state-of-the-art classifiers are investigated such as decision trees, logistic model trees, prepositional rule learners, and nearest neighbor algorithms. With both high precision and high recall we can assess the refactoring proneness of object-oriented systems. Although we investigate different domains, we discovered critical factors within the development life cycle leading to refactoring, which are common among all studied projects.},
	Author = {Patrick Knab and Martin Pinzger and Abraham Bernstein},
	Booktitle = {Proc. of the 3rd Int'l Workshop on Mining Software Repositories (MSR)},
	Pages = {119--125},
	Title = {{Predicting Defect Densities in Source Code Files with Decision Tree Learners}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QGi4uL1BhcGVycy9tc3IyMDA2X2tuYWIucGRm0hcLGBlXTlMuZGF0YU8RAYwAAAAAAYwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhBtc3IyMDA2X2tuYWIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHcAUzS0zBQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzS15VQAAAAEADAAKDg4ACWc/AAlnPAACADtNYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAbXNyMjAwNl9rbmFiLnBkZgAADgAiABAAbQBzAHIAMgAwADAANgBfAGsAbgBhAGIALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASACtVc2Vycy9zaGFuZW1jaW50b3NoL1BhcGVycy9tc3IyMDA2X2tuYWIucGRmAAATAAEvAAAVAAIAFP//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAKsAsAC4AkgCSgJPAloCYwJxAnUCfAKFAooClwKaAqwCrwK0AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAArY=}}

@misc{linguist,
	Howpublished = {\url{https://github.com/github/linguist}},
	Title = {Linguist}}

@misc{ivy,
	Howpublished = {\url{http://ant.apache.org/ivy/}},
	Title = {{Apache Ivy}}}

@book{buildsystems,
	Author = {Peter Smith},
	Date-Modified = {2013-03-05 15:48:49 +0000},
	Edition = {1st},
	Month = {March},
	Publisher = {Addison-Wesley},
	Read = {0},
	Title = {{Software Build Systems: Principles and Experience}},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJC4uL1BhcGVycy9ib29rX2J1aWxkc3lzdGVtc18yMDExLnBkZtIXCxgZV05TLmRhdGFPEQG0AAAAAAG0AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4aYm9va19idWlsZHN5c3RlbXNfMjAxMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADdMbM1bfegAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM1bxDgAAAABAAwACg4OAAlnPwAJZzwAAgBFTWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGJvb2tfYnVpbGRzeXN0ZW1zXzIwMTEucGRmAAAOADYAGgBiAG8AbwBrAF8AYgB1AGkAbABkAHMAeQBzAHQAZQBtAHMAXwAyADAAMQAxAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA1VXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvYm9va19idWlsZHN5c3RlbXNfMjAxMS5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AtQC6AMICegJ8AoECjAKVAqMCpwKuArcCvALJAswC3gLhAuYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC6A==}}

@book{knuth2006art,
	Author = {Donald Ervin Knuth},
	Publisher = {Addison-Wesley},
	Title = {{The Art of Computer Programming}},
	Year = {2006}}

@book{beautifulcode,
	Author = {Andy Oram and Greg Wilson},
	Publisher = {O'Reilly Media},
	Title = {{Beautiful Code}},
	Year = {2007}}

@article{sonification_anomalies,
	Author = {Mark Ballora and Robert J. Cole and Heidi Kruesi and Herbert Greene and Ganesh Mohanan and David L. Hall},
	Journal = {TODO},
	Title = {Use of sonification in the detection of anomalous events},
	Year = {2012}}

@inproceedings{hermann2008icad,
	Abstract = {Sonification is still a relatively young research field and many terms such as sonification, auditory display, auralization, audification have been used without a precise definition. Recent developments such as the introduction of Model-Based Sonification, the establishment of interactive sonification and the increased interest in sonification from arts have raised the need to revisit the definitions in order to move towards a clearer terminology. This paper introduces a new definition for sonification and auditory display that emphasizes the necessary and sufficient conditions for organized sound to be called sonification. It furthermore suggests a taxonomy, and discusses the relation between visualization and sonification. A hierarchy of closed-loop interactions is furthermore introduced. This paper aims to initiate vivid discussion towards the establishment of a deeper theory of sonification and auditory display.},
	Author = {Thomas Hermann},
	Booktitle = {{Proc. of the 14th Int'l Conf. on Auditory Display (ICAD)}},
	Date-Added = {2013-03-05 16:05:49 +0000},
	Date-Modified = {2013-03-05 16:20:13 +0000},
	Pages = {1--8},
	Title = {Taxonomy and definitions for sonification and auditory display},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY2FkMjAwOF9oZXJtYW5uLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNhZDIwMDhfaGVybWFubi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADJAs81aL4sAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM1addsAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljYWQyMDA4X2hlcm1hbm4ucGRmAAAOACoAFABpAGMAYQBkADIAMAAwADgAXwBoAGUAcgBtAGEAbgBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNhZDIwMDhfaGVybWFubi5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@misc{not_software_engineering,
	Author = {Terence Parr},
	Howpublished = {\url{http://www.cs.usfca.edu/\~parrt/doc/software-not-engineering.html}},
	Title = {Why writing software is not like engineering}}

@inproceedings{hussein2009icpc,
	Abstract = {Faced with the challenges of understanding the source code of a program, software developers are assisted by a wealth of software visualization research. This work explores how visualization can be supplemented by sonification as a cognitive tool for code comprehension. By engaging the programmer's auditory senses, sonification can improve the utility of program comprehension tools. This paper reports on our experiences of creating and evaluating a program comprehension prototype tool that employs sonification to assist program understanding by rendering sonic cues. Our empirical evaluation of the efficacy of information sonification indicates that this cognitive aid can effectively complement visualization when trying to understand an unfamiliar code base. Based on our experiences, we then propose a set of guidelines for the design of a new generation of tools that increase their information utility by combining visualization and sonification.},
	Author = {Khaled Hussein and Eli Tilevich and Ivica Ico Bukvic and SooBeen Kim},
	Booktitle = {{Proc. of the 17th Int'l Conf. on Program Comprehension (ICPC)}},
	Pages = {120--129},
	Title = {{Sonification Design Guidelines to Enhance Program Comprehension}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHi4uL1BhcGVycy9pY3BjMjAwOV9odXNzZWluLnBkZtIXCxgZV05TLmRhdGFPEQGcAAAAAAGcAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADNB6+qSCsAAAAKDg4UaWNwYzIwMDlfaHVzc2Vpbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADI6L81aK3cAAAAAAAAAAAABAAIAAAkgAAAAAAAAAAAAAAAAAAAABlBhcGVycwAQAAgAAM0H9foAAAARAAgAAM1acccAAAABAAwACg4OAAlnPwAJZzwAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzaGFuZW1jaW50b3NoOgBQYXBlcnM6AGljcGMyMDA5X2h1c3NlaW4ucGRmAAAOACoAFABpAGMAcABjADIAMAAwADkAXwBoAHUAcwBzAGUAaQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAvVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNwYzIwMDlfaHVzc2Vpbi5wZGYAABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4ArwC0ALwCXAJeAmMCbgJ3AoUCiQKQApkCngKrAq4CwALDAsgAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACyg==}}

@inproceedings{berman2009sigdoc,
	Abstract = {Use of non-speech sound can facilitate the understanding of a software program. Non-speech sound has been shown to be useful in dynamic program comprehension, that is, understanding the dynamic behavior of a program. We have developed a sonification scheme to describe static software entities in Java programs, and we show that it is useful in static program comprehension, notably concerning low-level architecture. The scheme is implemented via a tool in which an Eclipse IDE is integrated with a CSound synthesis engine. The tool is intended for use by sighted software developers in a static browsing/editing environment.
A validation study of the concept has been performed via one-on-one sessions with experienced software developers. Preliminary results indicate that software developers are easily able to learn and recognize sonified characteristics of software entities and their relationships by listening to sequences of mapped sound constructs. Identification of specific entities is more problematic. Developers have indicated that they would find the tool useful during both exploration and more focused programming activities. Their additional perceptions have been collected using grounded qualitative means.},
	Author = {Lewis I. Berman and Keith B. Gallagher},
	Booktitle = {{Proc. of the 27th Int'l Conf. on Design of Communication (SIGDOC)}},
	Pages = {127--134},
	Title = {{Using Sound to Understand Software Architecture}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9zaWdkb2MyMDA5X2Jlcm1hbi5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFXNpZ2RvYzIwMDlfYmVybWFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABC0zHNdbnHAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADNdfIHAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBzaWdkb2MyMDA5X2Jlcm1hbi5wZGYADgAsABUAcwBpAGcAZABvAGMAMgAwADAAOQBfAGIAZQByAG0AYQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvc2lnZG9jMjAwOV9iZXJtYW4ucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{boccuzzo2008icsm,
	Abstract = {There exist numerous software visualization techniques that aim to facilitate program comprehension. One of the main concerns in every such software visualization is to identify relevant aspects fast and provide information in an effective way. In previous work, we developed a cognitive visualization technique and tool called CocoViz that uses common place metaphors for an intuitive understanding of software structures and evolution. In this paper, we address software comprehension by a combination of visualization and audio. Evolution and structural aspects are annotated with different audio to represent concepts such as design erosion, code smells or evolution metrics. We use audio concepts such as loudness, sharpness, tone pitch, roughness or oscillation and map those to properties of classes and packages. As such we provide an audio annotation of software entities along their version history for software analysis and software browsing. Our first results with the prototype and a small user study show that with this combination of visual and aural means we can facilitate program comprehension and provide additional information that usually is not provided by current visualization approaches.},
	Author = {Sandro Boccuzzo and Harald C. Gall},
	Booktitle = {Proc. of the 24th Int'l Conf. on Software Maintenance (ICSM)},
	Pages = {366--375},
	Title = {{Software Visualization with Audio Supported Cognitive Glyphs}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NtMjAwOF9ib2NjdXp6by5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc20yMDA4X2JvY2N1enpvLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABC4t3Ndc4yAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADNdgZyAAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NtMjAwOF9ib2NjdXp6by5wZGYADgAsABUAaQBjAHMAbQAyADAAMAA4AF8AYgBvAGMAYwB1AHoAegBvAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzbTIwMDhfYm9jY3V6em8ucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@inproceedings{boccuzzo2009icse,
	Abstract = {For ages we used our ears side by side with our ophthalmic stimuli to gather additional information, leading and supporting us in our visualization. Nowadays numerous software visualization techniques exist that aim to facilitate program comprehension. In this paper we discuss how we can support such software comprehension visualization with environmental audio and lead users to identify relevant aspects. We use cognitive visualization techniques and audio concepts described in our previous work to create an ambient audio software exploration (AASE) out of program entities (packages, classes ...) and their mapped properties. The concepts where implemented in a extended version of our tool called CocoViz. Our first results with the prototype shows that with this combination of visual and aural means we can provide additional information to lead users during program comprehension tasks.},
	Author = {Sandro Boccuzzo and Harald C. Gall},
	Booktitle = {{Proc. of the 31st Int'l Conf. on Software Engineering (ICSE)}},
	Pages = {571--574},
	Title = {{CocoViz with Ambient Audio Software Exploration}},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHy4uL1BhcGVycy9pY3NlMjAwOV9ib2NjdXp6by5wZGbSFwsYGVdOUy5kYXRhTxEBngAAAAABngACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzQevqkgrAAAACg4OFWljc2UyMDA5X2JvY2N1enpvLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABC+47Ndez9AAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZQYXBlcnMAEAAIAADNB/X6AAAAEQAIAADNdiU9AAAAAQAMAAoODgAJZz8ACWc8AAIAQE1hY2ludG9zaCBIRDpVc2VyczoAc2hhbmVtY2ludG9zaDoAUGFwZXJzOgBpY3NlMjAwOV9ib2NjdXp6by5wZGYADgAsABUAaQBjAHMAZQAyADAAMAA5AF8AYgBvAGMAYwB1AHoAegBvAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAwVXNlcnMvc2hhbmVtY2ludG9zaC9QYXBlcnMvaWNzZTIwMDlfYm9jY3V6em8ucGRmABMAAS8AABUAAgAU//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AsAC1AL0CXwJhAmYCcQJ6AogCjAKTApwCoQKuArECwwLGAssAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACzQ==}}

@incollection{mozreleng,
	Author = {Chris AtLee and Lukas Blakk and John O'Duinn and Armen Zambrano Gasparnian},
	Booktitle = {{The Architecture of Open Source Applications}},
	Editor = {Amy Brown and Greg Wilson},
	Pages = {23--38},
	Title = {{Firefox Release Engineering}},
	Volume = {2},
	Year = {2012}}

@misc{mozilla_tbpl,
	Howpublished = {\url{https://tbpl.mozilla.org/}},
	Title = {Mozilla Build Automation Server}}

@misc{jenkins-hudson,
	Howpublished = {\url{http://jenkins-ci.org/content/hudsons-future}},
	Title = {Hudson's future}}

@book{R_car,
	Author = {John Fox and Sanford Weisberg},
	Edition = {2$^{\textit{nd}}$},
	Publisher = {Sage},
	Title = {An {R} Companion to Applied Regression},
	Url = {http://socserv.socsci.mcmaster.ca/jfox/Books/Companion},
	Year = {2011},
	Bdsk-Url-1 = {http://socserv.socsci.mcmaster.ca/jfox/Books/Companion}}

@manual{R,
	Address = {Vienna, Austria},
	Author = {{R Core Team}},
	Organization = {R Foundation for Statistical Computing},
	Title = {R: A Language and Environment for Statistical Computing},
	Url = {http://www.R-project.org/},
	Year = {2013},
	Bdsk-Url-1 = {http://www.R-project.org/}}

@techreport{roy2007techreport,
	Author = {Chanchal Kumar Roy and James R. Cordy},
	Institution = {Queen's University at Kingston},
	Number = {541},
	Title = {A Survey on Software Clone Detection Research},
	Year = {2007}}

@inproceedings{koschke2007dagstuhl,
	Author = {Rainer Koschke},
	Booktitle = {Duplication, Redundancy, and Similarity in Software},
	Publisher = {Dagstuhl Seminar Proceedings},
	Title = {Survey of Research on Software Clones},
	Year = {2007}}

@inproceedings{rahman2013icse,
	Author = {Rahman, Foyzur and Devanbu, Premkumar},
	Booktitle = {{Proc. of the 35th Int'l Conf. on Software Engineering (ICSE)}},
	Pages = {432--441},
	Title = {How, and Why, Process Metrics Are Better},
	Year = {2013}}

@inproceedings{matsumoto2010promise,
	Author = {Shinsuke Matsumoto and Yasutaka Kamei and Akito Monden and Ken-ichi Matsumoto and Masahide Nakamura},
	Booktitle = {Proc. of the 6th Int'l Conf. on Predictive Models in Software Engineering (PROMISE)},
	Date-Modified = {2014-03-21 14:57:58 +0000},
	Pages = {18:1--18:9},
	Title = {An Analysis of Developer Metrics for Fault Prediction},
	Year = {2010}}

@inproceedings{nagappan2006icse,
	Author = {Nagappan, Nachiappan and Ball, Thomas and Zeller, Andreas},
	Booktitle = {{Proc. of the 28th Int'l Conf. on Software Engineering (ICSE)}},
	Pages = {452--461},
	Title = {Mining metrics to predict component failures},
	Year = {2006}}

@article{mockus2000bell,
	Abstract = {Reducing the number of software failures is one of the most challenging problems of software production. We assume that software development proceeds as a series of changes and model the probability that a change to software will cause a failure. We use predictors based on the properties of a change itself. Such predictors include size in lines of code added, deleted, and unmodified; diffusion of the change and its component subchanges, as reflected in the number of files, modules, and subsystems touched, or changed; several measures of developer experience; and the type of change and its subchanges (fault fixes or new code). The model is built on historic information and is used to predict the risk of new changes. In this paper we apply the model to 5ESS{\textregistered} software updates and find that change diffusion and developer experience are essential to predicting failures. The predictive model is implemented as a Web-based tool to allow timely prediction of change quality. The ability to predict the quality of change enables us to make appropriate decisions regarding inspection, testing, and delivery. Historic information on software changes is recorded in many commercial software projects, suggesting that our results can be easily and widely applied in practice.},
	Author = {Audris Mockus and David M. Weiss},
	Date-Modified = {2014-01-24 19:29:18 +0000},
	Journal = {Bell Labs Technical Journal},
	Number = {2},
	Pages = {169--180},
	Title = {{Predicting Risk of Software Changes}},
	Volume = {5},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uL1BhcGVycy9ibHRqMjAwMF9tb2NrdXMucGRm0hcLGBlXTlMuZGF0YU8RAZYAAAAAAZYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAM0Hr6pIKwAAAAoODhNibHRqMjAwMF9tb2NrdXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABpL+SzwgozQAAAAAAAAAAAAEAAgAACSAAAAAAAAAAAAAAAAAAAAAGUGFwZXJzABAACAAAzQf1+gAAABEACAAAzwhvHQAAAAEADAAKDg4ACWc/AAlnPAACAD5NYWNpbnRvc2ggSEQ6VXNlcnM6AHNoYW5lbWNpbnRvc2g6AFBhcGVyczoAYmx0ajIwMDBfbW9ja3VzLnBkZgAOACgAEwBiAGwAdABqADIAMAAwADAAXwBtAG8AYwBrAHUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIALlVzZXJzL3NoYW5lbWNpbnRvc2gvUGFwZXJzL2JsdGoyMDAwX21vY2t1cy5wZGYAEwABLwAAFQACABT//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJVAlcCXAJnAnACfgKCAokCkgKXAqQCpwK5ArwCwQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALD}}

@article{kim2008tse,
	Author = {Kim, Sunghun and Whitehead,Jr., E. James and Zhang, Yi},
	Journal = {{Transactions on Software Engineering (TSE)}},
	Number = {2},
	Pages = {181--196},
	Title = {Classifying Software Changes: Clean or Buggy?},
	Volume = {34},
	Year = {2008}}

@inproceedings{schroter2006isese,
	Author = {Schr\"{o}ter, Adrian and Zimmermann, Thomas and Zeller, Andreas},
	Booktitle = {Proc. of the Int'l Symposium on Empirical software engineering (ISESE)},
	Pages = {18--27},
	Title = {Predicting component failures at design time},
	Year = {2006}}

@inproceedings{kononenko2015icsme,
  Author = {Oleksii Kononenko and Olga Baysal and Latifa Guerrouj and Yaxin Cao and Michael W. Godfrey},
  Booktitle = {{Proc. of the 31st Int'l Conf. on Software Maintenance and Evolution (ICSME)}},
  Title = {{Investigating Code Review Quality: Do People and Participation Matter?}},
  Pages = {111--120},
  Year = {2015}}

@inproceedings{thongtanunam2015msr,
  Author = {Patanamon Thongtanunam and Shane McIntosh and Ahmed E. Hassan and Hajimu Iida},
  Title = {{Investigating Code Review Practices in Defective Files: An Empirical Study of the Qt System}},
  Booktitle = {Proc. of the 12th Working Conference on Mining Software Repositories (MSR)},
  Pages = {168--179},
  Year = {2015}}

@article{mcintosh2016emse,
  Author = {Shane McIntosh and Yasutaka Kamei and Bram Adams and Ahmed E. Hassan},
  Journal = {Empirical Software Engineering},
	_Month = {October},
	Number = {5},
	Pages = {2146--2189},
	Title = {{An empirical study of the impact of modern code review practices on software quality}},
	Volume = {21},
	Year = {2016}
}

@article{kamei2016emse,
  Author = {Yasutaka Kamei and Takafumi Fukushima and Shane McIntosh and Kazuhiro Yamashita and Naoyasu Ubayashi and Ahmed E. Hassan},
  Title = {{Studying just-in-time defect prediction using cross-project models}},
  Year = {2016},
  Volume = {21},
  Number = {5},
  Journal = {Empirical Software Engineering (EMSE)},
  Pages = {2072-–2106}
}

@inproceedings{sliwerski2005msr,
  Author = {Jacek \'{S}liwerski and Thomas Zimmermann and Andreas Zeller},
  Title = {{When Do Changes Induce Fixes?}},
  Year = {2005},
  Booktitle = {{Proc. of the 2nd Int'l Workshop on Mining Software Repositories (MSR)}},
  Pages = {1--5},
}

@inproceedings{herzig2013icse,
 author = {Herzig, Kim and Just, Sascha and Zeller, Andreas},
 title = {{It's Not a Bug, It's a Feature: How Misclassification Impacts Bug Prediction}},
 booktitle = {{Proc. of the 35th Int'l Conf. on Software Engineering (ICSE)}},
 year = {2013},
 pages = {392--401}
}

@inproceedings{kim2006ase,
 author = {Kim, Sunghun and Zimmermann, Thomas and Pan, Kai and Whitehead, E. James Jr.},
 title = {{Automatic Identification of Bug-Introducing Changes}},
 booktitle = {{Proc. of the 21st Int'l Conf. on Automated Software Engineering (ASE)}},
 year = {2006},
 pages = {81--90}
} 

@inproceedings{rahman2013fse,
  Author = {Foyzur Rahman and Daryl Posnett and Israel Herraiz and Premkumar Devanbu},
  Title = {{Sample Size vs. Bias in Defect Prediction}},
  Year = {2013},
	Booktitle = {{Proc. of the 9th joint meeting of the European Software Engineering Conf. and the Symposium on the Foundations of Software Engineering (ESEC/FSE)}},
  Pages = {147--157}
}
@article{turhan2012emse,
  Author = {Burak Turhan},
  Title = {{On the dataset shift problem in software engineering prediction models}},
  Journal = {Empirical Software Engineering (EMSE)},
	Volume = {17},
	Number = {1},
	Pages = {62--74},
	Year = {2012}
}

@inproceedings{d2010extensive,
  title={{An Extensive Comparison of Bug Prediction Approaches}},
  author={D'Ambros, Marco and Lanza, Michele and Robbes, Romain},
	booktitle={{Proc. of the 7th Working Conf. on Mining Software Repositories (MSR)}},
  pages={31--41},
  year={2010},
}

@inproceedings{wu2011fse,
  title={{ReLink: Recovering Links between Bugs and Changes}},
  author={Rongxin Wu and Hongyu Zhang and Sunghun Kim and Shing-Chi Cheung},
	booktitle={{Proc. of the 8th joint meeting of the European Software Engineering Conf. and the Symposium on the Foundations of Software Engineering (ESEC/FSE)}},
  pages={15--25},
  year={2011}
}

@inproceedings{ekanayake2009msr,
  title={{Tracking Concept Drift of Software Projects Using Defect Prediction Quality}},
  author={Jayalath Ekanayake and Jonas Tappolet and Harald C. Gall and Abraham Bernstein},
  booktitle={{Proc. of the 6th Working Conf. on Mining Software Repositories (MSR)}},
  pages={51--60},
  year={2009}
}

@article {Amasaki2015jsep,
author = {Amasaki, S. and Lokan, C.},
title = {{On the Effectiveness of Weighted Moving Windows: Experiment on Linear Regression based Software Effort Estimation}},
journal = {{Journal of Software: Evolution and Process}},
volume = {27},
number = {7},
issn = {2047-7481},
url = {http://dx.doi.org/10.1002/smr.1672},
doi = {10.1002/smr.1672},
pages = {488--507},
keywords = {effort estimation, moving window, gradual weighting},
year = {2015},
}

@inproceedings{Giger2010rsse,
 author = {Giger, Emanuel and Pinzger, Martin and Gall, Harald},
 title = {{Predicting the Fix Time of Bugs}},
 booktitle = {{Proc. of the 2nd Int'l Workshop on Recommendation Systems for Software Engineering (RSSE)}},
 year = {2010},
 isbn = {978-1-60558-974-9},
 location = {Cape Town, South Africa},
 pages = {52--56},
 numpages = {5},
 url = {http://doi.acm.org/10.1145/1808920.1808933},
 doi = {10.1145/1808920.1808933},
 acmid = {1808933},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

@inproceedings{hata2012icse,
  author = {Hideaki Hata and Osamu Mizuno and Tohru Kikuno},
  title = {{Bug Prediction Based on Fine-Grained Module Histories}},
  booktitle = {{Proc. of the 34th Int'l Conf. on Software Engineering (ICSE)}},
  pages = {200--210},
  year = {2012}
}

@inproceedings{giger2012esem,
  author = {Emanuel Giger and Marco D'Ambros and Martin Pinzger and Harald C. Gall},
  title = {{Method-Level Bug Prediction}},
  booktitle = {{Proc. of the 6th Int'l Symposium on Empirical Software Engineering and Measurement (ESEM)}},
  pages = {171--180},
  year = {2012}
}

@inproceedings{shihab2012fse,
  author = {Emad Shihab and Ahmed E. Hassan and Bram Adams and Zhen Ming Jiang},
  title = {{An Industrial Study on the Risk of Software Changes}},
  booktitle = {{Proc. of the 20th Int'l Symposium on the Foundations of Software Engineering (FSE)}},
  pages = {62:1--62:11},
  year = {2012}
}

@inproceedings{tan2015seip,
  author = {Ming Tan and Lin Tan and Sashank Dara and Caleb Mayeux},
  title = {{Online Defect Prediction for Imbalanced Data}},
  booktitle = {{Proc. of the 37th Int'l Conf. on Software Engineering}},
  volume = {2},
  pages = {99--108},
  year = {2015}
}

@inproceedings{aranda2009icse,
  author = {Jorge Aranda and Gina Venolia},
  title = {{The Secret Life of Bugs: Going Past the Errors and Omissions in Software Repositories}},
  booktitle = {{Proc. of the 31st Int'l Conf. on Software Engineering}},
  pages = {298--308},
  year = {2009}
}

@inproceedings{antoniol2008cascon,
  author = {Giuliano Antoniol and Kamel Ayari and Massimiliano Di Penta and Foutse Khomh and Yann-Ga{\"e}l Gu{\'e}h{\'e}neuc},
  title = {{Is it a Bug or an Enhancement? A Text-based Approach to Classify Change Requests}},
  booktitle = {{Proc. of the IBM Centre for Advanced Studies Conference (CASCon)}},
  pages = {23:1--23:15},
  year = {2008}
}

@inproceedings{kim2011icse,
  author = {Sunghun Kim and Hongyu Zhang and Rongxin Wu and Liang Gong},
  title = {{Dealing with Noise in Defect Prediction}},
  booktitle = {{Proc. of the 33rd Int'l Conf. on Software Engineering}},
  pages = {481--490},
  year = {2011}
}

@inproceedings{tantithamthavorn2015icse,
  author = {Chakkrit Tantithamthavorn and Shane McIntosh and Ahmed E. Hassan and Akinori Ihara and Kenichi Matsumoto},
  title = {{The Impact of Mislabelling on the Performance and Interpretation of Defect Prediction Models}},
  booktitle = {{Proc. of the 37th Int'l Conf. on Software Engineering (ICSE)}},
  pages = {812--823},
  year = {2015}
}

@inproceedings{ghotra2015icse,
  author = {Baljinder Ghotra and Shane McIntosh and Ahmed E. Hassan},
  title = {{Revisiting the Impact of Classification Techniques on the Performance of Defect Prediction Models}},
  booktitle = {{Proc. of the 37th Int'l Conf. on Software Engineering (ICSE)}},
  pages = {789-800},
  year = {2015}
}

@article{costa2017tse,
  Author = {Daniel Alencar da Costa and Shane McIntosh and Weiyi Shang and Uirá Kulesza and Roberta Coelho and Ahmed E. Hassan},
  Title = {{A Framework for Evaluating the Results of the SZZ Approach for Identifying Bug-Introducing Changes}},
  Year = {2017},
  Journal = {IEEE Transactions on Software Engineering},
  Volume = {To appear}
}

@article{porter1998tosem,
	Author = {Adam Porter and Harvey Siy and Audris Mockus and Lawrence Votta},
	Journal = {{Transactions On Software Engineering and Methodology (TOSEM)}},
	Number = {1},
	Pages = {41--79},
	Title = {{Understanding the Sources of Variation in Software Inspections}},
	Volume = {7},
	Year = {1998}
}

@book{raymond,
  Author = {Eric S. Raymond},
  Title = {{The Cathedral and the Bazaar}},
  Publisher = {{O'Reilly Media}},
  Year = {1999}
}

@inproceedings{zhou2011icse,
  Author = {Minghui Zhou and Audris Mockus},
  Title = {{Does the Initial Environment Impact the Future of Developers?}},
  Booktitle = {{Proc. of the 33rd Int'l Conf. on Software Engineering (ICSE)}},
  Pages = {271--280},
  Year = {2011}
}
