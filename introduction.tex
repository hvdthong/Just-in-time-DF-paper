\section{Introduction}
\label{sec:intro}
As software systems are becoming the backbone of our economy and society, defects existing in those systems may substantially affect businesses and people's lives  in many ways. For example, Knight Capital\footnote{https://dealbook.nytimes.com/2012/08/02/knight-capital-says-trading-mishap-cost-it-440-million/}, a company which executes automated trading  for retail brokers, lost $\$$440 millions in only one morning in 2012 due to an overnight faulty update to its trading software. A flawed code change, introduced into OpenSSL's source code repository, caused the infamous Heartbleed\footnote{http://heartbleed.com} bug which affected billions of Internet users in 2014. As software grows significantly in both size and complexity, finding defects and fixing them become increasingly difficult and costly.

One common best practice for cost saving is identifying defects and fixing them as early as possible, ideally before new code changes (i.e. \emph{commits}) are introduced into codebases. Emerging research has thus developed \emph{Just-In-Time} (JIT) defect prediction models and techniques which help software engineers and testers to quickly narrow down the most likely defective commits to a software codebase~\cite{KameiS16,D'Ambros:2012:EDP}. JIT defect prediction tools help provide early feedback to software developers to prioritize and optimize effort for inspection and (regression) testing, especially when facing with deadlines and limited resources. They have therefore been integrated into the development practice at large software organizations such as Avaya~\cite{Mockus2000}, Blackberry~\cite{Shihab:2012:ISR}, and Cisco~\cite{Tantithamthavorn:2015:IMP}.

Machine learning techniques have been widely used in existing work for building JIT defect prediction models. A common theme of existing work (e.g. \cite{Kamei:2013:LES,Kim:2008:CSC,Kononenko:2015,Mockus2000}) is carefully crafting a set of features representing a code change, and using them as defectiveness predictors. Those features are mostly derived from properties of code changes, such as change size (e.g. lines deleted or added), change scope (e.g. number of files or directories modified), history of changes (e.g. number of prior changes to the updated files), track record of the author and code reviewers, and activeness of the code review of the change. This set of features is then used as an input to a traditional classifier (e.g. Random Forests or Logistic Regression) to predict the defectiveness of code changes. A recent work \cite{Yang:2015:DLJ}  used a deep learning model (i.e. Deep Belief Network) to improve the performance of JIT defect prediction models. Their approach does not, however, leverage the true notions of deep learning. They still used the same set of features that are manually engineered as in previous work, and their model is \emph{not} end-to-end trainable.

The metric-based features however do not represent the semantic and syntactical structure of the actual code changes. In many cases, two different code changes which have exactly the same metrics (e.g. the number of lines deleted and added) may generate different behaviour when executed, and thus have a different likelihood of defectiveness. Previous studies have showed the usefulness of harvesting the syntactical structure and semantic information hidden in source code to perform various software engineering tasks such as code completion, bug detection and defect prediction \cite{Wang:2016:ALS,Tu:2014:LS,Nguyen:2015:GSL,Hindle:2012:NS,Li:2005:PAE}. This information may enrich representations for defective code changes, and thus improve JIT defect prediction.

% In this paper, we present a new JIT defect prediction model (namely DeepJIT) which leverages the powerful deep learning Convolution Neural Network (CNN) architecture to learn a deep representation of commits. Our model processes both a commit message (in natural language) and the associated code changes (in programming languages) and automatically semantic features which represent the ``meaning'' of the commit. This approach removes software practitioners from manually designing and extracting features, as done in previous work. DeepJIT is a fully end-to-end trainable system where raw data signals (e.g. words or code tokens) are passed from input nodes up to the final output node for predicting defectiveness, and prediction errors are back propagated from the output node down to the input layer.

Inspired by prior studies that demonstrate the power of Convolutional Neural Network (CNN)~\cite{lecun2015deep}, which has been showed extraordinary success for various Natural Language Processing (NLP)~\cite{kim2014convolutional, dos2014deep, kalchbrenner2014convolutional, zhang2015character, johnson2014effective}, to automatically extract useful semantic features from raw text data, we present a new JIT defect prediction model (namely DeepJIT). Our model processes both a commit message (in natural language) and the associated code changes (in programming languages) and automatically extracts features which represent the ``meaning'' of the commit. Different from the commit message, the code changes is more complex as it includes a number of deleted and added lines across multiple files. To solve this problem, we first learn the semantic features of each deleted or added line for each changed file using CNN framework, the features of the added and deleted lines are then incorporated to build a new representation of the change file. We again use CNN to extract features from the new representation of the change file. The features of all the changed files are used to construct the features of the code changes in a given commit.   This approach removes software practitioners from manually designing and extracting features, as done in previous work. The features extracted from the commit message and the code changes are then collectively used to train a model that can be used to evaluate whether a given commit is buggy or not. 

% our deep learning \emph{Just-In-Time} (JIT) defect prediction model (DeepJIT) aims to automatically extract features from both code changes and commit messages. These features are then collectively used to train a model that can be used to evaluate whether a given commit is buggy or not.
% % The key challenge here is to capture the semantic and syntactical structure of the code changes in the given commit. 
% Different from the commit message, the code changes is more complex as it includes a number of deleted and added lines across multiple files (see Figure~\ref{fig:example}). To solve this problem, we first learn the semantic features of each deleted or added line for each changed file using CNN framework, the semantic features of the added and deleted lines are then incorporated to build a new representation 
% % preserving the syntactical structure 
% of the change file. We again use CNN to extract features from the new representation of the change file. The features of all the changed files are used to construct the features of the code changes in a given commit.  

The main contributions of our paper include:
\begin{itemize}
    \item We propose an end-to-end deep learning framework (DeepJIT) to automatically extract features from both commit message and code changes in a given commit. DeepJIT is able to learn the semantic features from commit message and capture the semantic and syntactical structure of the code changes. 
    \item We evaluate DeepJIT on two software projects (i.e., QT and OPENSTACK). The  experiments show  the  superiority of DeepJIT compared to state-of-the-art baselines.
\end{itemize}
