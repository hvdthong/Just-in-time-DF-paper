\section{Introduction}
\label{sec:intro}
As software systems are becoming the backbone of our economy and society, defects existing in those systems may substantially affect businesses and people's lives  in many ways. For example, Knight Capital\footnote{https://dealbook.nytimes.com/2012/08/02/knight-capital-says-trading-mishap-cost-it-440-million/}, a company which executes automated trading  for retail brokers, lost \$440 millions in only one morning in 2012 due to an overnight faulty update to its trading software. A flawed code change, introduced into OpenSSL's source code repository, caused the infamous Heartbleed\footnote{http://heartbleed.com} bug which affected billions of Internet users in 2014. As software grows significantly in both size and complexity, finding defects and fixing them become increasingly difficult and costly.

One common best practice for cost saving is identifying defects and fixing them as early as possible, ideally before new code changes (i.e. \emph{commits}) are introduced into codebases. Emerging research has thus developed \emph{Just-In-Time} (JIT) defect prediction models and techniques which help software engineers and testers to quickly narrow down the most likely defective commits to a software codebase~\cite{KameiS16,D'Ambros:2012:EDP}. JIT defect prediction tools help provide early feedback to software developers to prioritize and optimize effort for inspection and (regression) testing, especially when facing with deadlines and limited resources. They have therefore been integrated into the development practice at large software organizations such as Avaya~\cite{Mockus2000}, Blackberry~\cite{Shihab:2012:ISR}, and Cisco~\cite{Tantithamthavorn:2015:IMP}.

Machine learning techniques have been widely used in existing work for building JIT defect prediction models. A common theme of existing work (e.g. \cite{Kamei:2013:LES,Kim:2008:CSC,Kononenko:2015,Mockus2000,McIntosh:2018:FCM}) is carefully crafting a set of features representing a code change, and using them as defectiveness predictors. Those features are mostly derived from properties of code changes, such as change size (e.g. lines added or deleted), change scope (e.g. number of files or directories modified), history of changes (e.g. number of prior changes to the updated files), track record of the author and code reviewers, and activeness of the code review of the change. This set of features is then used as an input to a traditional classifier (e.g. Random Forest or Logistic Regression) to predict the defectiveness of code changes A recent work \cite{Yang:2015:DLJ}  used a deep learning model (i.e. Deep Belief Network) to improve the performance of JIT defect prediction models. Their approach does not, however, leverage the true notions of deep learning. They still used the same set of features that are manually engineered as in previous work, and their model is \emph{not} end-to-end trainable.

The metric-based features however do not represent the semantic and syntactical structure of the actual code changes. In many cases, two different code changes which have exactly the same metrics (e.g. the number of lines added and deleted) may generate different behaviour when executed, and thus have a different likelihood of defectiveness. Previous studies have showed the usefulness of harvesting the syntactical structure and semantic information hidden in source code to perform various software engineering tasks such as code completion, bug detection and defect prediction \cite{Wang:2016:ALS,Tu:2014:LS,Nguyen:2015:GSL,Hindle:2012:NS,Li:2005:PAE}. This information may enrich representations for defective code changes, and thus improve JIT defect prediction.

In this paper, we present a new JIT defect prediction model (namely DeepJIT) which leverages the powerful deep learning Convolution Neural Network (CNN) architecture to learn a deep representation of commits. Our model processes both a commit message (in natural language) and the associated code changes (in programming languages) and automatically semantic features which represent the ``meaning'' of the commit. This approach removes software practitioners from manually designing and extracting features, as done in previous work. DeepJIT is a fully end-to-end trainable system where raw data signals (e.g. words or code tokens) are passed from input nodes up to the final output node for predicting defectiveness, and prediction errors are back propagated from the output node down to the input layer.
\cmt{TODOXXX: Results are summarized here ....}