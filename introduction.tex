\section{Introduction}
\label{sec:intro}
As software systems are becoming the backbone of our economy and society, defects existing in those systems may substantially affect businesses and people's lives  in many ways. For example, Knight Capital\footnote{https://dealbook.nytimes.com/2012/08/02/knight-capital-says-trading-mishap-cost-it-440-million/}, a company which executes automated trading  for retail brokers, lost $\$$440 millions in only one morning in 2012 due to an overnight faulty update to its trading software. A flawed code change, introduced into OpenSSL's source code repository, caused the infamous Heartbleed\footnote{http://heartbleed.com} bug which affected billions of Internet users in 2014. As software grows significantly in both size and complexity, finding defects and fixing them become increasingly difficult and costly.

One common best practice for cost saving is identifying defects and fixing them as early as possible, ideally before new code changes (i.e. \emph{commits}) are introduced into codebases. Emerging research has thus developed \emph{Just-In-Time} (JIT) defect prediction models and techniques which help software engineers and testers to quickly narrow down the most likely defective commits to a software codebase~\cite{KameiS16,D'Ambros:2012:EDP}. JIT defect prediction tools provide early feedback to software developers to prioritize and optimize effort for inspection and (regression) testing, especially when facing with deadlines and limited resources. They have therefore been integrated into the development practice at large software organizations such as Avaya~\cite{Mockus2000}, Blackberry~\cite{Shihab:2012:ISR}, and Cisco~\cite{Tantithamthavorn:2015:IMP}.

Machine learning techniques have been widely used in existing work for building JIT defect prediction models. A common theme of existing work (e.g.~\cite{Kamei:2013:LES,Kim:2008:CSC,Kononenko:2015,Mockus2000}) is carefully crafting a set of features to represent a code change, and using them as defectiveness predictors. Those features are mostly derived from properties of code changes, such as change size (e.g. lines deleted or added), change scope (e.g. number of files or directories modified), history of changes (e.g. number of prior changes to the updated files), track record of the author and code reviewers, and activeness of the code review of the change. This set of features can then be used as an input to a traditional classifier (e.g. Random Forests or Logistic Regression) to predict the defectiveness of code changes. 

The aforementioned metric-based features however do not represent the semantic and syntactic structure of the actual code changes. In many cases, two different code changes which have exactly the same metrics (e.g. the number of lines deleted and added) may generate different behaviour when executed, and thus have a different likelihood of defectiveness. Previous studies have showed the usefulness of harvesting the semantic information and syntactic structure hidden in source code to perform various software engineering tasks such as code completion, bug detection and defect prediction~\cite{Wang:2016:ALS,Tu:2014:LS,Nguyen:2015:GSL,Hindle:2012:NS,Li:2005:PAE}. This information may enrich representations for defective code changes, and thus improve JIT defect prediction.

A recent work~\cite{Yang:2015:DLJ}  used a deep learning model (i.e. Deep Belief Network) to improve the performance of JIT defect prediction models. However, their approach does not leverage the true notions of deep learning as they still employ the same set of features that are manually engineered as in previous work, and their model is \emph{not} end-to-end trainable.

% In this paper, we present a new JIT defect prediction model (namely DeepJIT) which leverages the powerful deep learning Convolution Neural Network (CNN) architecture to learn a deep representation of commits. Our model processes both a commit message (in natural language) and the associated code changes (in programming languages) and automatically semantic features which represent the ``meaning'' of the commit. This approach removes software practitioners from manually designing and extracting features, as done in previous work. DeepJIT is a fully end-to-end trainable system where raw data signals (e.g. words or code tokens) are passed from input nodes up to the final output node for predicting defectiveness, and prediction errors are back propagated from the output node down to the input layer.

To more fully explore the power of deep learning for JIT defect prediction, in this paper, we present a new model (named DeepJIT) which is built upon the well-known deep learning technique, namely Convolutional Neural Network (CNN)~\cite{lecun2015deep}. CNN has produced many breakthroughs in Natural Language Processing (NLP)~\cite{kim2014convolutional, dos2014deep, kalchbrenner2014convolutional, zhang2015character, johnson2014effective}.   
Our DeepJIT model processes both a commit message (in natural language) and the associated code changes (in programming languages) and automatically extracts features which represent the ``meaning'' of the commit. Unlike commit messages, code changes are more complex as they include a number of deleted and added lines across multiple files. We first learn the semantic features of each deleted or added line for each changed file using CNN framework. The features of the deleted and added lines are then incorporated to generate a new representation of the changed file. We again use CNN to extract features from the new representation of the changed file. The features of all the changed files are then used to construct the features of the code changes in a given commit. This approach removes the need for software practitioners to manually design and extract features, as what was done in previous work~\cite{mcintosh2018fix}. The features extracted from commit messages and code changes are then collectively used to train a model, and then predict whether a given commit is buggy or not. 

% our deep learning \emph{Just-In-Time} (JIT) defect prediction model (DeepJIT) aims to automatically extract features from both code changes and commit messages. These features are then collectively used to train a model that can be used to evaluate whether a given commit is buggy or not.
% % The key challenge here is to capture the semantic and syntactical structure of the code changes in the given commit. 
% Different from the commit message, the code changes is more complex as it includes a number of deleted and added lines across multiple files (see Figure~\ref{fig:example}). To solve this problem, we first learn the semantic features of each deleted or added line for each changed file using CNN framework, the semantic features of the added and deleted lines are then incorporated to build a new representation 
% % preserving the syntactical structure 
% of the change file. We again use CNN to extract features from the new representation of the change file. The features of all the changed files are used to construct the features of the code changes in a given commit.  

The main contributions of our paper include:
\begin{itemize}
    \item An end-to-end deep learning framework (DeepJIT) to automatically extract features from both commit messages and code changes in a given commit. 
    % DeepJIT is able to learn the semantic features from commit message and capture the semantic and syntactical structure of the code changes. 
    % DeepJIT follows the syntactical structure of the code changes to extract 
    \item An evaluation of DeepJIT on two software projects (i.e., QT and OPENSTACK). This dataset was originally collected by McIntosh and Kamei to evaluate their proposed technique~\cite{mcintosh2018fix} that we use as one of the baselines. The  experiments show the  superiority of DeepJIT compared to state-of-the-art baselines.
\end{itemize}
